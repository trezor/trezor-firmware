<%
BKSL = "\\"

networks = list(supported_on("trezor1", eth))
max_chain_id_length = 0
max_slip44_length = 0
max_suffix_length = 0
for n in networks:
	max_chain_id_length = max(len(str(n.chain_id)), max_chain_id_length)
	max_slip44_length = max(len(str(n.slip44)), max_slip44_length)
	max_suffix_length = max(len(n.shortcut), max_suffix_length)

def align_chain_id(n):
	return "{:>{w}}".format(n.chain_id, w=max_chain_id_length)

def align_slip44(n):
	return "{:>{w}}".format(n.slip44, w=max_slip44_length)

def align_suffix(n):
	cstr = c_str(" " + n.shortcut) + ";"
	# we add two quotes, a space and a semicolon. hence +4 chars
	return "{:<{w}}".format(cstr, w=max_suffix_length + 4)

%>\
// This file is automatically generated from ethereum_networks.h.mako
// DO NOT EDIT

#ifndef __ETHEREUM_NETWORKS_H__
#define __ETHEREUM_NETWORKS_H__

#define SLIP44_UNKNOWN UINT32_MAX

#define ASSIGN_ETHEREUM_SUFFIX(suffix, chain_id) ${BKSL}
  switch (chain_id) { ${BKSL}
% for n in networks:
    case ${align_chain_id(n)}: suffix = ${align_suffix(n)} break;  /* ${n.name} */ ${BKSL}
% endfor
    default: suffix = " UNKN"; break;  /* unknown chain */ ${BKSL}
  }

static bool is_ethereum_slip44(uint32_t slip44) {
  switch (slip44) {
% for slip44 in sorted(set(n.slip44 for n in networks)):
    case ${slip44}:
% endfor
      return true;
    default:
      return false;
  }
}

static int32_t ethereum_slip44_by_chain_id(uint64_t chain_id) {
  switch (chain_id) {
% for n in networks:
    case ${align_chain_id(n)}: return ${align_slip44(n)};  /* ${n.name} */
% endfor
    default: return SLIP44_UNKNOWN;  /* unknown chain */
  }
}

#endif
