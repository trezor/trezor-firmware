syntax = "proto2";
package hw.trezor.messages.cosmos;

// Sugar for easier handling in Java
option java_package = "com.satoshilabs.trezor.lib.protobuf";
option java_outer_classname = "TrezorMessageCosmos";

/**
 * Request: Ask device for Cosmos address corresponding to address_n path and prefix bech32 prefix
 * @start
 * @next CosmosAddress
 * @next Failure
 */
message CosmosGetAddress {
    repeated uint32 address_n = 1;      // BIP-32 path to derive the key from master node
    required string prefix = 2;                  // bech32 prefix
    optional bool show_display = 3;     // optionally show on display before sending the result
}

/**
 * Response: Contains a Cosmos address derived from device private seed
 * @end
 */
message CosmosAddress {
    optional string address = 1;                       // Cosmos address as bech32 string
}

/**
 * Request: Ask device for Cosmos public key corresponding to address_n path
 * @start
 * @next CosmosPublicKey
 * @next Failure
 */
message CosmosGetPublicKey {
    repeated uint32 address_n = 1;      // BIP-32 path to derive the key from master node
    optional bool show_display = 2;     // optionally show on display before sending the result
}

/**
 * Response: Contains a Cosmos public key derived from device private seed
 * @end
 */
message CosmosPublicKey {
    required string type = 1;
    required bytes value = 2;                       // Cosmos public key bytes
}

/**
 * Request: Ask device to sign transaction
 * @start
 * @next CosmosSignedTx
 * @next Failure
 */
message CosmosSignTx {
    repeated uint32 address_n = 1;                      // BIP-32 path to derive the key from master node
    required bytes sign_doc = 2;                        // SignDoc serialized using ADR 027. This is the exact bytes that will be hashed and signed. This is also deserialized on device for validation and user confirmation.
}

/**
 * Response: Contains the signature of a transaction
 * @end
 */
message CosmosSignedTx {
    required bytes signature = 1;
}

// below: internal messages to decode sign doc and do clear-signing

message CosmosSignDoc {
    required bytes body_bytes = 1;
    required bytes auth_info_bytes = 2;
    required string chain_id = 3;
    required uint64 account_number = 4;
}

message CosmosAuthInfo {
    repeated CosmosSignerInfo signer_infos = 1;
    required CosmosFee fee = 2;
}

message CosmosSignerInfo {
    required CosmosAny public_key = 1;
    required CosmosModeInfo mode_info = 2;
    required uint64 sequence = 3;
}

message CosmosModeInfo {
    required CosmosModeInfoSingle single = 1;
}

message CosmosModeInfoSingle {
    required CosmosSignMode mode = 1;
}

message CosmosTxBody {
    repeated CosmosAny messages = 1;
    optional string memo = 2;
    optional uint64 timeout_height = 3;
    // repeated CosmosAny extension_options = 1023;
    // repeated CosmosAny non_critical_extension_options = 2047;
}

message CosmosBankMsgSend {
    required string from_address = 1;
    required string to_address = 2;
    repeated CosmosCoin amount = 3;
}

enum CosmosSignMode {
    // SIGN_MODE_UNSPECIFIED = 0;
    SIGN_MODE_DIRECT = 1;
    // SIGN_MODE_TEXTUAL = 2;
    // SIGN_MODE_LEGACY_AMINO_JSON = 127;
}

message CosmosFee {
    repeated CosmosCoin amount = 1;
    required uint64 gas_limit = 2;
    optional string payer = 3;
    optional string granter = 4;
}

message CosmosCoin {
    required string denom = 1;
    required string amount = 2;
}

message CosmosSecp256k1Pubkey {
    required bytes key = 1;
}

message CosmosAny {
  required string type_url = 1;

  // Must be a valid serialized protocol buffer of the above specified type.
  required bytes value = 2;
}