syntax = "proto2";
package hw.trezor.messages.stellar;

// Sugar for easier handling in Java
option java_package = "com.satoshilabs.trezor.lib.protobuf";
option java_outer_classname = "TrezorMessageStellar";

// https://github.com/stellar/stellar-core/blob/02d26858069de7c0eefe065056fb0a19bf72ea56/src/xdr/Stellar-ledger-entries.x#L25-L31
enum StellarAssetType {
    NATIVE = 0;
    ALPHANUM4 = 1;
    ALPHANUM12 = 2;
}

/**
 * Describes a Stellar asset
 * @embed
 */
message StellarAsset {
    required StellarAssetType type = 1;
    optional string code = 2;       // for non-native assets, string describing the code
    optional string issuer = 3;     // issuing address

}

/**
 * Request: Address at the specified index
 * @start
 * @next StellarAddress
 */
message StellarGetAddress {
    repeated uint32 address_n = 1;  // BIP-32 path. For compatibility with other wallets, must be m/44'/148'/index'
    optional bool show_display = 2; // optionally show on display before sending the result
    optional bool chunkify = 3;     // display the address in chunks of 4 characters
}

/**
 * Response: Address for the given index
 * @end
 */
message StellarAddress {
    required string address = 1;    // Address in Stellar format (base32 of a pubkey with checksum)
}

/**
 * Request: ask device to sign Stellar transaction
 * @start
 * @next StellarTxOpRequest
 */
message StellarSignTx {
    repeated uint32 address_n = 2;           // BIP-32 path. For compatibility with other wallets, must be m/44'/148'/index'
    required string network_passphrase = 3;  // passphrase for signing messages on the destination network
    required string source_account = 4;      // source account address
    required uint32 fee = 5;                 // Fee (in stroops) for the transaction
    required uint64 sequence_number = 6;     // transaction sequence number
    required uint32 timebounds_start = 8;    // unix timestamp (client must truncate this to 32 bytes)
    required uint32 timebounds_end = 9;      // unix timestamp (client must truncate this to 32 bytes)
    required StellarMemoType memo_type = 10; // type of memo attached to the transaction
    optional string memo_text = 11;          // up to 28 characters (4 bytes are for length)
    optional uint64 memo_id = 12;            // 8-byte uint64
    optional bytes memo_hash = 13;           // 32 bytes representing a hash
    required uint32 num_operations = 14;     // number of operations in this transaction

    // https://github.com/stellar/stellar-core/blob/02d26858069de7c0eefe065056fb0a19bf72ea56/src/xdr/Stellar-transaction.x#L506-L513
    enum StellarMemoType {
        NONE = 0;
        TEXT = 1;
        ID = 2;
        HASH = 3;
        RETURN = 4;
    }
}

/**
 * Response: device is ready for client to send the next operation
 * @next StellarPaymentOp
 * @next StellarCreateAccountOp
 * @next StellarPathPaymentStrictReceiveOp
 * @next StellarPathPaymentStrictSendOp
 * @next StellarManageSellOfferOp
 * @next StellarManageBuyOfferOp
 * @next StellarCreatePassiveSellOfferOp
 * @next StellarSetOptionsOp
 * @next StellarChangeTrustOp
 * @next StellarAllowTrustOp
 * @next StellarAccountMergeOp
 * @next StellarManageDataOp
 * @next StellarBumpSequenceOp
 * @next StellarClaimClaimableBalanceOp
 * @next StellarInvokeHostFunctionOp
 */
message StellarTxOpRequest {
}

/**
 * Request: ask device to confirm this operation type
 * @next StellarTxOpRequest
 * @next StellarTxExtRequest
 */
message StellarPaymentOp {
    optional string source_account = 1;         // (optional) source account address
    required string destination_account = 2;    // destination account address
    required StellarAsset asset = 3;        // asset involved in the operation
    required sint64 amount = 4;                 // amount of the given asset to pay
}

/**
 * Request: ask device to confirm this operation type
 * @next StellarTxOpRequest
 * @next StellarTxExtRequest
 */
message StellarCreateAccountOp {
    optional string source_account = 1;     // (optional) source account address
    required string new_account = 2;        // account address to create
    required sint64 starting_balance = 3;   // initial starting balance for the new account
}

/**
 * Request: ask device to confirm this operation type
 * @next StellarTxOpRequest
 * @next StellarTxExtRequest
 */
message StellarPathPaymentStrictReceiveOp {
    optional string source_account = 1;           // (optional) source address
    required StellarAsset send_asset = 2;         // asset we pay with
    required sint64 send_max = 3;                 // the maximum amount of sendAsset to send (excluding fees)
    required string destination_account = 4;      // recipient of the payment
    required StellarAsset destination_asset = 5;  // what they end up with
    required sint64 destination_amount = 6;       // amount they end up with
    repeated StellarAsset paths = 7;              // additional hops it must go through to get there
}

/**
 * Request: ask device to confirm this operation type
 * @next StellarTxOpRequest
 * @next StellarTxExtRequest
 */
message StellarPathPaymentStrictSendOp {
    optional string source_account = 1;           // (optional) source address
    required StellarAsset send_asset = 2;         // asset we pay with
    required sint64 send_amount = 3;              // amount of sendAsset to send (excluding fees)
    required string destination_account = 4;      // recipient of the payment
    required StellarAsset destination_asset = 5;  // what they end up with
    required sint64 destination_min = 6;          // the minimum amount of dest asset to be received
    repeated StellarAsset paths = 7;              //additional hops it must go through to get there
}

/**
 * Request: ask device to confirm this operation type
 * @next StellarTxOpRequest
 * @next StellarTxExtRequest
 */
message StellarManageSellOfferOp {
    optional string source_account = 1;             // (optional) source account address
    required StellarAsset selling_asset = 2;
    required StellarAsset buying_asset = 3;
    required sint64 amount = 4;
    required uint32 price_n = 5;                    // Price numerator
    required uint32 price_d = 6;                    // Price denominator
    required uint64 offer_id = 7;                   // Offer ID for updating an existing offer
}

/**
 * Request: ask device to confirm this operation type
 * @next StellarTxOpRequest
 * @next StellarTxExtRequest
 */
message StellarManageBuyOfferOp {
    optional string source_account = 1;             // (optional) source account address
    required StellarAsset selling_asset = 2;
    required StellarAsset buying_asset = 3;
    required sint64 amount = 4;
    required uint32 price_n = 5;                    // Price numerator
    required uint32 price_d = 6;                    // Price denominator
    required uint64 offer_id = 7;                   // Offer ID for updating an existing offer
}

/**
 * Request: ask device to confirm this operation type
 * @next StellarTxOpRequest
 * @next StellarTxExtRequest
 */
message StellarCreatePassiveSellOfferOp {
    optional string source_account = 1;             // (optional) source account address
    required StellarAsset selling_asset = 2;
    required StellarAsset buying_asset = 3;
    required sint64 amount = 4;
    required uint32 price_n = 5;                    // Price numerator
    required uint32 price_d = 6;                    // Price denominator
}

/**
 * Request: ask device to confirm this operation type
 * @next StellarTxOpRequest
 * @next StellarTxExtRequest
 */
message StellarSetOptionsOp {
    optional string source_account = 1;                 // (optional) source account address
    optional string inflation_destination_account = 2;  // (optional) inflation destination address
    optional uint32 clear_flags = 3;
    optional uint32 set_flags = 4;
    optional uint32 master_weight = 5;
    optional uint32 low_threshold = 6;
    optional uint32 medium_threshold = 7;
    optional uint32 high_threshold = 8;
    optional string home_domain = 9;
    optional StellarSignerType signer_type = 10;
    optional bytes signer_key = 11;
    optional uint32 signer_weight = 12;

    // https://github.com/stellar/stellar-core/blob/02d26858069de7c0eefe065056fb0a19bf72ea56/src/xdr/Stellar-types.x#L32-L37
    enum StellarSignerType {
        ACCOUNT = 0;
        PRE_AUTH = 1;
        HASH = 2;
    }
}

/**
 * Request: ask device to confirm this operation type
 * @next StellarTxOpRequest
 * @next StellarTxExtRequest
 */
message StellarChangeTrustOp {
    optional string source_account = 1;     // (optional) source account address
    required StellarAsset asset = 2;
    required uint64 limit = 3;
}

/**
 * Request: ask device to confirm this operation type
 * @next StellarTxOpRequest
 * @next StellarTxExtRequest
 */
message StellarAllowTrustOp {
    optional string source_account = 1;     // (optional) source account address
    required string trusted_account = 2;    // The account being allowed to hold the asset
    required StellarAssetType asset_type = 3;
    optional string asset_code = 4;         // human-readable asset code
    required bool is_authorized = 5;
}

/**
 * Request: ask device to confirm this operation type
 * @next StellarTxOpRequest
 * @next StellarTxExtRequest
 */
message StellarAccountMergeOp {
    optional string source_account = 1;         // (optional) source account address
    required string destination_account = 2;    // destination account address
}

/**
 * Request: ask device to confirm this operation type
 * @next StellarTxOpRequest
 * @next StellarTxExtRequest
 */
message StellarManageDataOp {
    optional string source_account = 1; // (optional) source account address
    required string key = 2;
    optional bytes value = 3;           // 64 bytes of arbitrary data
}

/**
 * Request: ask device to confirm this operation type
 * @next StellarTxOpRequest
 * @next StellarTxExtRequest
 */
message StellarBumpSequenceOp {
    optional string source_account = 1; // (optional) source account address
    required uint64 bump_to = 2;        // new sequence number
}

/**
 * Request: ask device to confirm this operation type
 * @next StellarTxOpRequest
 * @next StellarTxExtRequest
 */
message StellarClaimClaimableBalanceOp {
    optional string source_account = 1; // (optional) source account address
    required bytes balance_id = 2;      // balance id, 4 bytes of type flag, 32 bytes of data
}

/**
 * Response: signature for transaction
 * @end
 */
message StellarSignedTx {
    required bytes public_key = 1;  // public key for the private key used to sign data
    required bytes signature = 2;   // signature suitable for sending to the Stellar network
}

/**
 * Describes a Stellar SCValue
 * See https://github.com/stellar/stellar-xdr/blob/bb54e505f814386a3f45172e0b7e95b7badbe969/Stellar-contract.x#L214
 * @embed
 */
message StellarSCVal {
    required StellarSCValType type = 1;
    optional bool b = 2; // SCV_VOID
    reserved 3; // SCV_ERROR, not supported yet
    optional uint32 u32 = 4; // SCV_U32
    optional sint32 i32 = 5; // SCV_I32
    optional uint64 u64 = 6; // SCV_U64
    optional sint64 i64 = 7; // SCV_I64
    optional uint64 timepoint = 8; // SCV_TIMEPOINT
    optional uint64 duration = 9; // SCV_DURATION
    optional StellarUInt128Parts u128 = 10; // SCV_U128
    optional StellarInt128Parts i128 = 11; // SCV_I128
    optional StellarUInt256Parts u256 = 12; // SCV_U256
    optional StellarInt256Parts i256 = 13; // SCV_I256
    optional bytes bytes = 14; // SCV_BYTES
    optional string string = 15; // SCV_STRING, We do not allow sending binary data here, which is the same as how memo_text is handled, see: https://github.com/trezor/trezor-firmware/issues/610
    optional string symbol = 16; // SCV_SYMBOL
    repeated StellarSCVal vec = 17; // SCV_VEC
    repeated StellarSCValMapEntry map = 18; // SCV_MAP
    optional StellarSCAddress address = 19; // SCV_ADDRESS
    reserved 20; // SCV_LEDGER_KEY_NONCE, not supported yet
    reserved 21; // SCV_CONTRACT_INSTANCE, not supported yet

    message StellarUInt128Parts {
        required uint64 hi = 1;
        required uint64 lo = 2;
    }

    message StellarInt128Parts {
        required sint64 hi = 1;
        required uint64 lo = 2;
    }

    message StellarUInt256Parts {
        required uint64 hi_hi = 1;
        required uint64 hi_lo = 2;
        required uint64 lo_hi = 3;
        required uint64 lo_lo = 4;
    }

    message StellarInt256Parts {
        required sint64 hi_hi = 1;
        required uint64 hi_lo = 2;
        required uint64 lo_hi = 3;
        required uint64 lo_lo = 4;
    }

    message StellarSCAddress {
        required StellarSCAddressType type = 1;
        required string address = 2; // stellar account address (G...) or contract address (C...), TODO: bytes?

        enum StellarSCAddressType
        {
            SC_ADDRESS_TYPE_ACCOUNT = 0;
            SC_ADDRESS_TYPE_CONTRACT = 1;
        };
    }

    message StellarSCValMapEntry {
        optional StellarSCVal key = 1;
        optional StellarSCVal value = 2;
    }

    enum StellarSCValType {
        SCV_BOOL = 0;
        SCV_VOID = 1;
        reserved 2; // SCV_ERROR, not supported yet
        SCV_U32 = 3;
        SCV_I32 = 4;
        SCV_U64 = 5;
        SCV_I64 = 6;
        SCV_TIMEPOINT = 7;
        SCV_DURATION = 8;
        SCV_U128 = 9;
        SCV_I128 = 10;
        SCV_U256 = 11;
        SCV_I256 = 12;
        SCV_BYTES = 13;
        SCV_STRING = 14;
        SCV_SYMBOL = 15;
        SCV_VEC = 16;
        SCV_MAP = 17;
        SCV_ADDRESS = 18;
        reserved 19; // SCV_CONTRACT_INSTANCE, not supported yet
        reserved 20; // SCV_LEDGER_KEY_NONCE, not supported yet
        reserved 21; // SCV_LEDGER_KEY_CONTRACT_INSTANCE, not supported yet
    }
}

/**
 * https://github.com/stellar/stellar-xdr/blob/bb54e505f814386a3f45172e0b7e95b7badbe969/Stellar-transaction.x#L506
 * @embed
 */
message StellarInvokeContractArgs {
    required StellarSCVal.StellarSCAddress contract_address = 1;
    required string function_name = 2;
    repeated StellarSCVal args = 3;
}

/**
 * https://github.com/stellar/stellar-xdr/blob/bb54e505f814386a3f45172e0b7e95b7badbe969/Stellar-transaction.x#L528
 * @embed
 */
message StellarSorobanAuthorizedFunction {
    required StellarSorobanAuthorizedFunctionType type = 1;
    optional StellarInvokeContractArgs contract_fn = 2;

    enum StellarSorobanAuthorizedFunctionType {
        SOROBAN_AUTHORIZED_FUNCTION_TYPE_CONTRACT_FN = 0;
        SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_HOST_FN = 1; // Creating a contract can be done using any address without security issues, so we will not provide support for it at this time.
    }
}

/**
 * https://github.com/stellar/stellar-xdr/blob/bb54e505f814386a3f45172e0b7e95b7badbe969/Stellar-transaction.x#L536
 * @embed
 */
message StellarSorobanAuthorizedInvocation {
    required StellarSorobanAuthorizedFunction function = 1;
    repeated StellarSorobanAuthorizedInvocation sub_invocations = 2;
}

/**
 * https://github.com/stellar/stellar-xdr/blob/bb54e505f814386a3f45172e0b7e95b7badbe969/Stellar-transaction.x#L580
 * @embed
 */
message StellarHostFunction {
    required StellarHostFunctionType type = 1;
    optional StellarInvokeContractArgs invoke_contract = 2;

    enum StellarHostFunctionType
    {
        HOST_FUNCTION_TYPE_INVOKE_CONTRACT = 0; // We only support this type of host function at this time.
        HOST_FUNCTION_TYPE_CREATE_CONTRACT = 1;
        HOST_FUNCTION_TYPE_UPLOAD_CONTRACT_WASM = 2;
    }
}

/**
 * https://github.com/stellar/stellar-xdr/blob/bb54e505f814386a3f45172e0b7e95b7badbe969/Stellar-transaction.x#L542
 * @embed
 */
message StellarSorobanAddressCredentials {
    required StellarSCVal.StellarSCAddress address = 1;
    required sint64 nonce = 2;
    required uint32 signature_expiration_ledger = 3;
    required StellarSCVal signature = 4;
}

/**
 * https://github.com/stellar/stellar-xdr/blob/bb54e505f814386a3f45172e0b7e95b7badbe969/Stellar-transaction.x#L556
 * @embed
 */
message StellarSorobanCredentials {
    required StellarSorobanCredentialsType type = 1;
    optional StellarSorobanAddressCredentials address = 2;

    enum StellarSorobanCredentialsType
    {
        SOROBAN_CREDENTIALS_SOURCE_ACCOUNT = 0;
        SOROBAN_CREDENTIALS_ADDRESS = 1;
    };
}

/**
 * https://github.com/stellar/stellar-xdr/blob/bb54e505f814386a3f45172e0b7e95b7badbe969/Stellar-transaction.x#L569
 * @embed
 */
message StellarSorobanAuthorizationEntry {
    required StellarSorobanCredentials credentials = 1;
    required StellarSorobanAuthorizedInvocation root_invocation = 2;
}

/**
 * Request: ask device to confirm this operation type
 * @next StellarTxOpRequest
 * @next StellarTxExtRequest
 */
message StellarInvokeHostFunctionOp {
    optional string source_account = 1; // (optional) source account address
    required StellarHostFunction function = 2;
    repeated StellarSorobanAuthorizationEntry auth = 3;
}

/**
 * Response: device is ready for client to send StellarTxExt
 * @next StellarTxExt
 */
message StellarTxExtRequest {
}

/**
 * Request: ask device to add extra data to the transaction
 * @next StellarSignedTx
 */
message StellarTxExt {
    // For soroban transactions, v = 1
    required sint32 v = 1;
    optional bytes soroban_data = 2; // (optional) soroban data, exists only if v == 1
}

/**
 * Request: ask device to sign Stellar Soroban authorization
 * https://github.com/stellar/stellar-xdr/blob/bb54e505f814386a3f45172e0b7e95b7badbe969/Stellar-transaction.x#L702-L710
 * @start
 * @next StellarSignedTx
 */
message StellarSignSorobanAuthorization {
    repeated uint32 address_n = 1;  // BIP-32 path. For compatibility with other wallets, must be m/44'/148'/index'
    required string network_passphrase = 2;  // passphrase for signing messages on the destination network
    required sint64 nonce = 3;  // nonce for the authorization
    required uint32 signature_expiration_ledger = 4;  // ledger number after which the signature expires
    required StellarSorobanAuthorizedInvocation invocation = 5;  // the invocation to authorize
}
