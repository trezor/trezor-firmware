// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc 3.19.6
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `messages-monero.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionSourceEntry)
pub struct MoneroTransactionSourceEntry {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.outputs)
    pub outputs: ::std::vec::Vec<monero_transaction_source_entry::MoneroOutputEntry>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_output)
    pub real_output: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_tx_key)
    pub real_out_tx_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
    pub real_out_additional_tx_keys: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_output_in_tx_index)
    pub real_output_in_tx_index: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.amount)
    pub amount: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.rct)
    pub rct: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.mask)
    pub mask: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.multisig_kLRki)
    pub multisig_kLRki: ::protobuf::MessageField<monero_transaction_source_entry::MoneroMultisigKLRki>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.subaddr_minor)
    pub subaddr_minor: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSourceEntry {
    fn default() -> &'a MoneroTransactionSourceEntry {
        <MoneroTransactionSourceEntry as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSourceEntry {
    pub fn new() -> MoneroTransactionSourceEntry {
        ::std::default::Default::default()
    }

    // optional uint64 real_output = 2;

    pub fn real_output(&self) -> u64 {
        self.real_output.unwrap_or(0)
    }

    pub fn clear_real_output(&mut self) {
        self.real_output = ::std::option::Option::None;
    }

    pub fn has_real_output(&self) -> bool {
        self.real_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_real_output(&mut self, v: u64) {
        self.real_output = ::std::option::Option::Some(v);
    }

    // optional bytes real_out_tx_key = 3;

    pub fn real_out_tx_key(&self) -> &[u8] {
        match self.real_out_tx_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_real_out_tx_key(&mut self) {
        self.real_out_tx_key = ::std::option::Option::None;
    }

    pub fn has_real_out_tx_key(&self) -> bool {
        self.real_out_tx_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_real_out_tx_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.real_out_tx_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_real_out_tx_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.real_out_tx_key.is_none() {
            self.real_out_tx_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.real_out_tx_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_real_out_tx_key(&mut self) -> ::std::vec::Vec<u8> {
        self.real_out_tx_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 real_output_in_tx_index = 5;

    pub fn real_output_in_tx_index(&self) -> u64 {
        self.real_output_in_tx_index.unwrap_or(0)
    }

    pub fn clear_real_output_in_tx_index(&mut self) {
        self.real_output_in_tx_index = ::std::option::Option::None;
    }

    pub fn has_real_output_in_tx_index(&self) -> bool {
        self.real_output_in_tx_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_real_output_in_tx_index(&mut self, v: u64) {
        self.real_output_in_tx_index = ::std::option::Option::Some(v);
    }

    // optional uint64 amount = 6;

    pub fn amount(&self) -> u64 {
        self.amount.unwrap_or(0)
    }

    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: u64) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional bool rct = 7;

    pub fn rct(&self) -> bool {
        self.rct.unwrap_or(false)
    }

    pub fn clear_rct(&mut self) {
        self.rct = ::std::option::Option::None;
    }

    pub fn has_rct(&self) -> bool {
        self.rct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rct(&mut self, v: bool) {
        self.rct = ::std::option::Option::Some(v);
    }

    // optional bytes mask = 8;

    pub fn mask(&self) -> &[u8] {
        match self.mask.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mask(&mut self) {
        self.mask = ::std::option::Option::None;
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: ::std::vec::Vec<u8>) {
        self.mask = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mask(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mask.is_none() {
            self.mask = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_mask(&mut self) -> ::std::vec::Vec<u8> {
        self.mask.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 subaddr_minor = 10;

    pub fn subaddr_minor(&self) -> u32 {
        self.subaddr_minor.unwrap_or(0)
    }

    pub fn clear_subaddr_minor(&mut self) {
        self.subaddr_minor = ::std::option::Option::None;
    }

    pub fn has_subaddr_minor(&self) -> bool {
        self.subaddr_minor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subaddr_minor(&mut self, v: u32) {
        self.subaddr_minor = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "outputs",
            |m: &MoneroTransactionSourceEntry| { &m.outputs },
            |m: &mut MoneroTransactionSourceEntry| { &mut m.outputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "real_output",
            |m: &MoneroTransactionSourceEntry| { &m.real_output },
            |m: &mut MoneroTransactionSourceEntry| { &mut m.real_output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "real_out_tx_key",
            |m: &MoneroTransactionSourceEntry| { &m.real_out_tx_key },
            |m: &mut MoneroTransactionSourceEntry| { &mut m.real_out_tx_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "real_out_additional_tx_keys",
            |m: &MoneroTransactionSourceEntry| { &m.real_out_additional_tx_keys },
            |m: &mut MoneroTransactionSourceEntry| { &mut m.real_out_additional_tx_keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "real_output_in_tx_index",
            |m: &MoneroTransactionSourceEntry| { &m.real_output_in_tx_index },
            |m: &mut MoneroTransactionSourceEntry| { &mut m.real_output_in_tx_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "amount",
            |m: &MoneroTransactionSourceEntry| { &m.amount },
            |m: &mut MoneroTransactionSourceEntry| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rct",
            |m: &MoneroTransactionSourceEntry| { &m.rct },
            |m: &mut MoneroTransactionSourceEntry| { &mut m.rct },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mask",
            |m: &MoneroTransactionSourceEntry| { &m.mask },
            |m: &mut MoneroTransactionSourceEntry| { &mut m.mask },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, monero_transaction_source_entry::MoneroMultisigKLRki>(
            "multisig_kLRki",
            |m: &MoneroTransactionSourceEntry| { &m.multisig_kLRki },
            |m: &mut MoneroTransactionSourceEntry| { &mut m.multisig_kLRki },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subaddr_minor",
            |m: &MoneroTransactionSourceEntry| { &m.subaddr_minor },
            |m: &mut MoneroTransactionSourceEntry| { &mut m.subaddr_minor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionSourceEntry>(
            "MoneroTransactionSourceEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionSourceEntry {
    const NAME: &'static str = "MoneroTransactionSourceEntry";

    fn is_initialized(&self) -> bool {
        for v in &self.outputs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.multisig_kLRki {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.outputs.push(is.read_message()?);
                },
                16 => {
                    self.real_output = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.real_out_tx_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.real_out_additional_tx_keys.push(is.read_bytes()?);
                },
                40 => {
                    self.real_output_in_tx_index = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.amount = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.rct = ::std::option::Option::Some(is.read_bool()?);
                },
                66 => {
                    self.mask = ::std::option::Option::Some(is.read_bytes()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.multisig_kLRki)?;
                },
                80 => {
                    self.subaddr_minor = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.real_output {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.real_out_tx_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        for value in &self.real_out_additional_tx_keys {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        if let Some(v) = self.real_output_in_tx_index {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.rct {
            my_size += 1 + 1;
        }
        if let Some(v) = self.mask.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.multisig_kLRki.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.subaddr_minor {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.outputs {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.real_output {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.real_out_tx_key.as_ref() {
            os.write_bytes(3, v)?;
        }
        for v in &self.real_out_additional_tx_keys {
            os.write_bytes(4, &v)?;
        };
        if let Some(v) = self.real_output_in_tx_index {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.amount {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.rct {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.mask.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.multisig_kLRki.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.subaddr_minor {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionSourceEntry {
        MoneroTransactionSourceEntry::new()
    }

    fn clear(&mut self) {
        self.outputs.clear();
        self.real_output = ::std::option::Option::None;
        self.real_out_tx_key = ::std::option::Option::None;
        self.real_out_additional_tx_keys.clear();
        self.real_output_in_tx_index = ::std::option::Option::None;
        self.amount = ::std::option::Option::None;
        self.rct = ::std::option::Option::None;
        self.mask = ::std::option::Option::None;
        self.multisig_kLRki.clear();
        self.subaddr_minor = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionSourceEntry {
        static instance: MoneroTransactionSourceEntry = MoneroTransactionSourceEntry {
            outputs: ::std::vec::Vec::new(),
            real_output: ::std::option::Option::None,
            real_out_tx_key: ::std::option::Option::None,
            real_out_additional_tx_keys: ::std::vec::Vec::new(),
            real_output_in_tx_index: ::std::option::Option::None,
            amount: ::std::option::Option::None,
            rct: ::std::option::Option::None,
            mask: ::std::option::Option::None,
            multisig_kLRki: ::protobuf::MessageField::none(),
            subaddr_minor: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionSourceEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionSourceEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionSourceEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSourceEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MoneroTransactionSourceEntry`
pub mod monero_transaction_source_entry {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry)
    pub struct MoneroOutputEntry {
        // message fields
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.idx)
        pub idx: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.key)
        pub key: ::protobuf::MessageField<monero_output_entry::MoneroRctKeyPublic>,
        // special fields
        // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MoneroOutputEntry {
        fn default() -> &'a MoneroOutputEntry {
            <MoneroOutputEntry as ::protobuf::Message>::default_instance()
        }
    }

    impl MoneroOutputEntry {
        pub fn new() -> MoneroOutputEntry {
            ::std::default::Default::default()
        }

        // optional uint64 idx = 1;

        pub fn idx(&self) -> u64 {
            self.idx.unwrap_or(0)
        }

        pub fn clear_idx(&mut self) {
            self.idx = ::std::option::Option::None;
        }

        pub fn has_idx(&self) -> bool {
            self.idx.is_some()
        }

        // Param is passed by value, moved
        pub fn set_idx(&mut self, v: u64) {
            self.idx = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "idx",
                |m: &MoneroOutputEntry| { &m.idx },
                |m: &mut MoneroOutputEntry| { &mut m.idx },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, monero_output_entry::MoneroRctKeyPublic>(
                "key",
                |m: &MoneroOutputEntry| { &m.key },
                |m: &mut MoneroOutputEntry| { &mut m.key },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroOutputEntry>(
                "MoneroTransactionSourceEntry.MoneroOutputEntry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MoneroOutputEntry {
        const NAME: &'static str = "MoneroOutputEntry";

        fn is_initialized(&self) -> bool {
            for v in &self.key {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.idx = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.idx {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.key.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.idx {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.key.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MoneroOutputEntry {
            MoneroOutputEntry::new()
        }

        fn clear(&mut self) {
            self.idx = ::std::option::Option::None;
            self.key.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MoneroOutputEntry {
            static instance: MoneroOutputEntry = MoneroOutputEntry {
                idx: ::std::option::Option::None,
                key: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MoneroOutputEntry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MoneroTransactionSourceEntry.MoneroOutputEntry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MoneroOutputEntry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MoneroOutputEntry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `MoneroOutputEntry`
    pub mod monero_output_entry {
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic)
        pub struct MoneroRctKeyPublic {
            // message fields
            // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.dest)
            pub dest: ::std::option::Option<::std::vec::Vec<u8>>,
            // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.commitment)
            pub commitment: ::std::option::Option<::std::vec::Vec<u8>>,
            // special fields
            // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a MoneroRctKeyPublic {
            fn default() -> &'a MoneroRctKeyPublic {
                <MoneroRctKeyPublic as ::protobuf::Message>::default_instance()
            }
        }

        impl MoneroRctKeyPublic {
            pub fn new() -> MoneroRctKeyPublic {
                ::std::default::Default::default()
            }

            // required bytes dest = 1;

            pub fn dest(&self) -> &[u8] {
                match self.dest.as_ref() {
                    Some(v) => v,
                    None => &[],
                }
            }

            pub fn clear_dest(&mut self) {
                self.dest = ::std::option::Option::None;
            }

            pub fn has_dest(&self) -> bool {
                self.dest.is_some()
            }

            // Param is passed by value, moved
            pub fn set_dest(&mut self, v: ::std::vec::Vec<u8>) {
                self.dest = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_dest(&mut self) -> &mut ::std::vec::Vec<u8> {
                if self.dest.is_none() {
                    self.dest = ::std::option::Option::Some(::std::vec::Vec::new());
                }
                self.dest.as_mut().unwrap()
            }

            // Take field
            pub fn take_dest(&mut self) -> ::std::vec::Vec<u8> {
                self.dest.take().unwrap_or_else(|| ::std::vec::Vec::new())
            }

            // required bytes commitment = 2;

            pub fn commitment(&self) -> &[u8] {
                match self.commitment.as_ref() {
                    Some(v) => v,
                    None => &[],
                }
            }

            pub fn clear_commitment(&mut self) {
                self.commitment = ::std::option::Option::None;
            }

            pub fn has_commitment(&self) -> bool {
                self.commitment.is_some()
            }

            // Param is passed by value, moved
            pub fn set_commitment(&mut self, v: ::std::vec::Vec<u8>) {
                self.commitment = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_commitment(&mut self) -> &mut ::std::vec::Vec<u8> {
                if self.commitment.is_none() {
                    self.commitment = ::std::option::Option::Some(::std::vec::Vec::new());
                }
                self.commitment.as_mut().unwrap()
            }

            // Take field
            pub fn take_commitment(&mut self) -> ::std::vec::Vec<u8> {
                self.commitment.take().unwrap_or_else(|| ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "dest",
                    |m: &MoneroRctKeyPublic| { &m.dest },
                    |m: &mut MoneroRctKeyPublic| { &mut m.dest },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "commitment",
                    |m: &MoneroRctKeyPublic| { &m.commitment },
                    |m: &mut MoneroRctKeyPublic| { &mut m.commitment },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroRctKeyPublic>(
                    "MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for MoneroRctKeyPublic {
            const NAME: &'static str = "MoneroRctKeyPublic";

            fn is_initialized(&self) -> bool {
                if self.dest.is_none() {
                    return false;
                }
                if self.commitment.is_none() {
                    return false;
                }
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.dest = ::std::option::Option::Some(is.read_bytes()?);
                        },
                        18 => {
                            self.commitment = ::std::option::Option::Some(is.read_bytes()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.dest.as_ref() {
                    my_size += ::protobuf::rt::bytes_size(1, &v);
                }
                if let Some(v) = self.commitment.as_ref() {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.dest.as_ref() {
                    os.write_bytes(1, v)?;
                }
                if let Some(v) = self.commitment.as_ref() {
                    os.write_bytes(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> MoneroRctKeyPublic {
                MoneroRctKeyPublic::new()
            }

            fn clear(&mut self) {
                self.dest = ::std::option::Option::None;
                self.commitment = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static MoneroRctKeyPublic {
                static instance: MoneroRctKeyPublic = MoneroRctKeyPublic {
                    dest: ::std::option::Option::None,
                    commitment: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for MoneroRctKeyPublic {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for MoneroRctKeyPublic {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for MoneroRctKeyPublic {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki)
    pub struct MoneroMultisigKLRki {
        // message fields
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.K)
        pub K: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.L)
        pub L: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.R)
        pub R: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.ki)
        pub ki: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MoneroMultisigKLRki {
        fn default() -> &'a MoneroMultisigKLRki {
            <MoneroMultisigKLRki as ::protobuf::Message>::default_instance()
        }
    }

    impl MoneroMultisigKLRki {
        pub fn new() -> MoneroMultisigKLRki {
            ::std::default::Default::default()
        }

        // optional bytes K = 1;

        pub fn K(&self) -> &[u8] {
            match self.K.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_K(&mut self) {
            self.K = ::std::option::Option::None;
        }

        pub fn has_K(&self) -> bool {
            self.K.is_some()
        }

        // Param is passed by value, moved
        pub fn set_K(&mut self, v: ::std::vec::Vec<u8>) {
            self.K = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_K(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.K.is_none() {
                self.K = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.K.as_mut().unwrap()
        }

        // Take field
        pub fn take_K(&mut self) -> ::std::vec::Vec<u8> {
            self.K.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes L = 2;

        pub fn L(&self) -> &[u8] {
            match self.L.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_L(&mut self) {
            self.L = ::std::option::Option::None;
        }

        pub fn has_L(&self) -> bool {
            self.L.is_some()
        }

        // Param is passed by value, moved
        pub fn set_L(&mut self, v: ::std::vec::Vec<u8>) {
            self.L = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_L(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.L.is_none() {
                self.L = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.L.as_mut().unwrap()
        }

        // Take field
        pub fn take_L(&mut self) -> ::std::vec::Vec<u8> {
            self.L.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes R = 3;

        pub fn R(&self) -> &[u8] {
            match self.R.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_R(&mut self) {
            self.R = ::std::option::Option::None;
        }

        pub fn has_R(&self) -> bool {
            self.R.is_some()
        }

        // Param is passed by value, moved
        pub fn set_R(&mut self, v: ::std::vec::Vec<u8>) {
            self.R = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_R(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.R.is_none() {
                self.R = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.R.as_mut().unwrap()
        }

        // Take field
        pub fn take_R(&mut self) -> ::std::vec::Vec<u8> {
            self.R.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes ki = 4;

        pub fn ki(&self) -> &[u8] {
            match self.ki.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_ki(&mut self) {
            self.ki = ::std::option::Option::None;
        }

        pub fn has_ki(&self) -> bool {
            self.ki.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ki(&mut self, v: ::std::vec::Vec<u8>) {
            self.ki = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_ki(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.ki.is_none() {
                self.ki = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.ki.as_mut().unwrap()
        }

        // Take field
        pub fn take_ki(&mut self) -> ::std::vec::Vec<u8> {
            self.ki.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "K",
                |m: &MoneroMultisigKLRki| { &m.K },
                |m: &mut MoneroMultisigKLRki| { &mut m.K },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "L",
                |m: &MoneroMultisigKLRki| { &m.L },
                |m: &mut MoneroMultisigKLRki| { &mut m.L },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "R",
                |m: &MoneroMultisigKLRki| { &m.R },
                |m: &mut MoneroMultisigKLRki| { &mut m.R },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ki",
                |m: &MoneroMultisigKLRki| { &m.ki },
                |m: &mut MoneroMultisigKLRki| { &mut m.ki },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroMultisigKLRki>(
                "MoneroTransactionSourceEntry.MoneroMultisigKLRki",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MoneroMultisigKLRki {
        const NAME: &'static str = "MoneroMultisigKLRki";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.K = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    18 => {
                        self.L = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    26 => {
                        self.R = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    34 => {
                        self.ki = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.K.as_ref() {
                my_size += ::protobuf::rt::bytes_size(1, &v);
            }
            if let Some(v) = self.L.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            if let Some(v) = self.R.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            if let Some(v) = self.ki.as_ref() {
                my_size += ::protobuf::rt::bytes_size(4, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.K.as_ref() {
                os.write_bytes(1, v)?;
            }
            if let Some(v) = self.L.as_ref() {
                os.write_bytes(2, v)?;
            }
            if let Some(v) = self.R.as_ref() {
                os.write_bytes(3, v)?;
            }
            if let Some(v) = self.ki.as_ref() {
                os.write_bytes(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MoneroMultisigKLRki {
            MoneroMultisigKLRki::new()
        }

        fn clear(&mut self) {
            self.K = ::std::option::Option::None;
            self.L = ::std::option::Option::None;
            self.R = ::std::option::Option::None;
            self.ki = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MoneroMultisigKLRki {
            static instance: MoneroMultisigKLRki = MoneroMultisigKLRki {
                K: ::std::option::Option::None,
                L: ::std::option::Option::None,
                R: ::std::option::Option::None,
                ki: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MoneroMultisigKLRki {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MoneroTransactionSourceEntry.MoneroMultisigKLRki").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MoneroMultisigKLRki {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MoneroMultisigKLRki {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionDestinationEntry)
pub struct MoneroTransactionDestinationEntry {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.amount)
    pub amount: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.addr)
    pub addr: ::protobuf::MessageField<monero_transaction_destination_entry::MoneroAccountPublicAddress>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.is_subaddress)
    pub is_subaddress: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.original)
    pub original: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.is_integrated)
    pub is_integrated: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionDestinationEntry {
    fn default() -> &'a MoneroTransactionDestinationEntry {
        <MoneroTransactionDestinationEntry as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionDestinationEntry {
    pub fn new() -> MoneroTransactionDestinationEntry {
        ::std::default::Default::default()
    }

    // optional uint64 amount = 1;

    pub fn amount(&self) -> u64 {
        self.amount.unwrap_or(0)
    }

    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: u64) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional bool is_subaddress = 3;

    pub fn is_subaddress(&self) -> bool {
        self.is_subaddress.unwrap_or(false)
    }

    pub fn clear_is_subaddress(&mut self) {
        self.is_subaddress = ::std::option::Option::None;
    }

    pub fn has_is_subaddress(&self) -> bool {
        self.is_subaddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_subaddress(&mut self, v: bool) {
        self.is_subaddress = ::std::option::Option::Some(v);
    }

    // optional bytes original = 4;

    pub fn original(&self) -> &[u8] {
        match self.original.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_original(&mut self) {
        self.original = ::std::option::Option::None;
    }

    pub fn has_original(&self) -> bool {
        self.original.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original(&mut self, v: ::std::vec::Vec<u8>) {
        self.original = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.original.is_none() {
            self.original = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.original.as_mut().unwrap()
    }

    // Take field
    pub fn take_original(&mut self) -> ::std::vec::Vec<u8> {
        self.original.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool is_integrated = 5;

    pub fn is_integrated(&self) -> bool {
        self.is_integrated.unwrap_or(false)
    }

    pub fn clear_is_integrated(&mut self) {
        self.is_integrated = ::std::option::Option::None;
    }

    pub fn has_is_integrated(&self) -> bool {
        self.is_integrated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_integrated(&mut self, v: bool) {
        self.is_integrated = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "amount",
            |m: &MoneroTransactionDestinationEntry| { &m.amount },
            |m: &mut MoneroTransactionDestinationEntry| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, monero_transaction_destination_entry::MoneroAccountPublicAddress>(
            "addr",
            |m: &MoneroTransactionDestinationEntry| { &m.addr },
            |m: &mut MoneroTransactionDestinationEntry| { &mut m.addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_subaddress",
            |m: &MoneroTransactionDestinationEntry| { &m.is_subaddress },
            |m: &mut MoneroTransactionDestinationEntry| { &mut m.is_subaddress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "original",
            |m: &MoneroTransactionDestinationEntry| { &m.original },
            |m: &mut MoneroTransactionDestinationEntry| { &mut m.original },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_integrated",
            |m: &MoneroTransactionDestinationEntry| { &m.is_integrated },
            |m: &mut MoneroTransactionDestinationEntry| { &mut m.is_integrated },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionDestinationEntry>(
            "MoneroTransactionDestinationEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionDestinationEntry {
    const NAME: &'static str = "MoneroTransactionDestinationEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.amount = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.addr)?;
                },
                24 => {
                    self.is_subaddress = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.original = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.is_integrated = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.addr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.is_subaddress {
            my_size += 1 + 1;
        }
        if let Some(v) = self.original.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.is_integrated {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.amount {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.addr.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.is_subaddress {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.original.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.is_integrated {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionDestinationEntry {
        MoneroTransactionDestinationEntry::new()
    }

    fn clear(&mut self) {
        self.amount = ::std::option::Option::None;
        self.addr.clear();
        self.is_subaddress = ::std::option::Option::None;
        self.original = ::std::option::Option::None;
        self.is_integrated = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionDestinationEntry {
        static instance: MoneroTransactionDestinationEntry = MoneroTransactionDestinationEntry {
            amount: ::std::option::Option::None,
            addr: ::protobuf::MessageField::none(),
            is_subaddress: ::std::option::Option::None,
            original: ::std::option::Option::None,
            is_integrated: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionDestinationEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionDestinationEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionDestinationEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionDestinationEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MoneroTransactionDestinationEntry`
pub mod monero_transaction_destination_entry {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress)
    pub struct MoneroAccountPublicAddress {
        // message fields
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.spend_public_key)
        pub spend_public_key: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.view_public_key)
        pub view_public_key: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MoneroAccountPublicAddress {
        fn default() -> &'a MoneroAccountPublicAddress {
            <MoneroAccountPublicAddress as ::protobuf::Message>::default_instance()
        }
    }

    impl MoneroAccountPublicAddress {
        pub fn new() -> MoneroAccountPublicAddress {
            ::std::default::Default::default()
        }

        // optional bytes spend_public_key = 1;

        pub fn spend_public_key(&self) -> &[u8] {
            match self.spend_public_key.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_spend_public_key(&mut self) {
            self.spend_public_key = ::std::option::Option::None;
        }

        pub fn has_spend_public_key(&self) -> bool {
            self.spend_public_key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_spend_public_key(&mut self, v: ::std::vec::Vec<u8>) {
            self.spend_public_key = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_spend_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.spend_public_key.is_none() {
                self.spend_public_key = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.spend_public_key.as_mut().unwrap()
        }

        // Take field
        pub fn take_spend_public_key(&mut self) -> ::std::vec::Vec<u8> {
            self.spend_public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes view_public_key = 2;

        pub fn view_public_key(&self) -> &[u8] {
            match self.view_public_key.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_view_public_key(&mut self) {
            self.view_public_key = ::std::option::Option::None;
        }

        pub fn has_view_public_key(&self) -> bool {
            self.view_public_key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_view_public_key(&mut self, v: ::std::vec::Vec<u8>) {
            self.view_public_key = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_view_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.view_public_key.is_none() {
                self.view_public_key = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.view_public_key.as_mut().unwrap()
        }

        // Take field
        pub fn take_view_public_key(&mut self) -> ::std::vec::Vec<u8> {
            self.view_public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "spend_public_key",
                |m: &MoneroAccountPublicAddress| { &m.spend_public_key },
                |m: &mut MoneroAccountPublicAddress| { &mut m.spend_public_key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "view_public_key",
                |m: &MoneroAccountPublicAddress| { &m.view_public_key },
                |m: &mut MoneroAccountPublicAddress| { &mut m.view_public_key },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroAccountPublicAddress>(
                "MoneroTransactionDestinationEntry.MoneroAccountPublicAddress",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MoneroAccountPublicAddress {
        const NAME: &'static str = "MoneroAccountPublicAddress";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.spend_public_key = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    18 => {
                        self.view_public_key = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.spend_public_key.as_ref() {
                my_size += ::protobuf::rt::bytes_size(1, &v);
            }
            if let Some(v) = self.view_public_key.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.spend_public_key.as_ref() {
                os.write_bytes(1, v)?;
            }
            if let Some(v) = self.view_public_key.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MoneroAccountPublicAddress {
            MoneroAccountPublicAddress::new()
        }

        fn clear(&mut self) {
            self.spend_public_key = ::std::option::Option::None;
            self.view_public_key = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MoneroAccountPublicAddress {
            static instance: MoneroAccountPublicAddress = MoneroAccountPublicAddress {
                spend_public_key: ::std::option::Option::None,
                view_public_key: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MoneroAccountPublicAddress {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MoneroTransactionDestinationEntry.MoneroAccountPublicAddress").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MoneroAccountPublicAddress {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MoneroAccountPublicAddress {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionRsigData)
pub struct MoneroTransactionRsigData {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_type)
    pub rsig_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionRsigData.offload_type)
    pub offload_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionRsigData.grouping)
    pub grouping: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionRsigData.mask)
    pub mask: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig)
    pub rsig: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
    pub rsig_parts: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionRsigData.bp_version)
    pub bp_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionRsigData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionRsigData {
    fn default() -> &'a MoneroTransactionRsigData {
        <MoneroTransactionRsigData as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionRsigData {
    pub fn new() -> MoneroTransactionRsigData {
        ::std::default::Default::default()
    }

    // optional uint32 rsig_type = 1;

    pub fn rsig_type(&self) -> u32 {
        self.rsig_type.unwrap_or(0)
    }

    pub fn clear_rsig_type(&mut self) {
        self.rsig_type = ::std::option::Option::None;
    }

    pub fn has_rsig_type(&self) -> bool {
        self.rsig_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rsig_type(&mut self, v: u32) {
        self.rsig_type = ::std::option::Option::Some(v);
    }

    // optional uint32 offload_type = 2;

    pub fn offload_type(&self) -> u32 {
        self.offload_type.unwrap_or(0)
    }

    pub fn clear_offload_type(&mut self) {
        self.offload_type = ::std::option::Option::None;
    }

    pub fn has_offload_type(&self) -> bool {
        self.offload_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offload_type(&mut self, v: u32) {
        self.offload_type = ::std::option::Option::Some(v);
    }

    // optional bytes mask = 4;

    pub fn mask(&self) -> &[u8] {
        match self.mask.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mask(&mut self) {
        self.mask = ::std::option::Option::None;
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: ::std::vec::Vec<u8>) {
        self.mask = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mask(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mask.is_none() {
            self.mask = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_mask(&mut self) -> ::std::vec::Vec<u8> {
        self.mask.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes rsig = 5;

    pub fn rsig(&self) -> &[u8] {
        match self.rsig.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_rsig(&mut self) {
        self.rsig = ::std::option::Option::None;
    }

    pub fn has_rsig(&self) -> bool {
        self.rsig.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rsig(&mut self, v: ::std::vec::Vec<u8>) {
        self.rsig = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rsig(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.rsig.is_none() {
            self.rsig = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.rsig.as_mut().unwrap()
    }

    // Take field
    pub fn take_rsig(&mut self) -> ::std::vec::Vec<u8> {
        self.rsig.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 bp_version = 7;

    pub fn bp_version(&self) -> u32 {
        self.bp_version.unwrap_or(0)
    }

    pub fn clear_bp_version(&mut self) {
        self.bp_version = ::std::option::Option::None;
    }

    pub fn has_bp_version(&self) -> bool {
        self.bp_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bp_version(&mut self, v: u32) {
        self.bp_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rsig_type",
            |m: &MoneroTransactionRsigData| { &m.rsig_type },
            |m: &mut MoneroTransactionRsigData| { &mut m.rsig_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offload_type",
            |m: &MoneroTransactionRsigData| { &m.offload_type },
            |m: &mut MoneroTransactionRsigData| { &mut m.offload_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "grouping",
            |m: &MoneroTransactionRsigData| { &m.grouping },
            |m: &mut MoneroTransactionRsigData| { &mut m.grouping },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mask",
            |m: &MoneroTransactionRsigData| { &m.mask },
            |m: &mut MoneroTransactionRsigData| { &mut m.mask },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rsig",
            |m: &MoneroTransactionRsigData| { &m.rsig },
            |m: &mut MoneroTransactionRsigData| { &mut m.rsig },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rsig_parts",
            |m: &MoneroTransactionRsigData| { &m.rsig_parts },
            |m: &mut MoneroTransactionRsigData| { &mut m.rsig_parts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bp_version",
            |m: &MoneroTransactionRsigData| { &m.bp_version },
            |m: &mut MoneroTransactionRsigData| { &mut m.bp_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionRsigData>(
            "MoneroTransactionRsigData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionRsigData {
    const NAME: &'static str = "MoneroTransactionRsigData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rsig_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.offload_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint64_into(&mut self.grouping)?;
                },
                24 => {
                    self.grouping.push(is.read_uint64()?);
                },
                34 => {
                    self.mask = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.rsig = ::std::option::Option::Some(is.read_bytes()?);
                },
                50 => {
                    self.rsig_parts.push(is.read_bytes()?);
                },
                56 => {
                    self.bp_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rsig_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.offload_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.grouping {
            my_size += ::protobuf::rt::uint64_size(3, *value);
        };
        if let Some(v) = self.mask.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.rsig.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        for value in &self.rsig_parts {
            my_size += ::protobuf::rt::bytes_size(6, &value);
        };
        if let Some(v) = self.bp_version {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rsig_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.offload_type {
            os.write_uint32(2, v)?;
        }
        for v in &self.grouping {
            os.write_uint64(3, *v)?;
        };
        if let Some(v) = self.mask.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.rsig.as_ref() {
            os.write_bytes(5, v)?;
        }
        for v in &self.rsig_parts {
            os.write_bytes(6, &v)?;
        };
        if let Some(v) = self.bp_version {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionRsigData {
        MoneroTransactionRsigData::new()
    }

    fn clear(&mut self) {
        self.rsig_type = ::std::option::Option::None;
        self.offload_type = ::std::option::Option::None;
        self.grouping.clear();
        self.mask = ::std::option::Option::None;
        self.rsig = ::std::option::Option::None;
        self.rsig_parts.clear();
        self.bp_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionRsigData {
        static instance: MoneroTransactionRsigData = MoneroTransactionRsigData {
            rsig_type: ::std::option::Option::None,
            offload_type: ::std::option::Option::None,
            grouping: ::std::vec::Vec::new(),
            mask: ::std::option::Option::None,
            rsig: ::std::option::Option::None,
            rsig_parts: ::std::vec::Vec::new(),
            bp_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionRsigData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionRsigData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionRsigData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionRsigData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroGetAddress)
pub struct MoneroGetAddress {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetAddress.address_n)
    pub address_n: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetAddress.show_display)
    pub show_display: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetAddress.network_type)
    pub network_type: ::std::option::Option<::protobuf::EnumOrUnknown<MoneroNetworkType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetAddress.account)
    pub account: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetAddress.minor)
    pub minor: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetAddress.payment_id)
    pub payment_id: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetAddress.chunkify)
    pub chunkify: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroGetAddress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroGetAddress {
    fn default() -> &'a MoneroGetAddress {
        <MoneroGetAddress as ::protobuf::Message>::default_instance()
    }
}

impl MoneroGetAddress {
    pub fn new() -> MoneroGetAddress {
        ::std::default::Default::default()
    }

    // optional bool show_display = 2;

    pub fn show_display(&self) -> bool {
        self.show_display.unwrap_or(false)
    }

    pub fn clear_show_display(&mut self) {
        self.show_display = ::std::option::Option::None;
    }

    pub fn has_show_display(&self) -> bool {
        self.show_display.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_display(&mut self, v: bool) {
        self.show_display = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 3;

    pub fn network_type(&self) -> MoneroNetworkType {
        match self.network_type {
            Some(e) => e.enum_value_or(MoneroNetworkType::MAINNET),
            None => MoneroNetworkType::MAINNET,
        }
    }

    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: MoneroNetworkType) {
        self.network_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 account = 4;

    pub fn account(&self) -> u32 {
        self.account.unwrap_or(0)
    }

    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u32) {
        self.account = ::std::option::Option::Some(v);
    }

    // optional uint32 minor = 5;

    pub fn minor(&self) -> u32 {
        self.minor.unwrap_or(0)
    }

    pub fn clear_minor(&mut self) {
        self.minor = ::std::option::Option::None;
    }

    pub fn has_minor(&self) -> bool {
        self.minor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minor(&mut self, v: u32) {
        self.minor = ::std::option::Option::Some(v);
    }

    // optional bytes payment_id = 6;

    pub fn payment_id(&self) -> &[u8] {
        match self.payment_id.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payment_id(&mut self) {
        self.payment_id = ::std::option::Option::None;
    }

    pub fn has_payment_id(&self) -> bool {
        self.payment_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payment_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payment_id.is_none() {
            self.payment_id = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.payment_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_payment_id(&mut self) -> ::std::vec::Vec<u8> {
        self.payment_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool chunkify = 7;

    pub fn chunkify(&self) -> bool {
        self.chunkify.unwrap_or(false)
    }

    pub fn clear_chunkify(&mut self) {
        self.chunkify = ::std::option::Option::None;
    }

    pub fn has_chunkify(&self) -> bool {
        self.chunkify.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chunkify(&mut self, v: bool) {
        self.chunkify = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "address_n",
            |m: &MoneroGetAddress| { &m.address_n },
            |m: &mut MoneroGetAddress| { &mut m.address_n },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_display",
            |m: &MoneroGetAddress| { &m.show_display },
            |m: &mut MoneroGetAddress| { &mut m.show_display },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_type",
            |m: &MoneroGetAddress| { &m.network_type },
            |m: &mut MoneroGetAddress| { &mut m.network_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account",
            |m: &MoneroGetAddress| { &m.account },
            |m: &mut MoneroGetAddress| { &mut m.account },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minor",
            |m: &MoneroGetAddress| { &m.minor },
            |m: &mut MoneroGetAddress| { &mut m.minor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payment_id",
            |m: &MoneroGetAddress| { &m.payment_id },
            |m: &mut MoneroGetAddress| { &mut m.payment_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chunkify",
            |m: &MoneroGetAddress| { &m.chunkify },
            |m: &mut MoneroGetAddress| { &mut m.chunkify },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroGetAddress>(
            "MoneroGetAddress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroGetAddress {
    const NAME: &'static str = "MoneroGetAddress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.address_n)?;
                },
                8 => {
                    self.address_n.push(is.read_uint32()?);
                },
                16 => {
                    self.show_display = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.network_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.account = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.minor = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.payment_id = ::std::option::Option::Some(is.read_bytes()?);
                },
                56 => {
                    self.chunkify = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        if let Some(v) = self.show_display {
            my_size += 1 + 1;
        }
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.minor {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.payment_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.chunkify {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.show_display {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.network_type {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.account {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.minor {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.payment_id.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.chunkify {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroGetAddress {
        MoneroGetAddress::new()
    }

    fn clear(&mut self) {
        self.address_n.clear();
        self.show_display = ::std::option::Option::None;
        self.network_type = ::std::option::Option::None;
        self.account = ::std::option::Option::None;
        self.minor = ::std::option::Option::None;
        self.payment_id = ::std::option::Option::None;
        self.chunkify = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroGetAddress {
        static instance: MoneroGetAddress = MoneroGetAddress {
            address_n: ::std::vec::Vec::new(),
            show_display: ::std::option::Option::None,
            network_type: ::std::option::Option::None,
            account: ::std::option::Option::None,
            minor: ::std::option::Option::None,
            payment_id: ::std::option::Option::None,
            chunkify: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroGetAddress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroGetAddress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroGetAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroGetAddress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroAddress)
pub struct MoneroAddress {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroAddress.address)
    pub address: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroAddress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroAddress {
    fn default() -> &'a MoneroAddress {
        <MoneroAddress as ::protobuf::Message>::default_instance()
    }
}

impl MoneroAddress {
    pub fn new() -> MoneroAddress {
        ::std::default::Default::default()
    }

    // optional bytes address = 1;

    pub fn address(&self) -> &[u8] {
        match self.address.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_address(&mut self) {
        self.address = ::std::option::Option::None;
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.address.is_none() {
            self.address = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        self.address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "address",
            |m: &MoneroAddress| { &m.address },
            |m: &mut MoneroAddress| { &mut m.address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroAddress>(
            "MoneroAddress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroAddress {
    const NAME: &'static str = "MoneroAddress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.address.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroAddress {
        MoneroAddress::new()
    }

    fn clear(&mut self) {
        self.address = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroAddress {
        static instance: MoneroAddress = MoneroAddress {
            address: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroAddress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroAddress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroAddress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroGetWatchKey)
pub struct MoneroGetWatchKey {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetWatchKey.address_n)
    pub address_n: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetWatchKey.network_type)
    pub network_type: ::std::option::Option<::protobuf::EnumOrUnknown<MoneroNetworkType>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroGetWatchKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroGetWatchKey {
    fn default() -> &'a MoneroGetWatchKey {
        <MoneroGetWatchKey as ::protobuf::Message>::default_instance()
    }
}

impl MoneroGetWatchKey {
    pub fn new() -> MoneroGetWatchKey {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 2;

    pub fn network_type(&self) -> MoneroNetworkType {
        match self.network_type {
            Some(e) => e.enum_value_or(MoneroNetworkType::MAINNET),
            None => MoneroNetworkType::MAINNET,
        }
    }

    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: MoneroNetworkType) {
        self.network_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "address_n",
            |m: &MoneroGetWatchKey| { &m.address_n },
            |m: &mut MoneroGetWatchKey| { &mut m.address_n },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_type",
            |m: &MoneroGetWatchKey| { &m.network_type },
            |m: &mut MoneroGetWatchKey| { &mut m.network_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroGetWatchKey>(
            "MoneroGetWatchKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroGetWatchKey {
    const NAME: &'static str = "MoneroGetWatchKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.address_n)?;
                },
                8 => {
                    self.address_n.push(is.read_uint32()?);
                },
                16 => {
                    self.network_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.network_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroGetWatchKey {
        MoneroGetWatchKey::new()
    }

    fn clear(&mut self) {
        self.address_n.clear();
        self.network_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroGetWatchKey {
        static instance: MoneroGetWatchKey = MoneroGetWatchKey {
            address_n: ::std::vec::Vec::new(),
            network_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroGetWatchKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroGetWatchKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroGetWatchKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroGetWatchKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroWatchKey)
pub struct MoneroWatchKey {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroWatchKey.watch_key)
    pub watch_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroWatchKey.address)
    pub address: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroWatchKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroWatchKey {
    fn default() -> &'a MoneroWatchKey {
        <MoneroWatchKey as ::protobuf::Message>::default_instance()
    }
}

impl MoneroWatchKey {
    pub fn new() -> MoneroWatchKey {
        ::std::default::Default::default()
    }

    // optional bytes watch_key = 1;

    pub fn watch_key(&self) -> &[u8] {
        match self.watch_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_watch_key(&mut self) {
        self.watch_key = ::std::option::Option::None;
    }

    pub fn has_watch_key(&self) -> bool {
        self.watch_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watch_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.watch_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_watch_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.watch_key.is_none() {
            self.watch_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.watch_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_watch_key(&mut self) -> ::std::vec::Vec<u8> {
        self.watch_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes address = 2;

    pub fn address(&self) -> &[u8] {
        match self.address.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_address(&mut self) {
        self.address = ::std::option::Option::None;
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.address.is_none() {
            self.address = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        self.address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "watch_key",
            |m: &MoneroWatchKey| { &m.watch_key },
            |m: &mut MoneroWatchKey| { &mut m.watch_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "address",
            |m: &MoneroWatchKey| { &m.address },
            |m: &mut MoneroWatchKey| { &mut m.address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroWatchKey>(
            "MoneroWatchKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroWatchKey {
    const NAME: &'static str = "MoneroWatchKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.watch_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.address = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.watch_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.watch_key.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.address.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroWatchKey {
        MoneroWatchKey::new()
    }

    fn clear(&mut self) {
        self.watch_key = ::std::option::Option::None;
        self.address = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroWatchKey {
        static instance: MoneroWatchKey = MoneroWatchKey {
            watch_key: ::std::option::Option::None,
            address: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroWatchKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroWatchKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroWatchKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroWatchKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionInitRequest)
pub struct MoneroTransactionInitRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.address_n)
    pub address_n: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.network_type)
    pub network_type: ::std::option::Option<::protobuf::EnumOrUnknown<MoneroNetworkType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.tsx_data)
    pub tsx_data: ::protobuf::MessageField<monero_transaction_init_request::MoneroTransactionData>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionInitRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionInitRequest {
    fn default() -> &'a MoneroTransactionInitRequest {
        <MoneroTransactionInitRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionInitRequest {
    pub fn new() -> MoneroTransactionInitRequest {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 3;

    pub fn network_type(&self) -> MoneroNetworkType {
        match self.network_type {
            Some(e) => e.enum_value_or(MoneroNetworkType::MAINNET),
            None => MoneroNetworkType::MAINNET,
        }
    }

    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: MoneroNetworkType) {
        self.network_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &MoneroTransactionInitRequest| { &m.version },
            |m: &mut MoneroTransactionInitRequest| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "address_n",
            |m: &MoneroTransactionInitRequest| { &m.address_n },
            |m: &mut MoneroTransactionInitRequest| { &mut m.address_n },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_type",
            |m: &MoneroTransactionInitRequest| { &m.network_type },
            |m: &mut MoneroTransactionInitRequest| { &mut m.network_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, monero_transaction_init_request::MoneroTransactionData>(
            "tsx_data",
            |m: &MoneroTransactionInitRequest| { &m.tsx_data },
            |m: &mut MoneroTransactionInitRequest| { &mut m.tsx_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionInitRequest>(
            "MoneroTransactionInitRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionInitRequest {
    const NAME: &'static str = "MoneroTransactionInitRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.address_n)?;
                },
                16 => {
                    self.address_n.push(is.read_uint32()?);
                },
                24 => {
                    self.network_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tsx_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.address_n {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.tsx_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        for v in &self.address_n {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.network_type {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.tsx_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionInitRequest {
        MoneroTransactionInitRequest::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.address_n.clear();
        self.network_type = ::std::option::Option::None;
        self.tsx_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionInitRequest {
        static instance: MoneroTransactionInitRequest = MoneroTransactionInitRequest {
            version: ::std::option::Option::None,
            address_n: ::std::vec::Vec::new(),
            network_type: ::std::option::Option::None,
            tsx_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionInitRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionInitRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionInitRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionInitRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MoneroTransactionInitRequest`
pub mod monero_transaction_init_request {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData)
    pub struct MoneroTransactionData {
        // message fields
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.version)
        pub version: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.payment_id)
        pub payment_id: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.unlock_time)
        pub unlock_time: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.outputs)
        pub outputs: ::std::vec::Vec<super::MoneroTransactionDestinationEntry>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.change_dts)
        pub change_dts: ::protobuf::MessageField<super::MoneroTransactionDestinationEntry>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.num_inputs)
        pub num_inputs: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.mixin)
        pub mixin: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.fee)
        pub fee: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.account)
        pub account: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.minor_indices)
        pub minor_indices: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.rsig_data)
        pub rsig_data: ::protobuf::MessageField<super::MoneroTransactionRsigData>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.integrated_indices)
        pub integrated_indices: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.client_version)
        pub client_version: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.hard_fork)
        pub hard_fork: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.monero_version)
        pub monero_version: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.chunkify)
        pub chunkify: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MoneroTransactionData {
        fn default() -> &'a MoneroTransactionData {
            <MoneroTransactionData as ::protobuf::Message>::default_instance()
        }
    }

    impl MoneroTransactionData {
        pub fn new() -> MoneroTransactionData {
            ::std::default::Default::default()
        }

        // optional uint32 version = 1;

        pub fn version(&self) -> u32 {
            self.version.unwrap_or(0)
        }

        pub fn clear_version(&mut self) {
            self.version = ::std::option::Option::None;
        }

        pub fn has_version(&self) -> bool {
            self.version.is_some()
        }

        // Param is passed by value, moved
        pub fn set_version(&mut self, v: u32) {
            self.version = ::std::option::Option::Some(v);
        }

        // optional bytes payment_id = 2;

        pub fn payment_id(&self) -> &[u8] {
            match self.payment_id.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_payment_id(&mut self) {
            self.payment_id = ::std::option::Option::None;
        }

        pub fn has_payment_id(&self) -> bool {
            self.payment_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_payment_id(&mut self, v: ::std::vec::Vec<u8>) {
            self.payment_id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_payment_id(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.payment_id.is_none() {
                self.payment_id = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.payment_id.as_mut().unwrap()
        }

        // Take field
        pub fn take_payment_id(&mut self) -> ::std::vec::Vec<u8> {
            self.payment_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint64 unlock_time = 3;

        pub fn unlock_time(&self) -> u64 {
            self.unlock_time.unwrap_or(0)
        }

        pub fn clear_unlock_time(&mut self) {
            self.unlock_time = ::std::option::Option::None;
        }

        pub fn has_unlock_time(&self) -> bool {
            self.unlock_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unlock_time(&mut self, v: u64) {
            self.unlock_time = ::std::option::Option::Some(v);
        }

        // optional uint32 num_inputs = 6;

        pub fn num_inputs(&self) -> u32 {
            self.num_inputs.unwrap_or(0)
        }

        pub fn clear_num_inputs(&mut self) {
            self.num_inputs = ::std::option::Option::None;
        }

        pub fn has_num_inputs(&self) -> bool {
            self.num_inputs.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_inputs(&mut self, v: u32) {
            self.num_inputs = ::std::option::Option::Some(v);
        }

        // optional uint32 mixin = 7;

        pub fn mixin(&self) -> u32 {
            self.mixin.unwrap_or(0)
        }

        pub fn clear_mixin(&mut self) {
            self.mixin = ::std::option::Option::None;
        }

        pub fn has_mixin(&self) -> bool {
            self.mixin.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mixin(&mut self, v: u32) {
            self.mixin = ::std::option::Option::Some(v);
        }

        // optional uint64 fee = 8;

        pub fn fee(&self) -> u64 {
            self.fee.unwrap_or(0)
        }

        pub fn clear_fee(&mut self) {
            self.fee = ::std::option::Option::None;
        }

        pub fn has_fee(&self) -> bool {
            self.fee.is_some()
        }

        // Param is passed by value, moved
        pub fn set_fee(&mut self, v: u64) {
            self.fee = ::std::option::Option::Some(v);
        }

        // optional uint32 account = 9;

        pub fn account(&self) -> u32 {
            self.account.unwrap_or(0)
        }

        pub fn clear_account(&mut self) {
            self.account = ::std::option::Option::None;
        }

        pub fn has_account(&self) -> bool {
            self.account.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account(&mut self, v: u32) {
            self.account = ::std::option::Option::Some(v);
        }

        // optional uint32 client_version = 13;

        pub fn client_version(&self) -> u32 {
            self.client_version.unwrap_or(0)
        }

        pub fn clear_client_version(&mut self) {
            self.client_version = ::std::option::Option::None;
        }

        pub fn has_client_version(&self) -> bool {
            self.client_version.is_some()
        }

        // Param is passed by value, moved
        pub fn set_client_version(&mut self, v: u32) {
            self.client_version = ::std::option::Option::Some(v);
        }

        // optional uint32 hard_fork = 14;

        pub fn hard_fork(&self) -> u32 {
            self.hard_fork.unwrap_or(0)
        }

        pub fn clear_hard_fork(&mut self) {
            self.hard_fork = ::std::option::Option::None;
        }

        pub fn has_hard_fork(&self) -> bool {
            self.hard_fork.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hard_fork(&mut self, v: u32) {
            self.hard_fork = ::std::option::Option::Some(v);
        }

        // optional bytes monero_version = 15;

        pub fn monero_version(&self) -> &[u8] {
            match self.monero_version.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_monero_version(&mut self) {
            self.monero_version = ::std::option::Option::None;
        }

        pub fn has_monero_version(&self) -> bool {
            self.monero_version.is_some()
        }

        // Param is passed by value, moved
        pub fn set_monero_version(&mut self, v: ::std::vec::Vec<u8>) {
            self.monero_version = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_monero_version(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.monero_version.is_none() {
                self.monero_version = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.monero_version.as_mut().unwrap()
        }

        // Take field
        pub fn take_monero_version(&mut self) -> ::std::vec::Vec<u8> {
            self.monero_version.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bool chunkify = 16;

        pub fn chunkify(&self) -> bool {
            self.chunkify.unwrap_or(false)
        }

        pub fn clear_chunkify(&mut self) {
            self.chunkify = ::std::option::Option::None;
        }

        pub fn has_chunkify(&self) -> bool {
            self.chunkify.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chunkify(&mut self, v: bool) {
            self.chunkify = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(16);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "version",
                |m: &MoneroTransactionData| { &m.version },
                |m: &mut MoneroTransactionData| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "payment_id",
                |m: &MoneroTransactionData| { &m.payment_id },
                |m: &mut MoneroTransactionData| { &mut m.payment_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "unlock_time",
                |m: &MoneroTransactionData| { &m.unlock_time },
                |m: &mut MoneroTransactionData| { &mut m.unlock_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "outputs",
                |m: &MoneroTransactionData| { &m.outputs },
                |m: &mut MoneroTransactionData| { &mut m.outputs },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::MoneroTransactionDestinationEntry>(
                "change_dts",
                |m: &MoneroTransactionData| { &m.change_dts },
                |m: &mut MoneroTransactionData| { &mut m.change_dts },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "num_inputs",
                |m: &MoneroTransactionData| { &m.num_inputs },
                |m: &mut MoneroTransactionData| { &mut m.num_inputs },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "mixin",
                |m: &MoneroTransactionData| { &m.mixin },
                |m: &mut MoneroTransactionData| { &mut m.mixin },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "fee",
                |m: &MoneroTransactionData| { &m.fee },
                |m: &mut MoneroTransactionData| { &mut m.fee },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account",
                |m: &MoneroTransactionData| { &m.account },
                |m: &mut MoneroTransactionData| { &mut m.account },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "minor_indices",
                |m: &MoneroTransactionData| { &m.minor_indices },
                |m: &mut MoneroTransactionData| { &mut m.minor_indices },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::MoneroTransactionRsigData>(
                "rsig_data",
                |m: &MoneroTransactionData| { &m.rsig_data },
                |m: &mut MoneroTransactionData| { &mut m.rsig_data },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "integrated_indices",
                |m: &MoneroTransactionData| { &m.integrated_indices },
                |m: &mut MoneroTransactionData| { &mut m.integrated_indices },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "client_version",
                |m: &MoneroTransactionData| { &m.client_version },
                |m: &mut MoneroTransactionData| { &mut m.client_version },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hard_fork",
                |m: &MoneroTransactionData| { &m.hard_fork },
                |m: &mut MoneroTransactionData| { &mut m.hard_fork },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "monero_version",
                |m: &MoneroTransactionData| { &m.monero_version },
                |m: &mut MoneroTransactionData| { &mut m.monero_version },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "chunkify",
                |m: &MoneroTransactionData| { &m.chunkify },
                |m: &mut MoneroTransactionData| { &mut m.chunkify },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionData>(
                "MoneroTransactionInitRequest.MoneroTransactionData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MoneroTransactionData {
        const NAME: &'static str = "MoneroTransactionData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.version = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.payment_id = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    24 => {
                        self.unlock_time = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    34 => {
                        self.outputs.push(is.read_message()?);
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.change_dts)?;
                    },
                    48 => {
                        self.num_inputs = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.mixin = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.fee = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    72 => {
                        self.account = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    82 => {
                        is.read_repeated_packed_uint32_into(&mut self.minor_indices)?;
                    },
                    80 => {
                        self.minor_indices.push(is.read_uint32()?);
                    },
                    90 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.rsig_data)?;
                    },
                    98 => {
                        is.read_repeated_packed_uint32_into(&mut self.integrated_indices)?;
                    },
                    96 => {
                        self.integrated_indices.push(is.read_uint32()?);
                    },
                    104 => {
                        self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.hard_fork = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    122 => {
                        self.monero_version = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    128 => {
                        self.chunkify = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.version {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.payment_id.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            if let Some(v) = self.unlock_time {
                my_size += ::protobuf::rt::uint64_size(3, v);
            }
            for value in &self.outputs {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.change_dts.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.num_inputs {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.mixin {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.fee {
                my_size += ::protobuf::rt::uint64_size(8, v);
            }
            if let Some(v) = self.account {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            for value in &self.minor_indices {
                my_size += ::protobuf::rt::uint32_size(10, *value);
            };
            if let Some(v) = self.rsig_data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.integrated_indices {
                my_size += ::protobuf::rt::uint32_size(12, *value);
            };
            if let Some(v) = self.client_version {
                my_size += ::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.hard_fork {
                my_size += ::protobuf::rt::uint32_size(14, v);
            }
            if let Some(v) = self.monero_version.as_ref() {
                my_size += ::protobuf::rt::bytes_size(15, &v);
            }
            if let Some(v) = self.chunkify {
                my_size += 2 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.version {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.payment_id.as_ref() {
                os.write_bytes(2, v)?;
            }
            if let Some(v) = self.unlock_time {
                os.write_uint64(3, v)?;
            }
            for v in &self.outputs {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            if let Some(v) = self.change_dts.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if let Some(v) = self.num_inputs {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.mixin {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.fee {
                os.write_uint64(8, v)?;
            }
            if let Some(v) = self.account {
                os.write_uint32(9, v)?;
            }
            for v in &self.minor_indices {
                os.write_uint32(10, *v)?;
            };
            if let Some(v) = self.rsig_data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
            }
            for v in &self.integrated_indices {
                os.write_uint32(12, *v)?;
            };
            if let Some(v) = self.client_version {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.hard_fork {
                os.write_uint32(14, v)?;
            }
            if let Some(v) = self.monero_version.as_ref() {
                os.write_bytes(15, v)?;
            }
            if let Some(v) = self.chunkify {
                os.write_bool(16, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MoneroTransactionData {
            MoneroTransactionData::new()
        }

        fn clear(&mut self) {
            self.version = ::std::option::Option::None;
            self.payment_id = ::std::option::Option::None;
            self.unlock_time = ::std::option::Option::None;
            self.outputs.clear();
            self.change_dts.clear();
            self.num_inputs = ::std::option::Option::None;
            self.mixin = ::std::option::Option::None;
            self.fee = ::std::option::Option::None;
            self.account = ::std::option::Option::None;
            self.minor_indices.clear();
            self.rsig_data.clear();
            self.integrated_indices.clear();
            self.client_version = ::std::option::Option::None;
            self.hard_fork = ::std::option::Option::None;
            self.monero_version = ::std::option::Option::None;
            self.chunkify = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MoneroTransactionData {
            static instance: MoneroTransactionData = MoneroTransactionData {
                version: ::std::option::Option::None,
                payment_id: ::std::option::Option::None,
                unlock_time: ::std::option::Option::None,
                outputs: ::std::vec::Vec::new(),
                change_dts: ::protobuf::MessageField::none(),
                num_inputs: ::std::option::Option::None,
                mixin: ::std::option::Option::None,
                fee: ::std::option::Option::None,
                account: ::std::option::Option::None,
                minor_indices: ::std::vec::Vec::new(),
                rsig_data: ::protobuf::MessageField::none(),
                integrated_indices: ::std::vec::Vec::new(),
                client_version: ::std::option::Option::None,
                hard_fork: ::std::option::Option::None,
                monero_version: ::std::option::Option::None,
                chunkify: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MoneroTransactionData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MoneroTransactionInitRequest.MoneroTransactionData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MoneroTransactionData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MoneroTransactionData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionInitAck)
pub struct MoneroTransactionInitAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
    pub hmacs: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInitAck.rsig_data)
    pub rsig_data: ::protobuf::MessageField<MoneroTransactionRsigData>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionInitAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionInitAck {
    fn default() -> &'a MoneroTransactionInitAck {
        <MoneroTransactionInitAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionInitAck {
    pub fn new() -> MoneroTransactionInitAck {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hmacs",
            |m: &MoneroTransactionInitAck| { &m.hmacs },
            |m: &mut MoneroTransactionInitAck| { &mut m.hmacs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoneroTransactionRsigData>(
            "rsig_data",
            |m: &MoneroTransactionInitAck| { &m.rsig_data },
            |m: &mut MoneroTransactionInitAck| { &mut m.rsig_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionInitAck>(
            "MoneroTransactionInitAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionInitAck {
    const NAME: &'static str = "MoneroTransactionInitAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hmacs.push(is.read_bytes()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rsig_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.hmacs {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        if let Some(v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.hmacs {
            os.write_bytes(1, &v)?;
        };
        if let Some(v) = self.rsig_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionInitAck {
        MoneroTransactionInitAck::new()
    }

    fn clear(&mut self) {
        self.hmacs.clear();
        self.rsig_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionInitAck {
        static instance: MoneroTransactionInitAck = MoneroTransactionInitAck {
            hmacs: ::std::vec::Vec::new(),
            rsig_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionInitAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionInitAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionInitAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionInitAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionSetInputRequest)
pub struct MoneroTransactionSetInputRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetInputRequest.src_entr)
    pub src_entr: ::protobuf::MessageField<MoneroTransactionSourceEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionSetInputRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSetInputRequest {
    fn default() -> &'a MoneroTransactionSetInputRequest {
        <MoneroTransactionSetInputRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSetInputRequest {
    pub fn new() -> MoneroTransactionSetInputRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoneroTransactionSourceEntry>(
            "src_entr",
            |m: &MoneroTransactionSetInputRequest| { &m.src_entr },
            |m: &mut MoneroTransactionSetInputRequest| { &mut m.src_entr },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionSetInputRequest>(
            "MoneroTransactionSetInputRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionSetInputRequest {
    const NAME: &'static str = "MoneroTransactionSetInputRequest";

    fn is_initialized(&self) -> bool {
        for v in &self.src_entr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.src_entr)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.src_entr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.src_entr.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionSetInputRequest {
        MoneroTransactionSetInputRequest::new()
    }

    fn clear(&mut self) {
        self.src_entr.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionSetInputRequest {
        static instance: MoneroTransactionSetInputRequest = MoneroTransactionSetInputRequest {
            src_entr: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionSetInputRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionSetInputRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionSetInputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSetInputRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionSetInputAck)
pub struct MoneroTransactionSetInputAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini)
    pub vini: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini_hmac)
    pub vini_hmac: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out)
    pub pseudo_out: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_hmac)
    pub pseudo_out_hmac: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_alpha)
    pub pseudo_out_alpha: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetInputAck.spend_key)
    pub spend_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionSetInputAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSetInputAck {
    fn default() -> &'a MoneroTransactionSetInputAck {
        <MoneroTransactionSetInputAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSetInputAck {
    pub fn new() -> MoneroTransactionSetInputAck {
        ::std::default::Default::default()
    }

    // optional bytes vini = 1;

    pub fn vini(&self) -> &[u8] {
        match self.vini.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_vini(&mut self) {
        self.vini = ::std::option::Option::None;
    }

    pub fn has_vini(&self) -> bool {
        self.vini.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vini(&mut self, v: ::std::vec::Vec<u8>) {
        self.vini = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vini(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vini.is_none() {
            self.vini = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.vini.as_mut().unwrap()
    }

    // Take field
    pub fn take_vini(&mut self) -> ::std::vec::Vec<u8> {
        self.vini.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes vini_hmac = 2;

    pub fn vini_hmac(&self) -> &[u8] {
        match self.vini_hmac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_vini_hmac(&mut self) {
        self.vini_hmac = ::std::option::Option::None;
    }

    pub fn has_vini_hmac(&self) -> bool {
        self.vini_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vini_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.vini_hmac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vini_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vini_hmac.is_none() {
            self.vini_hmac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.vini_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_vini_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.vini_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out = 3;

    pub fn pseudo_out(&self) -> &[u8] {
        match self.pseudo_out.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pseudo_out(&mut self) {
        self.pseudo_out = ::std::option::Option::None;
    }

    pub fn has_pseudo_out(&self) -> bool {
        self.pseudo_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out.is_none() {
            self.pseudo_out = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.pseudo_out.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out_hmac = 4;

    pub fn pseudo_out_hmac(&self) -> &[u8] {
        match self.pseudo_out_hmac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pseudo_out_hmac(&mut self) {
        self.pseudo_out_hmac = ::std::option::Option::None;
    }

    pub fn has_pseudo_out_hmac(&self) -> bool {
        self.pseudo_out_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out_hmac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out_hmac.is_none() {
            self.pseudo_out_hmac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.pseudo_out_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out_alpha = 5;

    pub fn pseudo_out_alpha(&self) -> &[u8] {
        match self.pseudo_out_alpha.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pseudo_out_alpha(&mut self) {
        self.pseudo_out_alpha = ::std::option::Option::None;
    }

    pub fn has_pseudo_out_alpha(&self) -> bool {
        self.pseudo_out_alpha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out_alpha(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out_alpha = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out_alpha(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out_alpha.is_none() {
            self.pseudo_out_alpha = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.pseudo_out_alpha.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out_alpha(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out_alpha.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes spend_key = 6;

    pub fn spend_key(&self) -> &[u8] {
        match self.spend_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_spend_key(&mut self) {
        self.spend_key = ::std::option::Option::None;
    }

    pub fn has_spend_key(&self) -> bool {
        self.spend_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spend_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.spend_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spend_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.spend_key.is_none() {
            self.spend_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.spend_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_spend_key(&mut self) -> ::std::vec::Vec<u8> {
        self.spend_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vini",
            |m: &MoneroTransactionSetInputAck| { &m.vini },
            |m: &mut MoneroTransactionSetInputAck| { &mut m.vini },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vini_hmac",
            |m: &MoneroTransactionSetInputAck| { &m.vini_hmac },
            |m: &mut MoneroTransactionSetInputAck| { &mut m.vini_hmac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pseudo_out",
            |m: &MoneroTransactionSetInputAck| { &m.pseudo_out },
            |m: &mut MoneroTransactionSetInputAck| { &mut m.pseudo_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pseudo_out_hmac",
            |m: &MoneroTransactionSetInputAck| { &m.pseudo_out_hmac },
            |m: &mut MoneroTransactionSetInputAck| { &mut m.pseudo_out_hmac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pseudo_out_alpha",
            |m: &MoneroTransactionSetInputAck| { &m.pseudo_out_alpha },
            |m: &mut MoneroTransactionSetInputAck| { &mut m.pseudo_out_alpha },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spend_key",
            |m: &MoneroTransactionSetInputAck| { &m.spend_key },
            |m: &mut MoneroTransactionSetInputAck| { &mut m.spend_key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionSetInputAck>(
            "MoneroTransactionSetInputAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionSetInputAck {
    const NAME: &'static str = "MoneroTransactionSetInputAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.vini = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.vini_hmac = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.pseudo_out = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.pseudo_out_hmac = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.pseudo_out_alpha = ::std::option::Option::Some(is.read_bytes()?);
                },
                50 => {
                    self.spend_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.vini.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.vini_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.pseudo_out.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.pseudo_out_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.pseudo_out_alpha.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.spend_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.vini.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.vini_hmac.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.pseudo_out.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.pseudo_out_hmac.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.pseudo_out_alpha.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.spend_key.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionSetInputAck {
        MoneroTransactionSetInputAck::new()
    }

    fn clear(&mut self) {
        self.vini = ::std::option::Option::None;
        self.vini_hmac = ::std::option::Option::None;
        self.pseudo_out = ::std::option::Option::None;
        self.pseudo_out_hmac = ::std::option::Option::None;
        self.pseudo_out_alpha = ::std::option::Option::None;
        self.spend_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionSetInputAck {
        static instance: MoneroTransactionSetInputAck = MoneroTransactionSetInputAck {
            vini: ::std::option::Option::None,
            vini_hmac: ::std::option::Option::None,
            pseudo_out: ::std::option::Option::None,
            pseudo_out_hmac: ::std::option::Option::None,
            pseudo_out_alpha: ::std::option::Option::None,
            spend_key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionSetInputAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionSetInputAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionSetInputAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSetInputAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionInputViniRequest)
pub struct MoneroTransactionInputViniRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.src_entr)
    pub src_entr: ::protobuf::MessageField<MoneroTransactionSourceEntry>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini)
    pub vini: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini_hmac)
    pub vini_hmac: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out)
    pub pseudo_out: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out_hmac)
    pub pseudo_out_hmac: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.orig_idx)
    pub orig_idx: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionInputViniRequest {
    fn default() -> &'a MoneroTransactionInputViniRequest {
        <MoneroTransactionInputViniRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionInputViniRequest {
    pub fn new() -> MoneroTransactionInputViniRequest {
        ::std::default::Default::default()
    }

    // optional bytes vini = 2;

    pub fn vini(&self) -> &[u8] {
        match self.vini.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_vini(&mut self) {
        self.vini = ::std::option::Option::None;
    }

    pub fn has_vini(&self) -> bool {
        self.vini.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vini(&mut self, v: ::std::vec::Vec<u8>) {
        self.vini = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vini(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vini.is_none() {
            self.vini = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.vini.as_mut().unwrap()
    }

    // Take field
    pub fn take_vini(&mut self) -> ::std::vec::Vec<u8> {
        self.vini.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes vini_hmac = 3;

    pub fn vini_hmac(&self) -> &[u8] {
        match self.vini_hmac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_vini_hmac(&mut self) {
        self.vini_hmac = ::std::option::Option::None;
    }

    pub fn has_vini_hmac(&self) -> bool {
        self.vini_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vini_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.vini_hmac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vini_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vini_hmac.is_none() {
            self.vini_hmac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.vini_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_vini_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.vini_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out = 4;

    pub fn pseudo_out(&self) -> &[u8] {
        match self.pseudo_out.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pseudo_out(&mut self) {
        self.pseudo_out = ::std::option::Option::None;
    }

    pub fn has_pseudo_out(&self) -> bool {
        self.pseudo_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out.is_none() {
            self.pseudo_out = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.pseudo_out.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out_hmac = 5;

    pub fn pseudo_out_hmac(&self) -> &[u8] {
        match self.pseudo_out_hmac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pseudo_out_hmac(&mut self) {
        self.pseudo_out_hmac = ::std::option::Option::None;
    }

    pub fn has_pseudo_out_hmac(&self) -> bool {
        self.pseudo_out_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out_hmac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out_hmac.is_none() {
            self.pseudo_out_hmac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.pseudo_out_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 orig_idx = 6;

    pub fn orig_idx(&self) -> u32 {
        self.orig_idx.unwrap_or(0)
    }

    pub fn clear_orig_idx(&mut self) {
        self.orig_idx = ::std::option::Option::None;
    }

    pub fn has_orig_idx(&self) -> bool {
        self.orig_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orig_idx(&mut self, v: u32) {
        self.orig_idx = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoneroTransactionSourceEntry>(
            "src_entr",
            |m: &MoneroTransactionInputViniRequest| { &m.src_entr },
            |m: &mut MoneroTransactionInputViniRequest| { &mut m.src_entr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vini",
            |m: &MoneroTransactionInputViniRequest| { &m.vini },
            |m: &mut MoneroTransactionInputViniRequest| { &mut m.vini },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vini_hmac",
            |m: &MoneroTransactionInputViniRequest| { &m.vini_hmac },
            |m: &mut MoneroTransactionInputViniRequest| { &mut m.vini_hmac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pseudo_out",
            |m: &MoneroTransactionInputViniRequest| { &m.pseudo_out },
            |m: &mut MoneroTransactionInputViniRequest| { &mut m.pseudo_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pseudo_out_hmac",
            |m: &MoneroTransactionInputViniRequest| { &m.pseudo_out_hmac },
            |m: &mut MoneroTransactionInputViniRequest| { &mut m.pseudo_out_hmac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "orig_idx",
            |m: &MoneroTransactionInputViniRequest| { &m.orig_idx },
            |m: &mut MoneroTransactionInputViniRequest| { &mut m.orig_idx },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionInputViniRequest>(
            "MoneroTransactionInputViniRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionInputViniRequest {
    const NAME: &'static str = "MoneroTransactionInputViniRequest";

    fn is_initialized(&self) -> bool {
        for v in &self.src_entr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.src_entr)?;
                },
                18 => {
                    self.vini = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.vini_hmac = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.pseudo_out = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.pseudo_out_hmac = ::std::option::Option::Some(is.read_bytes()?);
                },
                48 => {
                    self.orig_idx = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.src_entr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.vini.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.vini_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.pseudo_out.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.pseudo_out_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.orig_idx {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.src_entr.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.vini.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.vini_hmac.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.pseudo_out.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.pseudo_out_hmac.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.orig_idx {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionInputViniRequest {
        MoneroTransactionInputViniRequest::new()
    }

    fn clear(&mut self) {
        self.src_entr.clear();
        self.vini = ::std::option::Option::None;
        self.vini_hmac = ::std::option::Option::None;
        self.pseudo_out = ::std::option::Option::None;
        self.pseudo_out_hmac = ::std::option::Option::None;
        self.orig_idx = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionInputViniRequest {
        static instance: MoneroTransactionInputViniRequest = MoneroTransactionInputViniRequest {
            src_entr: ::protobuf::MessageField::none(),
            vini: ::std::option::Option::None,
            vini_hmac: ::std::option::Option::None,
            pseudo_out: ::std::option::Option::None,
            pseudo_out_hmac: ::std::option::Option::None,
            orig_idx: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionInputViniRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionInputViniRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionInputViniRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionInputViniRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionInputViniAck)
pub struct MoneroTransactionInputViniAck {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionInputViniAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionInputViniAck {
    fn default() -> &'a MoneroTransactionInputViniAck {
        <MoneroTransactionInputViniAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionInputViniAck {
    pub fn new() -> MoneroTransactionInputViniAck {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionInputViniAck>(
            "MoneroTransactionInputViniAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionInputViniAck {
    const NAME: &'static str = "MoneroTransactionInputViniAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionInputViniAck {
        MoneroTransactionInputViniAck::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionInputViniAck {
        static instance: MoneroTransactionInputViniAck = MoneroTransactionInputViniAck {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionInputViniAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionInputViniAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionInputViniAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionInputViniAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionAllInputsSetRequest)
pub struct MoneroTransactionAllInputsSetRequest {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionAllInputsSetRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionAllInputsSetRequest {
    fn default() -> &'a MoneroTransactionAllInputsSetRequest {
        <MoneroTransactionAllInputsSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionAllInputsSetRequest {
    pub fn new() -> MoneroTransactionAllInputsSetRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionAllInputsSetRequest>(
            "MoneroTransactionAllInputsSetRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionAllInputsSetRequest {
    const NAME: &'static str = "MoneroTransactionAllInputsSetRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionAllInputsSetRequest {
        MoneroTransactionAllInputsSetRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionAllInputsSetRequest {
        static instance: MoneroTransactionAllInputsSetRequest = MoneroTransactionAllInputsSetRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionAllInputsSetRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionAllInputsSetRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionAllInputsSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionAllInputsSetRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck)
pub struct MoneroTransactionAllInputsSetAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck.rsig_data)
    pub rsig_data: ::protobuf::MessageField<MoneroTransactionRsigData>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionAllInputsSetAck {
    fn default() -> &'a MoneroTransactionAllInputsSetAck {
        <MoneroTransactionAllInputsSetAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionAllInputsSetAck {
    pub fn new() -> MoneroTransactionAllInputsSetAck {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoneroTransactionRsigData>(
            "rsig_data",
            |m: &MoneroTransactionAllInputsSetAck| { &m.rsig_data },
            |m: &mut MoneroTransactionAllInputsSetAck| { &mut m.rsig_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionAllInputsSetAck>(
            "MoneroTransactionAllInputsSetAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionAllInputsSetAck {
    const NAME: &'static str = "MoneroTransactionAllInputsSetAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rsig_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rsig_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionAllInputsSetAck {
        MoneroTransactionAllInputsSetAck::new()
    }

    fn clear(&mut self) {
        self.rsig_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionAllInputsSetAck {
        static instance: MoneroTransactionAllInputsSetAck = MoneroTransactionAllInputsSetAck {
            rsig_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionAllInputsSetAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionAllInputsSetAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionAllInputsSetAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionAllInputsSetAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest)
pub struct MoneroTransactionSetOutputRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr)
    pub dst_entr: ::protobuf::MessageField<MoneroTransactionDestinationEntry>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr_hmac)
    pub dst_entr_hmac: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.rsig_data)
    pub rsig_data: ::protobuf::MessageField<MoneroTransactionRsigData>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.is_offloaded_bp)
    pub is_offloaded_bp: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSetOutputRequest {
    fn default() -> &'a MoneroTransactionSetOutputRequest {
        <MoneroTransactionSetOutputRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSetOutputRequest {
    pub fn new() -> MoneroTransactionSetOutputRequest {
        ::std::default::Default::default()
    }

    // optional bytes dst_entr_hmac = 2;

    pub fn dst_entr_hmac(&self) -> &[u8] {
        match self.dst_entr_hmac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_dst_entr_hmac(&mut self) {
        self.dst_entr_hmac = ::std::option::Option::None;
    }

    pub fn has_dst_entr_hmac(&self) -> bool {
        self.dst_entr_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst_entr_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.dst_entr_hmac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst_entr_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.dst_entr_hmac.is_none() {
            self.dst_entr_hmac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.dst_entr_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_dst_entr_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.dst_entr_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool is_offloaded_bp = 4;

    pub fn is_offloaded_bp(&self) -> bool {
        self.is_offloaded_bp.unwrap_or(false)
    }

    pub fn clear_is_offloaded_bp(&mut self) {
        self.is_offloaded_bp = ::std::option::Option::None;
    }

    pub fn has_is_offloaded_bp(&self) -> bool {
        self.is_offloaded_bp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_offloaded_bp(&mut self, v: bool) {
        self.is_offloaded_bp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoneroTransactionDestinationEntry>(
            "dst_entr",
            |m: &MoneroTransactionSetOutputRequest| { &m.dst_entr },
            |m: &mut MoneroTransactionSetOutputRequest| { &mut m.dst_entr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dst_entr_hmac",
            |m: &MoneroTransactionSetOutputRequest| { &m.dst_entr_hmac },
            |m: &mut MoneroTransactionSetOutputRequest| { &mut m.dst_entr_hmac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoneroTransactionRsigData>(
            "rsig_data",
            |m: &MoneroTransactionSetOutputRequest| { &m.rsig_data },
            |m: &mut MoneroTransactionSetOutputRequest| { &mut m.rsig_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_offloaded_bp",
            |m: &MoneroTransactionSetOutputRequest| { &m.is_offloaded_bp },
            |m: &mut MoneroTransactionSetOutputRequest| { &mut m.is_offloaded_bp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionSetOutputRequest>(
            "MoneroTransactionSetOutputRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionSetOutputRequest {
    const NAME: &'static str = "MoneroTransactionSetOutputRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dst_entr)?;
                },
                18 => {
                    self.dst_entr_hmac = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rsig_data)?;
                },
                32 => {
                    self.is_offloaded_bp = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dst_entr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dst_entr_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.is_offloaded_bp {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dst_entr.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.dst_entr_hmac.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.rsig_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.is_offloaded_bp {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionSetOutputRequest {
        MoneroTransactionSetOutputRequest::new()
    }

    fn clear(&mut self) {
        self.dst_entr.clear();
        self.dst_entr_hmac = ::std::option::Option::None;
        self.rsig_data.clear();
        self.is_offloaded_bp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionSetOutputRequest {
        static instance: MoneroTransactionSetOutputRequest = MoneroTransactionSetOutputRequest {
            dst_entr: ::protobuf::MessageField::none(),
            dst_entr_hmac: ::std::option::Option::None,
            rsig_data: ::protobuf::MessageField::none(),
            is_offloaded_bp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionSetOutputRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionSetOutputRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionSetOutputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSetOutputRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionSetOutputAck)
pub struct MoneroTransactionSetOutputAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.tx_out)
    pub tx_out: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.vouti_hmac)
    pub vouti_hmac: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.rsig_data)
    pub rsig_data: ::protobuf::MessageField<MoneroTransactionRsigData>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.out_pk)
    pub out_pk: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.ecdh_info)
    pub ecdh_info: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSetOutputAck {
    fn default() -> &'a MoneroTransactionSetOutputAck {
        <MoneroTransactionSetOutputAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSetOutputAck {
    pub fn new() -> MoneroTransactionSetOutputAck {
        ::std::default::Default::default()
    }

    // optional bytes tx_out = 1;

    pub fn tx_out(&self) -> &[u8] {
        match self.tx_out.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_tx_out(&mut self) {
        self.tx_out = ::std::option::Option::None;
    }

    pub fn has_tx_out(&self) -> bool {
        self.tx_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_out(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_out = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_out(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tx_out.is_none() {
            self.tx_out = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.tx_out.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_out(&mut self) -> ::std::vec::Vec<u8> {
        self.tx_out.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes vouti_hmac = 2;

    pub fn vouti_hmac(&self) -> &[u8] {
        match self.vouti_hmac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_vouti_hmac(&mut self) {
        self.vouti_hmac = ::std::option::Option::None;
    }

    pub fn has_vouti_hmac(&self) -> bool {
        self.vouti_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vouti_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.vouti_hmac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vouti_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vouti_hmac.is_none() {
            self.vouti_hmac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.vouti_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_vouti_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.vouti_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes out_pk = 4;

    pub fn out_pk(&self) -> &[u8] {
        match self.out_pk.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_out_pk(&mut self) {
        self.out_pk = ::std::option::Option::None;
    }

    pub fn has_out_pk(&self) -> bool {
        self.out_pk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_out_pk(&mut self, v: ::std::vec::Vec<u8>) {
        self.out_pk = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out_pk(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.out_pk.is_none() {
            self.out_pk = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.out_pk.as_mut().unwrap()
    }

    // Take field
    pub fn take_out_pk(&mut self) -> ::std::vec::Vec<u8> {
        self.out_pk.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes ecdh_info = 5;

    pub fn ecdh_info(&self) -> &[u8] {
        match self.ecdh_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ecdh_info(&mut self) {
        self.ecdh_info = ::std::option::Option::None;
    }

    pub fn has_ecdh_info(&self) -> bool {
        self.ecdh_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ecdh_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.ecdh_info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ecdh_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ecdh_info.is_none() {
            self.ecdh_info = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.ecdh_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_ecdh_info(&mut self) -> ::std::vec::Vec<u8> {
        self.ecdh_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tx_out",
            |m: &MoneroTransactionSetOutputAck| { &m.tx_out },
            |m: &mut MoneroTransactionSetOutputAck| { &mut m.tx_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vouti_hmac",
            |m: &MoneroTransactionSetOutputAck| { &m.vouti_hmac },
            |m: &mut MoneroTransactionSetOutputAck| { &mut m.vouti_hmac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoneroTransactionRsigData>(
            "rsig_data",
            |m: &MoneroTransactionSetOutputAck| { &m.rsig_data },
            |m: &mut MoneroTransactionSetOutputAck| { &mut m.rsig_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "out_pk",
            |m: &MoneroTransactionSetOutputAck| { &m.out_pk },
            |m: &mut MoneroTransactionSetOutputAck| { &mut m.out_pk },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ecdh_info",
            |m: &MoneroTransactionSetOutputAck| { &m.ecdh_info },
            |m: &mut MoneroTransactionSetOutputAck| { &mut m.ecdh_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionSetOutputAck>(
            "MoneroTransactionSetOutputAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionSetOutputAck {
    const NAME: &'static str = "MoneroTransactionSetOutputAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tx_out = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.vouti_hmac = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rsig_data)?;
                },
                34 => {
                    self.out_pk = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.ecdh_info = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tx_out.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.vouti_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.out_pk.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.ecdh_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tx_out.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.vouti_hmac.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.rsig_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.out_pk.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.ecdh_info.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionSetOutputAck {
        MoneroTransactionSetOutputAck::new()
    }

    fn clear(&mut self) {
        self.tx_out = ::std::option::Option::None;
        self.vouti_hmac = ::std::option::Option::None;
        self.rsig_data.clear();
        self.out_pk = ::std::option::Option::None;
        self.ecdh_info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionSetOutputAck {
        static instance: MoneroTransactionSetOutputAck = MoneroTransactionSetOutputAck {
            tx_out: ::std::option::Option::None,
            vouti_hmac: ::std::option::Option::None,
            rsig_data: ::protobuf::MessageField::none(),
            out_pk: ::std::option::Option::None,
            ecdh_info: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionSetOutputAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionSetOutputAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionSetOutputAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSetOutputAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest)
pub struct MoneroTransactionAllOutSetRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest.rsig_data)
    pub rsig_data: ::protobuf::MessageField<MoneroTransactionRsigData>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionAllOutSetRequest {
    fn default() -> &'a MoneroTransactionAllOutSetRequest {
        <MoneroTransactionAllOutSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionAllOutSetRequest {
    pub fn new() -> MoneroTransactionAllOutSetRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoneroTransactionRsigData>(
            "rsig_data",
            |m: &MoneroTransactionAllOutSetRequest| { &m.rsig_data },
            |m: &mut MoneroTransactionAllOutSetRequest| { &mut m.rsig_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionAllOutSetRequest>(
            "MoneroTransactionAllOutSetRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionAllOutSetRequest {
    const NAME: &'static str = "MoneroTransactionAllOutSetRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rsig_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rsig_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionAllOutSetRequest {
        MoneroTransactionAllOutSetRequest::new()
    }

    fn clear(&mut self) {
        self.rsig_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionAllOutSetRequest {
        static instance: MoneroTransactionAllOutSetRequest = MoneroTransactionAllOutSetRequest {
            rsig_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionAllOutSetRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionAllOutSetRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionAllOutSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionAllOutSetRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck)
pub struct MoneroTransactionAllOutSetAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.extra)
    pub extra: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.tx_prefix_hash)
    pub tx_prefix_hash: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.rv)
    pub rv: ::protobuf::MessageField<monero_transaction_all_out_set_ack::MoneroRingCtSig>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.full_message_hash)
    pub full_message_hash: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionAllOutSetAck {
    fn default() -> &'a MoneroTransactionAllOutSetAck {
        <MoneroTransactionAllOutSetAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionAllOutSetAck {
    pub fn new() -> MoneroTransactionAllOutSetAck {
        ::std::default::Default::default()
    }

    // optional bytes extra = 1;

    pub fn extra(&self) -> &[u8] {
        match self.extra.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_extra(&mut self) {
        self.extra = ::std::option::Option::None;
    }

    pub fn has_extra(&self) -> bool {
        self.extra.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra.is_none() {
            self.extra = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.extra.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra(&mut self) -> ::std::vec::Vec<u8> {
        self.extra.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes tx_prefix_hash = 2;

    pub fn tx_prefix_hash(&self) -> &[u8] {
        match self.tx_prefix_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_tx_prefix_hash(&mut self) {
        self.tx_prefix_hash = ::std::option::Option::None;
    }

    pub fn has_tx_prefix_hash(&self) -> bool {
        self.tx_prefix_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_prefix_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_prefix_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_prefix_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tx_prefix_hash.is_none() {
            self.tx_prefix_hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.tx_prefix_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_prefix_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.tx_prefix_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes full_message_hash = 5;

    pub fn full_message_hash(&self) -> &[u8] {
        match self.full_message_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_full_message_hash(&mut self) {
        self.full_message_hash = ::std::option::Option::None;
    }

    pub fn has_full_message_hash(&self) -> bool {
        self.full_message_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_full_message_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.full_message_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_full_message_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.full_message_hash.is_none() {
            self.full_message_hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.full_message_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_full_message_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.full_message_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "extra",
            |m: &MoneroTransactionAllOutSetAck| { &m.extra },
            |m: &mut MoneroTransactionAllOutSetAck| { &mut m.extra },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tx_prefix_hash",
            |m: &MoneroTransactionAllOutSetAck| { &m.tx_prefix_hash },
            |m: &mut MoneroTransactionAllOutSetAck| { &mut m.tx_prefix_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, monero_transaction_all_out_set_ack::MoneroRingCtSig>(
            "rv",
            |m: &MoneroTransactionAllOutSetAck| { &m.rv },
            |m: &mut MoneroTransactionAllOutSetAck| { &mut m.rv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "full_message_hash",
            |m: &MoneroTransactionAllOutSetAck| { &m.full_message_hash },
            |m: &mut MoneroTransactionAllOutSetAck| { &mut m.full_message_hash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionAllOutSetAck>(
            "MoneroTransactionAllOutSetAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionAllOutSetAck {
    const NAME: &'static str = "MoneroTransactionAllOutSetAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.extra = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.tx_prefix_hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rv)?;
                },
                42 => {
                    self.full_message_hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.extra.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.tx_prefix_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.rv.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.full_message_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.extra.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.tx_prefix_hash.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.rv.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.full_message_hash.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionAllOutSetAck {
        MoneroTransactionAllOutSetAck::new()
    }

    fn clear(&mut self) {
        self.extra = ::std::option::Option::None;
        self.tx_prefix_hash = ::std::option::Option::None;
        self.rv.clear();
        self.full_message_hash = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionAllOutSetAck {
        static instance: MoneroTransactionAllOutSetAck = MoneroTransactionAllOutSetAck {
            extra: ::std::option::Option::None,
            tx_prefix_hash: ::std::option::Option::None,
            rv: ::protobuf::MessageField::none(),
            full_message_hash: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionAllOutSetAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionAllOutSetAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionAllOutSetAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionAllOutSetAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MoneroTransactionAllOutSetAck`
pub mod monero_transaction_all_out_set_ack {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig)
    pub struct MoneroRingCtSig {
        // message fields
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.txn_fee)
        pub txn_fee: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.message)
        pub message: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.rv_type)
        pub rv_type: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MoneroRingCtSig {
        fn default() -> &'a MoneroRingCtSig {
            <MoneroRingCtSig as ::protobuf::Message>::default_instance()
        }
    }

    impl MoneroRingCtSig {
        pub fn new() -> MoneroRingCtSig {
            ::std::default::Default::default()
        }

        // optional uint64 txn_fee = 1;

        pub fn txn_fee(&self) -> u64 {
            self.txn_fee.unwrap_or(0)
        }

        pub fn clear_txn_fee(&mut self) {
            self.txn_fee = ::std::option::Option::None;
        }

        pub fn has_txn_fee(&self) -> bool {
            self.txn_fee.is_some()
        }

        // Param is passed by value, moved
        pub fn set_txn_fee(&mut self, v: u64) {
            self.txn_fee = ::std::option::Option::Some(v);
        }

        // optional bytes message = 2;

        pub fn message(&self) -> &[u8] {
            match self.message.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_message(&mut self) {
            self.message = ::std::option::Option::None;
        }

        pub fn has_message(&self) -> bool {
            self.message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_message(&mut self, v: ::std::vec::Vec<u8>) {
            self.message = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_message(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.message.is_none() {
                self.message = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.message.as_mut().unwrap()
        }

        // Take field
        pub fn take_message(&mut self) -> ::std::vec::Vec<u8> {
            self.message.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint32 rv_type = 3;

        pub fn rv_type(&self) -> u32 {
            self.rv_type.unwrap_or(0)
        }

        pub fn clear_rv_type(&mut self) {
            self.rv_type = ::std::option::Option::None;
        }

        pub fn has_rv_type(&self) -> bool {
            self.rv_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rv_type(&mut self, v: u32) {
            self.rv_type = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "txn_fee",
                |m: &MoneroRingCtSig| { &m.txn_fee },
                |m: &mut MoneroRingCtSig| { &mut m.txn_fee },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "message",
                |m: &MoneroRingCtSig| { &m.message },
                |m: &mut MoneroRingCtSig| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rv_type",
                |m: &MoneroRingCtSig| { &m.rv_type },
                |m: &mut MoneroRingCtSig| { &mut m.rv_type },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroRingCtSig>(
                "MoneroTransactionAllOutSetAck.MoneroRingCtSig",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MoneroRingCtSig {
        const NAME: &'static str = "MoneroRingCtSig";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.txn_fee = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        self.message = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    24 => {
                        self.rv_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.txn_fee {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.message.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            if let Some(v) = self.rv_type {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.txn_fee {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.message.as_ref() {
                os.write_bytes(2, v)?;
            }
            if let Some(v) = self.rv_type {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MoneroRingCtSig {
            MoneroRingCtSig::new()
        }

        fn clear(&mut self) {
            self.txn_fee = ::std::option::Option::None;
            self.message = ::std::option::Option::None;
            self.rv_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MoneroRingCtSig {
            static instance: MoneroRingCtSig = MoneroRingCtSig {
                txn_fee: ::std::option::Option::None,
                message: ::std::option::Option::None,
                rv_type: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MoneroRingCtSig {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MoneroTransactionAllOutSetAck.MoneroRingCtSig").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MoneroRingCtSig {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MoneroRingCtSig {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionSignInputRequest)
pub struct MoneroTransactionSignInputRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.src_entr)
    pub src_entr: ::protobuf::MessageField<MoneroTransactionSourceEntry>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini)
    pub vini: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini_hmac)
    pub vini_hmac: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out)
    pub pseudo_out: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_hmac)
    pub pseudo_out_hmac: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_alpha)
    pub pseudo_out_alpha: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.spend_key)
    pub spend_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.orig_idx)
    pub orig_idx: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSignInputRequest {
    fn default() -> &'a MoneroTransactionSignInputRequest {
        <MoneroTransactionSignInputRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSignInputRequest {
    pub fn new() -> MoneroTransactionSignInputRequest {
        ::std::default::Default::default()
    }

    // optional bytes vini = 2;

    pub fn vini(&self) -> &[u8] {
        match self.vini.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_vini(&mut self) {
        self.vini = ::std::option::Option::None;
    }

    pub fn has_vini(&self) -> bool {
        self.vini.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vini(&mut self, v: ::std::vec::Vec<u8>) {
        self.vini = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vini(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vini.is_none() {
            self.vini = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.vini.as_mut().unwrap()
    }

    // Take field
    pub fn take_vini(&mut self) -> ::std::vec::Vec<u8> {
        self.vini.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes vini_hmac = 3;

    pub fn vini_hmac(&self) -> &[u8] {
        match self.vini_hmac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_vini_hmac(&mut self) {
        self.vini_hmac = ::std::option::Option::None;
    }

    pub fn has_vini_hmac(&self) -> bool {
        self.vini_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vini_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.vini_hmac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vini_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vini_hmac.is_none() {
            self.vini_hmac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.vini_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_vini_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.vini_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out = 4;

    pub fn pseudo_out(&self) -> &[u8] {
        match self.pseudo_out.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pseudo_out(&mut self) {
        self.pseudo_out = ::std::option::Option::None;
    }

    pub fn has_pseudo_out(&self) -> bool {
        self.pseudo_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out.is_none() {
            self.pseudo_out = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.pseudo_out.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out_hmac = 5;

    pub fn pseudo_out_hmac(&self) -> &[u8] {
        match self.pseudo_out_hmac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pseudo_out_hmac(&mut self) {
        self.pseudo_out_hmac = ::std::option::Option::None;
    }

    pub fn has_pseudo_out_hmac(&self) -> bool {
        self.pseudo_out_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out_hmac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out_hmac.is_none() {
            self.pseudo_out_hmac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.pseudo_out_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out_alpha = 6;

    pub fn pseudo_out_alpha(&self) -> &[u8] {
        match self.pseudo_out_alpha.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pseudo_out_alpha(&mut self) {
        self.pseudo_out_alpha = ::std::option::Option::None;
    }

    pub fn has_pseudo_out_alpha(&self) -> bool {
        self.pseudo_out_alpha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out_alpha(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out_alpha = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out_alpha(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out_alpha.is_none() {
            self.pseudo_out_alpha = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.pseudo_out_alpha.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out_alpha(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out_alpha.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes spend_key = 7;

    pub fn spend_key(&self) -> &[u8] {
        match self.spend_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_spend_key(&mut self) {
        self.spend_key = ::std::option::Option::None;
    }

    pub fn has_spend_key(&self) -> bool {
        self.spend_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spend_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.spend_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spend_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.spend_key.is_none() {
            self.spend_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.spend_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_spend_key(&mut self) -> ::std::vec::Vec<u8> {
        self.spend_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 orig_idx = 8;

    pub fn orig_idx(&self) -> u32 {
        self.orig_idx.unwrap_or(0)
    }

    pub fn clear_orig_idx(&mut self) {
        self.orig_idx = ::std::option::Option::None;
    }

    pub fn has_orig_idx(&self) -> bool {
        self.orig_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orig_idx(&mut self, v: u32) {
        self.orig_idx = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoneroTransactionSourceEntry>(
            "src_entr",
            |m: &MoneroTransactionSignInputRequest| { &m.src_entr },
            |m: &mut MoneroTransactionSignInputRequest| { &mut m.src_entr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vini",
            |m: &MoneroTransactionSignInputRequest| { &m.vini },
            |m: &mut MoneroTransactionSignInputRequest| { &mut m.vini },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vini_hmac",
            |m: &MoneroTransactionSignInputRequest| { &m.vini_hmac },
            |m: &mut MoneroTransactionSignInputRequest| { &mut m.vini_hmac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pseudo_out",
            |m: &MoneroTransactionSignInputRequest| { &m.pseudo_out },
            |m: &mut MoneroTransactionSignInputRequest| { &mut m.pseudo_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pseudo_out_hmac",
            |m: &MoneroTransactionSignInputRequest| { &m.pseudo_out_hmac },
            |m: &mut MoneroTransactionSignInputRequest| { &mut m.pseudo_out_hmac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pseudo_out_alpha",
            |m: &MoneroTransactionSignInputRequest| { &m.pseudo_out_alpha },
            |m: &mut MoneroTransactionSignInputRequest| { &mut m.pseudo_out_alpha },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spend_key",
            |m: &MoneroTransactionSignInputRequest| { &m.spend_key },
            |m: &mut MoneroTransactionSignInputRequest| { &mut m.spend_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "orig_idx",
            |m: &MoneroTransactionSignInputRequest| { &m.orig_idx },
            |m: &mut MoneroTransactionSignInputRequest| { &mut m.orig_idx },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionSignInputRequest>(
            "MoneroTransactionSignInputRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionSignInputRequest {
    const NAME: &'static str = "MoneroTransactionSignInputRequest";

    fn is_initialized(&self) -> bool {
        for v in &self.src_entr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.src_entr)?;
                },
                18 => {
                    self.vini = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.vini_hmac = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.pseudo_out = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.pseudo_out_hmac = ::std::option::Option::Some(is.read_bytes()?);
                },
                50 => {
                    self.pseudo_out_alpha = ::std::option::Option::Some(is.read_bytes()?);
                },
                58 => {
                    self.spend_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                64 => {
                    self.orig_idx = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.src_entr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.vini.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.vini_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.pseudo_out.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.pseudo_out_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.pseudo_out_alpha.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.spend_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.orig_idx {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.src_entr.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.vini.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.vini_hmac.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.pseudo_out.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.pseudo_out_hmac.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.pseudo_out_alpha.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.spend_key.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.orig_idx {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionSignInputRequest {
        MoneroTransactionSignInputRequest::new()
    }

    fn clear(&mut self) {
        self.src_entr.clear();
        self.vini = ::std::option::Option::None;
        self.vini_hmac = ::std::option::Option::None;
        self.pseudo_out = ::std::option::Option::None;
        self.pseudo_out_hmac = ::std::option::Option::None;
        self.pseudo_out_alpha = ::std::option::Option::None;
        self.spend_key = ::std::option::Option::None;
        self.orig_idx = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionSignInputRequest {
        static instance: MoneroTransactionSignInputRequest = MoneroTransactionSignInputRequest {
            src_entr: ::protobuf::MessageField::none(),
            vini: ::std::option::Option::None,
            vini_hmac: ::std::option::Option::None,
            pseudo_out: ::std::option::Option::None,
            pseudo_out_hmac: ::std::option::Option::None,
            pseudo_out_alpha: ::std::option::Option::None,
            spend_key: ::std::option::Option::None,
            orig_idx: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionSignInputRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionSignInputRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionSignInputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSignInputRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionSignInputAck)
pub struct MoneroTransactionSignInputAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSignInputAck.signature)
    pub signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionSignInputAck.pseudo_out)
    pub pseudo_out: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionSignInputAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSignInputAck {
    fn default() -> &'a MoneroTransactionSignInputAck {
        <MoneroTransactionSignInputAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSignInputAck {
    pub fn new() -> MoneroTransactionSignInputAck {
        ::std::default::Default::default()
    }

    // optional bytes signature = 1;

    pub fn signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out = 2;

    pub fn pseudo_out(&self) -> &[u8] {
        match self.pseudo_out.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pseudo_out(&mut self) {
        self.pseudo_out = ::std::option::Option::None;
    }

    pub fn has_pseudo_out(&self) -> bool {
        self.pseudo_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out.is_none() {
            self.pseudo_out = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.pseudo_out.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signature",
            |m: &MoneroTransactionSignInputAck| { &m.signature },
            |m: &mut MoneroTransactionSignInputAck| { &mut m.signature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pseudo_out",
            |m: &MoneroTransactionSignInputAck| { &m.pseudo_out },
            |m: &mut MoneroTransactionSignInputAck| { &mut m.pseudo_out },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionSignInputAck>(
            "MoneroTransactionSignInputAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionSignInputAck {
    const NAME: &'static str = "MoneroTransactionSignInputAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.pseudo_out = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.pseudo_out.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.signature.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.pseudo_out.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionSignInputAck {
        MoneroTransactionSignInputAck::new()
    }

    fn clear(&mut self) {
        self.signature = ::std::option::Option::None;
        self.pseudo_out = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionSignInputAck {
        static instance: MoneroTransactionSignInputAck = MoneroTransactionSignInputAck {
            signature: ::std::option::Option::None,
            pseudo_out: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionSignInputAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionSignInputAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionSignInputAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSignInputAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionFinalRequest)
pub struct MoneroTransactionFinalRequest {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionFinalRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionFinalRequest {
    fn default() -> &'a MoneroTransactionFinalRequest {
        <MoneroTransactionFinalRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionFinalRequest {
    pub fn new() -> MoneroTransactionFinalRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionFinalRequest>(
            "MoneroTransactionFinalRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionFinalRequest {
    const NAME: &'static str = "MoneroTransactionFinalRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionFinalRequest {
        MoneroTransactionFinalRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionFinalRequest {
        static instance: MoneroTransactionFinalRequest = MoneroTransactionFinalRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionFinalRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionFinalRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionFinalRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionFinalRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroTransactionFinalAck)
pub struct MoneroTransactionFinalAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionFinalAck.cout_key)
    pub cout_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionFinalAck.salt)
    pub salt: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionFinalAck.rand_mult)
    pub rand_mult: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionFinalAck.tx_enc_keys)
    pub tx_enc_keys: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroTransactionFinalAck.opening_key)
    pub opening_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroTransactionFinalAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionFinalAck {
    fn default() -> &'a MoneroTransactionFinalAck {
        <MoneroTransactionFinalAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionFinalAck {
    pub fn new() -> MoneroTransactionFinalAck {
        ::std::default::Default::default()
    }

    // optional bytes cout_key = 1;

    pub fn cout_key(&self) -> &[u8] {
        match self.cout_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_cout_key(&mut self) {
        self.cout_key = ::std::option::Option::None;
    }

    pub fn has_cout_key(&self) -> bool {
        self.cout_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cout_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.cout_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cout_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.cout_key.is_none() {
            self.cout_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.cout_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_cout_key(&mut self) -> ::std::vec::Vec<u8> {
        self.cout_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes salt = 2;

    pub fn salt(&self) -> &[u8] {
        match self.salt.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_salt(&mut self) {
        self.salt = ::std::option::Option::None;
    }

    pub fn has_salt(&self) -> bool {
        self.salt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_salt(&mut self, v: ::std::vec::Vec<u8>) {
        self.salt = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_salt(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.salt.is_none() {
            self.salt = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.salt.as_mut().unwrap()
    }

    // Take field
    pub fn take_salt(&mut self) -> ::std::vec::Vec<u8> {
        self.salt.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes rand_mult = 3;

    pub fn rand_mult(&self) -> &[u8] {
        match self.rand_mult.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_rand_mult(&mut self) {
        self.rand_mult = ::std::option::Option::None;
    }

    pub fn has_rand_mult(&self) -> bool {
        self.rand_mult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rand_mult(&mut self, v: ::std::vec::Vec<u8>) {
        self.rand_mult = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rand_mult(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.rand_mult.is_none() {
            self.rand_mult = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.rand_mult.as_mut().unwrap()
    }

    // Take field
    pub fn take_rand_mult(&mut self) -> ::std::vec::Vec<u8> {
        self.rand_mult.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes tx_enc_keys = 4;

    pub fn tx_enc_keys(&self) -> &[u8] {
        match self.tx_enc_keys.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_tx_enc_keys(&mut self) {
        self.tx_enc_keys = ::std::option::Option::None;
    }

    pub fn has_tx_enc_keys(&self) -> bool {
        self.tx_enc_keys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_enc_keys(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_enc_keys = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_enc_keys(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tx_enc_keys.is_none() {
            self.tx_enc_keys = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.tx_enc_keys.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_enc_keys(&mut self) -> ::std::vec::Vec<u8> {
        self.tx_enc_keys.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes opening_key = 5;

    pub fn opening_key(&self) -> &[u8] {
        match self.opening_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_opening_key(&mut self) {
        self.opening_key = ::std::option::Option::None;
    }

    pub fn has_opening_key(&self) -> bool {
        self.opening_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opening_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.opening_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_opening_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.opening_key.is_none() {
            self.opening_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.opening_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_opening_key(&mut self) -> ::std::vec::Vec<u8> {
        self.opening_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cout_key",
            |m: &MoneroTransactionFinalAck| { &m.cout_key },
            |m: &mut MoneroTransactionFinalAck| { &mut m.cout_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "salt",
            |m: &MoneroTransactionFinalAck| { &m.salt },
            |m: &mut MoneroTransactionFinalAck| { &mut m.salt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rand_mult",
            |m: &MoneroTransactionFinalAck| { &m.rand_mult },
            |m: &mut MoneroTransactionFinalAck| { &mut m.rand_mult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tx_enc_keys",
            |m: &MoneroTransactionFinalAck| { &m.tx_enc_keys },
            |m: &mut MoneroTransactionFinalAck| { &mut m.tx_enc_keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "opening_key",
            |m: &MoneroTransactionFinalAck| { &m.opening_key },
            |m: &mut MoneroTransactionFinalAck| { &mut m.opening_key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransactionFinalAck>(
            "MoneroTransactionFinalAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroTransactionFinalAck {
    const NAME: &'static str = "MoneroTransactionFinalAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cout_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.salt = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.rand_mult = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.tx_enc_keys = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.opening_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cout_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.salt.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.rand_mult.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.tx_enc_keys.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.opening_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cout_key.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.salt.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.rand_mult.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.tx_enc_keys.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.opening_key.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroTransactionFinalAck {
        MoneroTransactionFinalAck::new()
    }

    fn clear(&mut self) {
        self.cout_key = ::std::option::Option::None;
        self.salt = ::std::option::Option::None;
        self.rand_mult = ::std::option::Option::None;
        self.tx_enc_keys = ::std::option::Option::None;
        self.opening_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroTransactionFinalAck {
        static instance: MoneroTransactionFinalAck = MoneroTransactionFinalAck {
            cout_key: ::std::option::Option::None,
            salt: ::std::option::Option::None,
            rand_mult: ::std::option::Option::None,
            tx_enc_keys: ::std::option::Option::None,
            opening_key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroTransactionFinalAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroTransactionFinalAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroTransactionFinalAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionFinalAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest)
pub struct MoneroKeyImageExportInitRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.num)
    pub num: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.hash)
    pub hash: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.address_n)
    pub address_n: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.network_type)
    pub network_type: ::std::option::Option<::protobuf::EnumOrUnknown<MoneroNetworkType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.subs)
    pub subs: ::std::vec::Vec<monero_key_image_export_init_request::MoneroSubAddressIndicesList>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageExportInitRequest {
    fn default() -> &'a MoneroKeyImageExportInitRequest {
        <MoneroKeyImageExportInitRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageExportInitRequest {
    pub fn new() -> MoneroKeyImageExportInitRequest {
        ::std::default::Default::default()
    }

    // required uint64 num = 1;

    pub fn num(&self) -> u64 {
        self.num.unwrap_or(0)
    }

    pub fn clear_num(&mut self) {
        self.num = ::std::option::Option::None;
    }

    pub fn has_num(&self) -> bool {
        self.num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num(&mut self, v: u64) {
        self.num = ::std::option::Option::Some(v);
    }

    // required bytes hash = 2;

    pub fn hash(&self) -> &[u8] {
        match self.hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_hash(&mut self) {
        self.hash = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.hash.is_none() {
            self.hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 4;

    pub fn network_type(&self) -> MoneroNetworkType {
        match self.network_type {
            Some(e) => e.enum_value_or(MoneroNetworkType::MAINNET),
            None => MoneroNetworkType::MAINNET,
        }
    }

    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: MoneroNetworkType) {
        self.network_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num",
            |m: &MoneroKeyImageExportInitRequest| { &m.num },
            |m: &mut MoneroKeyImageExportInitRequest| { &mut m.num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hash",
            |m: &MoneroKeyImageExportInitRequest| { &m.hash },
            |m: &mut MoneroKeyImageExportInitRequest| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "address_n",
            |m: &MoneroKeyImageExportInitRequest| { &m.address_n },
            |m: &mut MoneroKeyImageExportInitRequest| { &mut m.address_n },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_type",
            |m: &MoneroKeyImageExportInitRequest| { &m.network_type },
            |m: &mut MoneroKeyImageExportInitRequest| { &mut m.network_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subs",
            |m: &MoneroKeyImageExportInitRequest| { &m.subs },
            |m: &mut MoneroKeyImageExportInitRequest| { &mut m.subs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroKeyImageExportInitRequest>(
            "MoneroKeyImageExportInitRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroKeyImageExportInitRequest {
    const NAME: &'static str = "MoneroKeyImageExportInitRequest";

    fn is_initialized(&self) -> bool {
        if self.num.is_none() {
            return false;
        }
        if self.hash.is_none() {
            return false;
        }
        for v in &self.subs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.num = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.address_n)?;
                },
                24 => {
                    self.address_n.push(is.read_uint32()?);
                },
                32 => {
                    self.network_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                42 => {
                    self.subs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.num {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        for value in &self.address_n {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        for value in &self.subs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.num {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.hash.as_ref() {
            os.write_bytes(2, v)?;
        }
        for v in &self.address_n {
            os.write_uint32(3, *v)?;
        };
        if let Some(v) = self.network_type {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.subs {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroKeyImageExportInitRequest {
        MoneroKeyImageExportInitRequest::new()
    }

    fn clear(&mut self) {
        self.num = ::std::option::Option::None;
        self.hash = ::std::option::Option::None;
        self.address_n.clear();
        self.network_type = ::std::option::Option::None;
        self.subs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroKeyImageExportInitRequest {
        static instance: MoneroKeyImageExportInitRequest = MoneroKeyImageExportInitRequest {
            num: ::std::option::Option::None,
            hash: ::std::option::Option::None,
            address_n: ::std::vec::Vec::new(),
            network_type: ::std::option::Option::None,
            subs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroKeyImageExportInitRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroKeyImageExportInitRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroKeyImageExportInitRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageExportInitRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MoneroKeyImageExportInitRequest`
pub mod monero_key_image_export_init_request {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList)
    pub struct MoneroSubAddressIndicesList {
        // message fields
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.account)
        pub account: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.minor_indices)
        pub minor_indices: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MoneroSubAddressIndicesList {
        fn default() -> &'a MoneroSubAddressIndicesList {
            <MoneroSubAddressIndicesList as ::protobuf::Message>::default_instance()
        }
    }

    impl MoneroSubAddressIndicesList {
        pub fn new() -> MoneroSubAddressIndicesList {
            ::std::default::Default::default()
        }

        // required uint32 account = 1;

        pub fn account(&self) -> u32 {
            self.account.unwrap_or(0)
        }

        pub fn clear_account(&mut self) {
            self.account = ::std::option::Option::None;
        }

        pub fn has_account(&self) -> bool {
            self.account.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account(&mut self, v: u32) {
            self.account = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account",
                |m: &MoneroSubAddressIndicesList| { &m.account },
                |m: &mut MoneroSubAddressIndicesList| { &mut m.account },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "minor_indices",
                |m: &MoneroSubAddressIndicesList| { &m.minor_indices },
                |m: &mut MoneroSubAddressIndicesList| { &mut m.minor_indices },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroSubAddressIndicesList>(
                "MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MoneroSubAddressIndicesList {
        const NAME: &'static str = "MoneroSubAddressIndicesList";

        fn is_initialized(&self) -> bool {
            if self.account.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        is.read_repeated_packed_uint32_into(&mut self.minor_indices)?;
                    },
                    16 => {
                        self.minor_indices.push(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.minor_indices {
                my_size += ::protobuf::rt::uint32_size(2, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account {
                os.write_uint32(1, v)?;
            }
            for v in &self.minor_indices {
                os.write_uint32(2, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MoneroSubAddressIndicesList {
            MoneroSubAddressIndicesList::new()
        }

        fn clear(&mut self) {
            self.account = ::std::option::Option::None;
            self.minor_indices.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MoneroSubAddressIndicesList {
            static instance: MoneroSubAddressIndicesList = MoneroSubAddressIndicesList {
                account: ::std::option::Option::None,
                minor_indices: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MoneroSubAddressIndicesList {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MoneroSubAddressIndicesList {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MoneroSubAddressIndicesList {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroKeyImageExportInitAck)
pub struct MoneroKeyImageExportInitAck {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroKeyImageExportInitAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageExportInitAck {
    fn default() -> &'a MoneroKeyImageExportInitAck {
        <MoneroKeyImageExportInitAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageExportInitAck {
    pub fn new() -> MoneroKeyImageExportInitAck {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroKeyImageExportInitAck>(
            "MoneroKeyImageExportInitAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroKeyImageExportInitAck {
    const NAME: &'static str = "MoneroKeyImageExportInitAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroKeyImageExportInitAck {
        MoneroKeyImageExportInitAck::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroKeyImageExportInitAck {
        static instance: MoneroKeyImageExportInitAck = MoneroKeyImageExportInitAck {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroKeyImageExportInitAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroKeyImageExportInitAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroKeyImageExportInitAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageExportInitAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest)
pub struct MoneroKeyImageSyncStepRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.tdis)
    pub tdis: ::std::vec::Vec<monero_key_image_sync_step_request::MoneroTransferDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageSyncStepRequest {
    fn default() -> &'a MoneroKeyImageSyncStepRequest {
        <MoneroKeyImageSyncStepRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageSyncStepRequest {
    pub fn new() -> MoneroKeyImageSyncStepRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tdis",
            |m: &MoneroKeyImageSyncStepRequest| { &m.tdis },
            |m: &mut MoneroKeyImageSyncStepRequest| { &mut m.tdis },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroKeyImageSyncStepRequest>(
            "MoneroKeyImageSyncStepRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroKeyImageSyncStepRequest {
    const NAME: &'static str = "MoneroKeyImageSyncStepRequest";

    fn is_initialized(&self) -> bool {
        for v in &self.tdis {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tdis.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.tdis {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.tdis {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroKeyImageSyncStepRequest {
        MoneroKeyImageSyncStepRequest::new()
    }

    fn clear(&mut self) {
        self.tdis.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroKeyImageSyncStepRequest {
        static instance: MoneroKeyImageSyncStepRequest = MoneroKeyImageSyncStepRequest {
            tdis: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroKeyImageSyncStepRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroKeyImageSyncStepRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroKeyImageSyncStepRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageSyncStepRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MoneroKeyImageSyncStepRequest`
pub mod monero_key_image_sync_step_request {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails)
    pub struct MoneroTransferDetails {
        // message fields
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.out_key)
        pub out_key: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.tx_pub_key)
        pub tx_pub_key: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
        pub additional_tx_pub_keys: ::std::vec::Vec<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.internal_output_index)
        pub internal_output_index: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.sub_addr_major)
        pub sub_addr_major: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.sub_addr_minor)
        pub sub_addr_minor: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MoneroTransferDetails {
        fn default() -> &'a MoneroTransferDetails {
            <MoneroTransferDetails as ::protobuf::Message>::default_instance()
        }
    }

    impl MoneroTransferDetails {
        pub fn new() -> MoneroTransferDetails {
            ::std::default::Default::default()
        }

        // required bytes out_key = 1;

        pub fn out_key(&self) -> &[u8] {
            match self.out_key.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_out_key(&mut self) {
            self.out_key = ::std::option::Option::None;
        }

        pub fn has_out_key(&self) -> bool {
            self.out_key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_out_key(&mut self, v: ::std::vec::Vec<u8>) {
            self.out_key = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_out_key(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.out_key.is_none() {
                self.out_key = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.out_key.as_mut().unwrap()
        }

        // Take field
        pub fn take_out_key(&mut self) -> ::std::vec::Vec<u8> {
            self.out_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // required bytes tx_pub_key = 2;

        pub fn tx_pub_key(&self) -> &[u8] {
            match self.tx_pub_key.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_tx_pub_key(&mut self) {
            self.tx_pub_key = ::std::option::Option::None;
        }

        pub fn has_tx_pub_key(&self) -> bool {
            self.tx_pub_key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tx_pub_key(&mut self, v: ::std::vec::Vec<u8>) {
            self.tx_pub_key = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_tx_pub_key(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.tx_pub_key.is_none() {
                self.tx_pub_key = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.tx_pub_key.as_mut().unwrap()
        }

        // Take field
        pub fn take_tx_pub_key(&mut self) -> ::std::vec::Vec<u8> {
            self.tx_pub_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // required uint64 internal_output_index = 4;

        pub fn internal_output_index(&self) -> u64 {
            self.internal_output_index.unwrap_or(0)
        }

        pub fn clear_internal_output_index(&mut self) {
            self.internal_output_index = ::std::option::Option::None;
        }

        pub fn has_internal_output_index(&self) -> bool {
            self.internal_output_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_internal_output_index(&mut self, v: u64) {
            self.internal_output_index = ::std::option::Option::Some(v);
        }

        // optional uint32 sub_addr_major = 5;

        pub fn sub_addr_major(&self) -> u32 {
            self.sub_addr_major.unwrap_or(0)
        }

        pub fn clear_sub_addr_major(&mut self) {
            self.sub_addr_major = ::std::option::Option::None;
        }

        pub fn has_sub_addr_major(&self) -> bool {
            self.sub_addr_major.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sub_addr_major(&mut self, v: u32) {
            self.sub_addr_major = ::std::option::Option::Some(v);
        }

        // optional uint32 sub_addr_minor = 6;

        pub fn sub_addr_minor(&self) -> u32 {
            self.sub_addr_minor.unwrap_or(0)
        }

        pub fn clear_sub_addr_minor(&mut self) {
            self.sub_addr_minor = ::std::option::Option::None;
        }

        pub fn has_sub_addr_minor(&self) -> bool {
            self.sub_addr_minor.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sub_addr_minor(&mut self, v: u32) {
            self.sub_addr_minor = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "out_key",
                |m: &MoneroTransferDetails| { &m.out_key },
                |m: &mut MoneroTransferDetails| { &mut m.out_key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tx_pub_key",
                |m: &MoneroTransferDetails| { &m.tx_pub_key },
                |m: &mut MoneroTransferDetails| { &mut m.tx_pub_key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "additional_tx_pub_keys",
                |m: &MoneroTransferDetails| { &m.additional_tx_pub_keys },
                |m: &mut MoneroTransferDetails| { &mut m.additional_tx_pub_keys },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "internal_output_index",
                |m: &MoneroTransferDetails| { &m.internal_output_index },
                |m: &mut MoneroTransferDetails| { &mut m.internal_output_index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sub_addr_major",
                |m: &MoneroTransferDetails| { &m.sub_addr_major },
                |m: &mut MoneroTransferDetails| { &mut m.sub_addr_major },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sub_addr_minor",
                |m: &MoneroTransferDetails| { &m.sub_addr_minor },
                |m: &mut MoneroTransferDetails| { &mut m.sub_addr_minor },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroTransferDetails>(
                "MoneroKeyImageSyncStepRequest.MoneroTransferDetails",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MoneroTransferDetails {
        const NAME: &'static str = "MoneroTransferDetails";

        fn is_initialized(&self) -> bool {
            if self.out_key.is_none() {
                return false;
            }
            if self.tx_pub_key.is_none() {
                return false;
            }
            if self.internal_output_index.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.out_key = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    18 => {
                        self.tx_pub_key = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    26 => {
                        self.additional_tx_pub_keys.push(is.read_bytes()?);
                    },
                    32 => {
                        self.internal_output_index = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    40 => {
                        self.sub_addr_major = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.sub_addr_minor = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.out_key.as_ref() {
                my_size += ::protobuf::rt::bytes_size(1, &v);
            }
            if let Some(v) = self.tx_pub_key.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            for value in &self.additional_tx_pub_keys {
                my_size += ::protobuf::rt::bytes_size(3, &value);
            };
            if let Some(v) = self.internal_output_index {
                my_size += ::protobuf::rt::uint64_size(4, v);
            }
            if let Some(v) = self.sub_addr_major {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.sub_addr_minor {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.out_key.as_ref() {
                os.write_bytes(1, v)?;
            }
            if let Some(v) = self.tx_pub_key.as_ref() {
                os.write_bytes(2, v)?;
            }
            for v in &self.additional_tx_pub_keys {
                os.write_bytes(3, &v)?;
            };
            if let Some(v) = self.internal_output_index {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.sub_addr_major {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.sub_addr_minor {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MoneroTransferDetails {
            MoneroTransferDetails::new()
        }

        fn clear(&mut self) {
            self.out_key = ::std::option::Option::None;
            self.tx_pub_key = ::std::option::Option::None;
            self.additional_tx_pub_keys.clear();
            self.internal_output_index = ::std::option::Option::None;
            self.sub_addr_major = ::std::option::Option::None;
            self.sub_addr_minor = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MoneroTransferDetails {
            static instance: MoneroTransferDetails = MoneroTransferDetails {
                out_key: ::std::option::Option::None,
                tx_pub_key: ::std::option::Option::None,
                additional_tx_pub_keys: ::std::vec::Vec::new(),
                internal_output_index: ::std::option::Option::None,
                sub_addr_major: ::std::option::Option::None,
                sub_addr_minor: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MoneroTransferDetails {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MoneroKeyImageSyncStepRequest.MoneroTransferDetails").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MoneroTransferDetails {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MoneroTransferDetails {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck)
pub struct MoneroKeyImageSyncStepAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.kis)
    pub kis: ::std::vec::Vec<monero_key_image_sync_step_ack::MoneroExportedKeyImage>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageSyncStepAck {
    fn default() -> &'a MoneroKeyImageSyncStepAck {
        <MoneroKeyImageSyncStepAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageSyncStepAck {
    pub fn new() -> MoneroKeyImageSyncStepAck {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "kis",
            |m: &MoneroKeyImageSyncStepAck| { &m.kis },
            |m: &mut MoneroKeyImageSyncStepAck| { &mut m.kis },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroKeyImageSyncStepAck>(
            "MoneroKeyImageSyncStepAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroKeyImageSyncStepAck {
    const NAME: &'static str = "MoneroKeyImageSyncStepAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.kis.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.kis {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.kis {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroKeyImageSyncStepAck {
        MoneroKeyImageSyncStepAck::new()
    }

    fn clear(&mut self) {
        self.kis.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroKeyImageSyncStepAck {
        static instance: MoneroKeyImageSyncStepAck = MoneroKeyImageSyncStepAck {
            kis: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroKeyImageSyncStepAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroKeyImageSyncStepAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroKeyImageSyncStepAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageSyncStepAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MoneroKeyImageSyncStepAck`
pub mod monero_key_image_sync_step_ack {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage)
    pub struct MoneroExportedKeyImage {
        // message fields
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.iv)
        pub iv: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.blob)
        pub blob: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MoneroExportedKeyImage {
        fn default() -> &'a MoneroExportedKeyImage {
            <MoneroExportedKeyImage as ::protobuf::Message>::default_instance()
        }
    }

    impl MoneroExportedKeyImage {
        pub fn new() -> MoneroExportedKeyImage {
            ::std::default::Default::default()
        }

        // optional bytes iv = 1;

        pub fn iv(&self) -> &[u8] {
            match self.iv.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_iv(&mut self) {
            self.iv = ::std::option::Option::None;
        }

        pub fn has_iv(&self) -> bool {
            self.iv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_iv(&mut self, v: ::std::vec::Vec<u8>) {
            self.iv = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_iv(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.iv.is_none() {
                self.iv = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.iv.as_mut().unwrap()
        }

        // Take field
        pub fn take_iv(&mut self) -> ::std::vec::Vec<u8> {
            self.iv.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes blob = 3;

        pub fn blob(&self) -> &[u8] {
            match self.blob.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_blob(&mut self) {
            self.blob = ::std::option::Option::None;
        }

        pub fn has_blob(&self) -> bool {
            self.blob.is_some()
        }

        // Param is passed by value, moved
        pub fn set_blob(&mut self, v: ::std::vec::Vec<u8>) {
            self.blob = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_blob(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.blob.is_none() {
                self.blob = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.blob.as_mut().unwrap()
        }

        // Take field
        pub fn take_blob(&mut self) -> ::std::vec::Vec<u8> {
            self.blob.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "iv",
                |m: &MoneroExportedKeyImage| { &m.iv },
                |m: &mut MoneroExportedKeyImage| { &mut m.iv },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "blob",
                |m: &MoneroExportedKeyImage| { &m.blob },
                |m: &mut MoneroExportedKeyImage| { &mut m.blob },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroExportedKeyImage>(
                "MoneroKeyImageSyncStepAck.MoneroExportedKeyImage",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MoneroExportedKeyImage {
        const NAME: &'static str = "MoneroExportedKeyImage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.iv = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    26 => {
                        self.blob = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.iv.as_ref() {
                my_size += ::protobuf::rt::bytes_size(1, &v);
            }
            if let Some(v) = self.blob.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.iv.as_ref() {
                os.write_bytes(1, v)?;
            }
            if let Some(v) = self.blob.as_ref() {
                os.write_bytes(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MoneroExportedKeyImage {
            MoneroExportedKeyImage::new()
        }

        fn clear(&mut self) {
            self.iv = ::std::option::Option::None;
            self.blob = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MoneroExportedKeyImage {
            static instance: MoneroExportedKeyImage = MoneroExportedKeyImage {
                iv: ::std::option::Option::None,
                blob: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MoneroExportedKeyImage {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MoneroKeyImageSyncStepAck.MoneroExportedKeyImage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MoneroExportedKeyImage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MoneroExportedKeyImage {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroKeyImageSyncFinalRequest)
pub struct MoneroKeyImageSyncFinalRequest {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroKeyImageSyncFinalRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageSyncFinalRequest {
    fn default() -> &'a MoneroKeyImageSyncFinalRequest {
        <MoneroKeyImageSyncFinalRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageSyncFinalRequest {
    pub fn new() -> MoneroKeyImageSyncFinalRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroKeyImageSyncFinalRequest>(
            "MoneroKeyImageSyncFinalRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroKeyImageSyncFinalRequest {
    const NAME: &'static str = "MoneroKeyImageSyncFinalRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroKeyImageSyncFinalRequest {
        MoneroKeyImageSyncFinalRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroKeyImageSyncFinalRequest {
        static instance: MoneroKeyImageSyncFinalRequest = MoneroKeyImageSyncFinalRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroKeyImageSyncFinalRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroKeyImageSyncFinalRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroKeyImageSyncFinalRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageSyncFinalRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck)
pub struct MoneroKeyImageSyncFinalAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck.enc_key)
    pub enc_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageSyncFinalAck {
    fn default() -> &'a MoneroKeyImageSyncFinalAck {
        <MoneroKeyImageSyncFinalAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageSyncFinalAck {
    pub fn new() -> MoneroKeyImageSyncFinalAck {
        ::std::default::Default::default()
    }

    // optional bytes enc_key = 1;

    pub fn enc_key(&self) -> &[u8] {
        match self.enc_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_enc_key(&mut self) {
        self.enc_key = ::std::option::Option::None;
    }

    pub fn has_enc_key(&self) -> bool {
        self.enc_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enc_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.enc_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_enc_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.enc_key.is_none() {
            self.enc_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.enc_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_enc_key(&mut self) -> ::std::vec::Vec<u8> {
        self.enc_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enc_key",
            |m: &MoneroKeyImageSyncFinalAck| { &m.enc_key },
            |m: &mut MoneroKeyImageSyncFinalAck| { &mut m.enc_key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroKeyImageSyncFinalAck>(
            "MoneroKeyImageSyncFinalAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroKeyImageSyncFinalAck {
    const NAME: &'static str = "MoneroKeyImageSyncFinalAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.enc_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.enc_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.enc_key.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroKeyImageSyncFinalAck {
        MoneroKeyImageSyncFinalAck::new()
    }

    fn clear(&mut self) {
        self.enc_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroKeyImageSyncFinalAck {
        static instance: MoneroKeyImageSyncFinalAck = MoneroKeyImageSyncFinalAck {
            enc_key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroKeyImageSyncFinalAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroKeyImageSyncFinalAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroKeyImageSyncFinalAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageSyncFinalAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroGetTxKeyRequest)
pub struct MoneroGetTxKeyRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetTxKeyRequest.address_n)
    pub address_n: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetTxKeyRequest.network_type)
    pub network_type: ::std::option::Option<::protobuf::EnumOrUnknown<MoneroNetworkType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt1)
    pub salt1: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt2)
    pub salt2: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_enc_keys)
    pub tx_enc_keys: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_prefix_hash)
    pub tx_prefix_hash: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetTxKeyRequest.reason)
    pub reason: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetTxKeyRequest.view_public_key)
    pub view_public_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroGetTxKeyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroGetTxKeyRequest {
    fn default() -> &'a MoneroGetTxKeyRequest {
        <MoneroGetTxKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroGetTxKeyRequest {
    pub fn new() -> MoneroGetTxKeyRequest {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 2;

    pub fn network_type(&self) -> MoneroNetworkType {
        match self.network_type {
            Some(e) => e.enum_value_or(MoneroNetworkType::MAINNET),
            None => MoneroNetworkType::MAINNET,
        }
    }

    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: MoneroNetworkType) {
        self.network_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required bytes salt1 = 3;

    pub fn salt1(&self) -> &[u8] {
        match self.salt1.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_salt1(&mut self) {
        self.salt1 = ::std::option::Option::None;
    }

    pub fn has_salt1(&self) -> bool {
        self.salt1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_salt1(&mut self, v: ::std::vec::Vec<u8>) {
        self.salt1 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_salt1(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.salt1.is_none() {
            self.salt1 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.salt1.as_mut().unwrap()
    }

    // Take field
    pub fn take_salt1(&mut self) -> ::std::vec::Vec<u8> {
        self.salt1.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes salt2 = 4;

    pub fn salt2(&self) -> &[u8] {
        match self.salt2.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_salt2(&mut self) {
        self.salt2 = ::std::option::Option::None;
    }

    pub fn has_salt2(&self) -> bool {
        self.salt2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_salt2(&mut self, v: ::std::vec::Vec<u8>) {
        self.salt2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_salt2(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.salt2.is_none() {
            self.salt2 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.salt2.as_mut().unwrap()
    }

    // Take field
    pub fn take_salt2(&mut self) -> ::std::vec::Vec<u8> {
        self.salt2.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes tx_enc_keys = 5;

    pub fn tx_enc_keys(&self) -> &[u8] {
        match self.tx_enc_keys.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_tx_enc_keys(&mut self) {
        self.tx_enc_keys = ::std::option::Option::None;
    }

    pub fn has_tx_enc_keys(&self) -> bool {
        self.tx_enc_keys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_enc_keys(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_enc_keys = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_enc_keys(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tx_enc_keys.is_none() {
            self.tx_enc_keys = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.tx_enc_keys.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_enc_keys(&mut self) -> ::std::vec::Vec<u8> {
        self.tx_enc_keys.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes tx_prefix_hash = 6;

    pub fn tx_prefix_hash(&self) -> &[u8] {
        match self.tx_prefix_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_tx_prefix_hash(&mut self) {
        self.tx_prefix_hash = ::std::option::Option::None;
    }

    pub fn has_tx_prefix_hash(&self) -> bool {
        self.tx_prefix_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_prefix_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_prefix_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_prefix_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tx_prefix_hash.is_none() {
            self.tx_prefix_hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.tx_prefix_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_prefix_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.tx_prefix_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 reason = 7;

    pub fn reason(&self) -> u32 {
        self.reason.unwrap_or(0)
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: u32) {
        self.reason = ::std::option::Option::Some(v);
    }

    // optional bytes view_public_key = 8;

    pub fn view_public_key(&self) -> &[u8] {
        match self.view_public_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_view_public_key(&mut self) {
        self.view_public_key = ::std::option::Option::None;
    }

    pub fn has_view_public_key(&self) -> bool {
        self.view_public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.view_public_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_view_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.view_public_key.is_none() {
            self.view_public_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.view_public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_view_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.view_public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "address_n",
            |m: &MoneroGetTxKeyRequest| { &m.address_n },
            |m: &mut MoneroGetTxKeyRequest| { &mut m.address_n },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_type",
            |m: &MoneroGetTxKeyRequest| { &m.network_type },
            |m: &mut MoneroGetTxKeyRequest| { &mut m.network_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "salt1",
            |m: &MoneroGetTxKeyRequest| { &m.salt1 },
            |m: &mut MoneroGetTxKeyRequest| { &mut m.salt1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "salt2",
            |m: &MoneroGetTxKeyRequest| { &m.salt2 },
            |m: &mut MoneroGetTxKeyRequest| { &mut m.salt2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tx_enc_keys",
            |m: &MoneroGetTxKeyRequest| { &m.tx_enc_keys },
            |m: &mut MoneroGetTxKeyRequest| { &mut m.tx_enc_keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tx_prefix_hash",
            |m: &MoneroGetTxKeyRequest| { &m.tx_prefix_hash },
            |m: &mut MoneroGetTxKeyRequest| { &mut m.tx_prefix_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &MoneroGetTxKeyRequest| { &m.reason },
            |m: &mut MoneroGetTxKeyRequest| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "view_public_key",
            |m: &MoneroGetTxKeyRequest| { &m.view_public_key },
            |m: &mut MoneroGetTxKeyRequest| { &mut m.view_public_key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroGetTxKeyRequest>(
            "MoneroGetTxKeyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroGetTxKeyRequest {
    const NAME: &'static str = "MoneroGetTxKeyRequest";

    fn is_initialized(&self) -> bool {
        if self.salt1.is_none() {
            return false;
        }
        if self.salt2.is_none() {
            return false;
        }
        if self.tx_enc_keys.is_none() {
            return false;
        }
        if self.tx_prefix_hash.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.address_n)?;
                },
                8 => {
                    self.address_n.push(is.read_uint32()?);
                },
                16 => {
                    self.network_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.salt1 = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.salt2 = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.tx_enc_keys = ::std::option::Option::Some(is.read_bytes()?);
                },
                50 => {
                    self.tx_prefix_hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                56 => {
                    self.reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.view_public_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.salt1.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.salt2.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.tx_enc_keys.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.tx_prefix_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.view_public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.network_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.salt1.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.salt2.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.tx_enc_keys.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.tx_prefix_hash.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.reason {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.view_public_key.as_ref() {
            os.write_bytes(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroGetTxKeyRequest {
        MoneroGetTxKeyRequest::new()
    }

    fn clear(&mut self) {
        self.address_n.clear();
        self.network_type = ::std::option::Option::None;
        self.salt1 = ::std::option::Option::None;
        self.salt2 = ::std::option::Option::None;
        self.tx_enc_keys = ::std::option::Option::None;
        self.tx_prefix_hash = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.view_public_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroGetTxKeyRequest {
        static instance: MoneroGetTxKeyRequest = MoneroGetTxKeyRequest {
            address_n: ::std::vec::Vec::new(),
            network_type: ::std::option::Option::None,
            salt1: ::std::option::Option::None,
            salt2: ::std::option::Option::None,
            tx_enc_keys: ::std::option::Option::None,
            tx_prefix_hash: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            view_public_key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroGetTxKeyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroGetTxKeyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroGetTxKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroGetTxKeyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroGetTxKeyAck)
pub struct MoneroGetTxKeyAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetTxKeyAck.salt)
    pub salt: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_keys)
    pub tx_keys: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_derivations)
    pub tx_derivations: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroGetTxKeyAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroGetTxKeyAck {
    fn default() -> &'a MoneroGetTxKeyAck {
        <MoneroGetTxKeyAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroGetTxKeyAck {
    pub fn new() -> MoneroGetTxKeyAck {
        ::std::default::Default::default()
    }

    // optional bytes salt = 1;

    pub fn salt(&self) -> &[u8] {
        match self.salt.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_salt(&mut self) {
        self.salt = ::std::option::Option::None;
    }

    pub fn has_salt(&self) -> bool {
        self.salt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_salt(&mut self, v: ::std::vec::Vec<u8>) {
        self.salt = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_salt(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.salt.is_none() {
            self.salt = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.salt.as_mut().unwrap()
    }

    // Take field
    pub fn take_salt(&mut self) -> ::std::vec::Vec<u8> {
        self.salt.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes tx_keys = 2;

    pub fn tx_keys(&self) -> &[u8] {
        match self.tx_keys.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_tx_keys(&mut self) {
        self.tx_keys = ::std::option::Option::None;
    }

    pub fn has_tx_keys(&self) -> bool {
        self.tx_keys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_keys(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_keys = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_keys(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tx_keys.is_none() {
            self.tx_keys = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.tx_keys.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_keys(&mut self) -> ::std::vec::Vec<u8> {
        self.tx_keys.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes tx_derivations = 3;

    pub fn tx_derivations(&self) -> &[u8] {
        match self.tx_derivations.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_tx_derivations(&mut self) {
        self.tx_derivations = ::std::option::Option::None;
    }

    pub fn has_tx_derivations(&self) -> bool {
        self.tx_derivations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_derivations(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_derivations = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_derivations(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tx_derivations.is_none() {
            self.tx_derivations = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.tx_derivations.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_derivations(&mut self) -> ::std::vec::Vec<u8> {
        self.tx_derivations.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "salt",
            |m: &MoneroGetTxKeyAck| { &m.salt },
            |m: &mut MoneroGetTxKeyAck| { &mut m.salt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tx_keys",
            |m: &MoneroGetTxKeyAck| { &m.tx_keys },
            |m: &mut MoneroGetTxKeyAck| { &mut m.tx_keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tx_derivations",
            |m: &MoneroGetTxKeyAck| { &m.tx_derivations },
            |m: &mut MoneroGetTxKeyAck| { &mut m.tx_derivations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroGetTxKeyAck>(
            "MoneroGetTxKeyAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroGetTxKeyAck {
    const NAME: &'static str = "MoneroGetTxKeyAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.salt = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.tx_keys = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.tx_derivations = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.salt.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.tx_keys.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.tx_derivations.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.salt.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.tx_keys.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.tx_derivations.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroGetTxKeyAck {
        MoneroGetTxKeyAck::new()
    }

    fn clear(&mut self) {
        self.salt = ::std::option::Option::None;
        self.tx_keys = ::std::option::Option::None;
        self.tx_derivations = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroGetTxKeyAck {
        static instance: MoneroGetTxKeyAck = MoneroGetTxKeyAck {
            salt: ::std::option::Option::None,
            tx_keys: ::std::option::Option::None,
            tx_derivations: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroGetTxKeyAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroGetTxKeyAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroGetTxKeyAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroGetTxKeyAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest)
pub struct MoneroLiveRefreshStartRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest.address_n)
    pub address_n: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest.network_type)
    pub network_type: ::std::option::Option<::protobuf::EnumOrUnknown<MoneroNetworkType>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroLiveRefreshStartRequest {
    fn default() -> &'a MoneroLiveRefreshStartRequest {
        <MoneroLiveRefreshStartRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroLiveRefreshStartRequest {
    pub fn new() -> MoneroLiveRefreshStartRequest {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 2;

    pub fn network_type(&self) -> MoneroNetworkType {
        match self.network_type {
            Some(e) => e.enum_value_or(MoneroNetworkType::MAINNET),
            None => MoneroNetworkType::MAINNET,
        }
    }

    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: MoneroNetworkType) {
        self.network_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "address_n",
            |m: &MoneroLiveRefreshStartRequest| { &m.address_n },
            |m: &mut MoneroLiveRefreshStartRequest| { &mut m.address_n },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_type",
            |m: &MoneroLiveRefreshStartRequest| { &m.network_type },
            |m: &mut MoneroLiveRefreshStartRequest| { &mut m.network_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroLiveRefreshStartRequest>(
            "MoneroLiveRefreshStartRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroLiveRefreshStartRequest {
    const NAME: &'static str = "MoneroLiveRefreshStartRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.address_n)?;
                },
                8 => {
                    self.address_n.push(is.read_uint32()?);
                },
                16 => {
                    self.network_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.network_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroLiveRefreshStartRequest {
        MoneroLiveRefreshStartRequest::new()
    }

    fn clear(&mut self) {
        self.address_n.clear();
        self.network_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroLiveRefreshStartRequest {
        static instance: MoneroLiveRefreshStartRequest = MoneroLiveRefreshStartRequest {
            address_n: ::std::vec::Vec::new(),
            network_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroLiveRefreshStartRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroLiveRefreshStartRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroLiveRefreshStartRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroLiveRefreshStartRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroLiveRefreshStartAck)
pub struct MoneroLiveRefreshStartAck {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroLiveRefreshStartAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroLiveRefreshStartAck {
    fn default() -> &'a MoneroLiveRefreshStartAck {
        <MoneroLiveRefreshStartAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroLiveRefreshStartAck {
    pub fn new() -> MoneroLiveRefreshStartAck {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroLiveRefreshStartAck>(
            "MoneroLiveRefreshStartAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroLiveRefreshStartAck {
    const NAME: &'static str = "MoneroLiveRefreshStartAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroLiveRefreshStartAck {
        MoneroLiveRefreshStartAck::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroLiveRefreshStartAck {
        static instance: MoneroLiveRefreshStartAck = MoneroLiveRefreshStartAck {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroLiveRefreshStartAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroLiveRefreshStartAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroLiveRefreshStartAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroLiveRefreshStartAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest)
pub struct MoneroLiveRefreshStepRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.out_key)
    pub out_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.recv_deriv)
    pub recv_deriv: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.real_out_idx)
    pub real_out_idx: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.sub_addr_major)
    pub sub_addr_major: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.sub_addr_minor)
    pub sub_addr_minor: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroLiveRefreshStepRequest {
    fn default() -> &'a MoneroLiveRefreshStepRequest {
        <MoneroLiveRefreshStepRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroLiveRefreshStepRequest {
    pub fn new() -> MoneroLiveRefreshStepRequest {
        ::std::default::Default::default()
    }

    // required bytes out_key = 1;

    pub fn out_key(&self) -> &[u8] {
        match self.out_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_out_key(&mut self) {
        self.out_key = ::std::option::Option::None;
    }

    pub fn has_out_key(&self) -> bool {
        self.out_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_out_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.out_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.out_key.is_none() {
            self.out_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.out_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_out_key(&mut self) -> ::std::vec::Vec<u8> {
        self.out_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes recv_deriv = 2;

    pub fn recv_deriv(&self) -> &[u8] {
        match self.recv_deriv.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_recv_deriv(&mut self) {
        self.recv_deriv = ::std::option::Option::None;
    }

    pub fn has_recv_deriv(&self) -> bool {
        self.recv_deriv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recv_deriv(&mut self, v: ::std::vec::Vec<u8>) {
        self.recv_deriv = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recv_deriv(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.recv_deriv.is_none() {
            self.recv_deriv = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.recv_deriv.as_mut().unwrap()
    }

    // Take field
    pub fn take_recv_deriv(&mut self) -> ::std::vec::Vec<u8> {
        self.recv_deriv.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint64 real_out_idx = 3;

    pub fn real_out_idx(&self) -> u64 {
        self.real_out_idx.unwrap_or(0)
    }

    pub fn clear_real_out_idx(&mut self) {
        self.real_out_idx = ::std::option::Option::None;
    }

    pub fn has_real_out_idx(&self) -> bool {
        self.real_out_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_real_out_idx(&mut self, v: u64) {
        self.real_out_idx = ::std::option::Option::Some(v);
    }

    // required uint32 sub_addr_major = 4;

    pub fn sub_addr_major(&self) -> u32 {
        self.sub_addr_major.unwrap_or(0)
    }

    pub fn clear_sub_addr_major(&mut self) {
        self.sub_addr_major = ::std::option::Option::None;
    }

    pub fn has_sub_addr_major(&self) -> bool {
        self.sub_addr_major.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sub_addr_major(&mut self, v: u32) {
        self.sub_addr_major = ::std::option::Option::Some(v);
    }

    // required uint32 sub_addr_minor = 5;

    pub fn sub_addr_minor(&self) -> u32 {
        self.sub_addr_minor.unwrap_or(0)
    }

    pub fn clear_sub_addr_minor(&mut self) {
        self.sub_addr_minor = ::std::option::Option::None;
    }

    pub fn has_sub_addr_minor(&self) -> bool {
        self.sub_addr_minor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sub_addr_minor(&mut self, v: u32) {
        self.sub_addr_minor = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "out_key",
            |m: &MoneroLiveRefreshStepRequest| { &m.out_key },
            |m: &mut MoneroLiveRefreshStepRequest| { &mut m.out_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recv_deriv",
            |m: &MoneroLiveRefreshStepRequest| { &m.recv_deriv },
            |m: &mut MoneroLiveRefreshStepRequest| { &mut m.recv_deriv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "real_out_idx",
            |m: &MoneroLiveRefreshStepRequest| { &m.real_out_idx },
            |m: &mut MoneroLiveRefreshStepRequest| { &mut m.real_out_idx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sub_addr_major",
            |m: &MoneroLiveRefreshStepRequest| { &m.sub_addr_major },
            |m: &mut MoneroLiveRefreshStepRequest| { &mut m.sub_addr_major },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sub_addr_minor",
            |m: &MoneroLiveRefreshStepRequest| { &m.sub_addr_minor },
            |m: &mut MoneroLiveRefreshStepRequest| { &mut m.sub_addr_minor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroLiveRefreshStepRequest>(
            "MoneroLiveRefreshStepRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroLiveRefreshStepRequest {
    const NAME: &'static str = "MoneroLiveRefreshStepRequest";

    fn is_initialized(&self) -> bool {
        if self.out_key.is_none() {
            return false;
        }
        if self.recv_deriv.is_none() {
            return false;
        }
        if self.real_out_idx.is_none() {
            return false;
        }
        if self.sub_addr_major.is_none() {
            return false;
        }
        if self.sub_addr_minor.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.out_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.recv_deriv = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.real_out_idx = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.sub_addr_major = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.sub_addr_minor = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.out_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.recv_deriv.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.real_out_idx {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.sub_addr_major {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.sub_addr_minor {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.out_key.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.recv_deriv.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.real_out_idx {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.sub_addr_major {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.sub_addr_minor {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroLiveRefreshStepRequest {
        MoneroLiveRefreshStepRequest::new()
    }

    fn clear(&mut self) {
        self.out_key = ::std::option::Option::None;
        self.recv_deriv = ::std::option::Option::None;
        self.real_out_idx = ::std::option::Option::None;
        self.sub_addr_major = ::std::option::Option::None;
        self.sub_addr_minor = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroLiveRefreshStepRequest {
        static instance: MoneroLiveRefreshStepRequest = MoneroLiveRefreshStepRequest {
            out_key: ::std::option::Option::None,
            recv_deriv: ::std::option::Option::None,
            real_out_idx: ::std::option::Option::None,
            sub_addr_major: ::std::option::Option::None,
            sub_addr_minor: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroLiveRefreshStepRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroLiveRefreshStepRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroLiveRefreshStepRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroLiveRefreshStepRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroLiveRefreshStepAck)
pub struct MoneroLiveRefreshStepAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.salt)
    pub salt: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.key_image)
    pub key_image: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroLiveRefreshStepAck {
    fn default() -> &'a MoneroLiveRefreshStepAck {
        <MoneroLiveRefreshStepAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroLiveRefreshStepAck {
    pub fn new() -> MoneroLiveRefreshStepAck {
        ::std::default::Default::default()
    }

    // optional bytes salt = 1;

    pub fn salt(&self) -> &[u8] {
        match self.salt.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_salt(&mut self) {
        self.salt = ::std::option::Option::None;
    }

    pub fn has_salt(&self) -> bool {
        self.salt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_salt(&mut self, v: ::std::vec::Vec<u8>) {
        self.salt = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_salt(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.salt.is_none() {
            self.salt = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.salt.as_mut().unwrap()
    }

    // Take field
    pub fn take_salt(&mut self) -> ::std::vec::Vec<u8> {
        self.salt.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes key_image = 2;

    pub fn key_image(&self) -> &[u8] {
        match self.key_image.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_key_image(&mut self) {
        self.key_image = ::std::option::Option::None;
    }

    pub fn has_key_image(&self) -> bool {
        self.key_image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_image(&mut self, v: ::std::vec::Vec<u8>) {
        self.key_image = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_image(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key_image.is_none() {
            self.key_image = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.key_image.as_mut().unwrap()
    }

    // Take field
    pub fn take_key_image(&mut self) -> ::std::vec::Vec<u8> {
        self.key_image.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "salt",
            |m: &MoneroLiveRefreshStepAck| { &m.salt },
            |m: &mut MoneroLiveRefreshStepAck| { &mut m.salt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key_image",
            |m: &MoneroLiveRefreshStepAck| { &m.key_image },
            |m: &mut MoneroLiveRefreshStepAck| { &mut m.key_image },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroLiveRefreshStepAck>(
            "MoneroLiveRefreshStepAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroLiveRefreshStepAck {
    const NAME: &'static str = "MoneroLiveRefreshStepAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.salt = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.key_image = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.salt.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.key_image.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.salt.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.key_image.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroLiveRefreshStepAck {
        MoneroLiveRefreshStepAck::new()
    }

    fn clear(&mut self) {
        self.salt = ::std::option::Option::None;
        self.key_image = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroLiveRefreshStepAck {
        static instance: MoneroLiveRefreshStepAck = MoneroLiveRefreshStepAck {
            salt: ::std::option::Option::None,
            key_image: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroLiveRefreshStepAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroLiveRefreshStepAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroLiveRefreshStepAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroLiveRefreshStepAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroLiveRefreshFinalRequest)
pub struct MoneroLiveRefreshFinalRequest {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroLiveRefreshFinalRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroLiveRefreshFinalRequest {
    fn default() -> &'a MoneroLiveRefreshFinalRequest {
        <MoneroLiveRefreshFinalRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroLiveRefreshFinalRequest {
    pub fn new() -> MoneroLiveRefreshFinalRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroLiveRefreshFinalRequest>(
            "MoneroLiveRefreshFinalRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroLiveRefreshFinalRequest {
    const NAME: &'static str = "MoneroLiveRefreshFinalRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroLiveRefreshFinalRequest {
        MoneroLiveRefreshFinalRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroLiveRefreshFinalRequest {
        static instance: MoneroLiveRefreshFinalRequest = MoneroLiveRefreshFinalRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroLiveRefreshFinalRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroLiveRefreshFinalRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroLiveRefreshFinalRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroLiveRefreshFinalRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.MoneroLiveRefreshFinalAck)
pub struct MoneroLiveRefreshFinalAck {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.MoneroLiveRefreshFinalAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoneroLiveRefreshFinalAck {
    fn default() -> &'a MoneroLiveRefreshFinalAck {
        <MoneroLiveRefreshFinalAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroLiveRefreshFinalAck {
    pub fn new() -> MoneroLiveRefreshFinalAck {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoneroLiveRefreshFinalAck>(
            "MoneroLiveRefreshFinalAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoneroLiveRefreshFinalAck {
    const NAME: &'static str = "MoneroLiveRefreshFinalAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoneroLiveRefreshFinalAck {
        MoneroLiveRefreshFinalAck::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoneroLiveRefreshFinalAck {
        static instance: MoneroLiveRefreshFinalAck = MoneroLiveRefreshFinalAck {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoneroLiveRefreshFinalAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoneroLiveRefreshFinalAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoneroLiveRefreshFinalAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroLiveRefreshFinalAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.DebugMoneroDiagRequest)
pub struct DebugMoneroDiagRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.DebugMoneroDiagRequest.ins)
    pub ins: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.DebugMoneroDiagRequest.p1)
    pub p1: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.DebugMoneroDiagRequest.p2)
    pub p2: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.DebugMoneroDiagRequest.pd)
    pub pd: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.DebugMoneroDiagRequest.data1)
    pub data1: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.DebugMoneroDiagRequest.data2)
    pub data2: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.DebugMoneroDiagRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DebugMoneroDiagRequest {
    fn default() -> &'a DebugMoneroDiagRequest {
        <DebugMoneroDiagRequest as ::protobuf::Message>::default_instance()
    }
}

impl DebugMoneroDiagRequest {
    pub fn new() -> DebugMoneroDiagRequest {
        ::std::default::Default::default()
    }

    // optional uint64 ins = 1;

    pub fn ins(&self) -> u64 {
        self.ins.unwrap_or(0)
    }

    pub fn clear_ins(&mut self) {
        self.ins = ::std::option::Option::None;
    }

    pub fn has_ins(&self) -> bool {
        self.ins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ins(&mut self, v: u64) {
        self.ins = ::std::option::Option::Some(v);
    }

    // optional uint64 p1 = 2;

    pub fn p1(&self) -> u64 {
        self.p1.unwrap_or(0)
    }

    pub fn clear_p1(&mut self) {
        self.p1 = ::std::option::Option::None;
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: u64) {
        self.p1 = ::std::option::Option::Some(v);
    }

    // optional uint64 p2 = 3;

    pub fn p2(&self) -> u64 {
        self.p2.unwrap_or(0)
    }

    pub fn clear_p2(&mut self) {
        self.p2 = ::std::option::Option::None;
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: u64) {
        self.p2 = ::std::option::Option::Some(v);
    }

    // optional bytes data1 = 5;

    pub fn data1(&self) -> &[u8] {
        match self.data1.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data1(&mut self) {
        self.data1 = ::std::option::Option::None;
    }

    pub fn has_data1(&self) -> bool {
        self.data1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data1(&mut self, v: ::std::vec::Vec<u8>) {
        self.data1 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data1(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data1.is_none() {
            self.data1 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data1.as_mut().unwrap()
    }

    // Take field
    pub fn take_data1(&mut self) -> ::std::vec::Vec<u8> {
        self.data1.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes data2 = 6;

    pub fn data2(&self) -> &[u8] {
        match self.data2.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data2(&mut self) {
        self.data2 = ::std::option::Option::None;
    }

    pub fn has_data2(&self) -> bool {
        self.data2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data2(&mut self, v: ::std::vec::Vec<u8>) {
        self.data2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data2(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data2.is_none() {
            self.data2 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data2.as_mut().unwrap()
    }

    // Take field
    pub fn take_data2(&mut self) -> ::std::vec::Vec<u8> {
        self.data2.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ins",
            |m: &DebugMoneroDiagRequest| { &m.ins },
            |m: &mut DebugMoneroDiagRequest| { &mut m.ins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "p1",
            |m: &DebugMoneroDiagRequest| { &m.p1 },
            |m: &mut DebugMoneroDiagRequest| { &mut m.p1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "p2",
            |m: &DebugMoneroDiagRequest| { &m.p2 },
            |m: &mut DebugMoneroDiagRequest| { &mut m.p2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pd",
            |m: &DebugMoneroDiagRequest| { &m.pd },
            |m: &mut DebugMoneroDiagRequest| { &mut m.pd },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data1",
            |m: &DebugMoneroDiagRequest| { &m.data1 },
            |m: &mut DebugMoneroDiagRequest| { &mut m.data1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data2",
            |m: &DebugMoneroDiagRequest| { &m.data2 },
            |m: &mut DebugMoneroDiagRequest| { &mut m.data2 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DebugMoneroDiagRequest>(
            "DebugMoneroDiagRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DebugMoneroDiagRequest {
    const NAME: &'static str = "DebugMoneroDiagRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ins = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.p1 = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.p2 = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    is.read_repeated_packed_uint64_into(&mut self.pd)?;
                },
                32 => {
                    self.pd.push(is.read_uint64()?);
                },
                42 => {
                    self.data1 = ::std::option::Option::Some(is.read_bytes()?);
                },
                50 => {
                    self.data2 = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ins {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.p1 {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.p2 {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        for value in &self.pd {
            my_size += ::protobuf::rt::uint64_size(4, *value);
        };
        if let Some(v) = self.data1.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.data2.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ins {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.p1 {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.p2 {
            os.write_uint64(3, v)?;
        }
        for v in &self.pd {
            os.write_uint64(4, *v)?;
        };
        if let Some(v) = self.data1.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.data2.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DebugMoneroDiagRequest {
        DebugMoneroDiagRequest::new()
    }

    fn clear(&mut self) {
        self.ins = ::std::option::Option::None;
        self.p1 = ::std::option::Option::None;
        self.p2 = ::std::option::Option::None;
        self.pd.clear();
        self.data1 = ::std::option::Option::None;
        self.data2 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DebugMoneroDiagRequest {
        static instance: DebugMoneroDiagRequest = DebugMoneroDiagRequest {
            ins: ::std::option::Option::None,
            p1: ::std::option::Option::None,
            p2: ::std::option::Option::None,
            pd: ::std::vec::Vec::new(),
            data1: ::std::option::Option::None,
            data2: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DebugMoneroDiagRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DebugMoneroDiagRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DebugMoneroDiagRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugMoneroDiagRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.monero.DebugMoneroDiagAck)
pub struct DebugMoneroDiagAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.DebugMoneroDiagAck.ins)
    pub ins: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.DebugMoneroDiagAck.p1)
    pub p1: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.DebugMoneroDiagAck.p2)
    pub p2: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.DebugMoneroDiagAck.pd)
    pub pd: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.DebugMoneroDiagAck.data1)
    pub data1: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.monero.DebugMoneroDiagAck.data2)
    pub data2: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.monero.DebugMoneroDiagAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DebugMoneroDiagAck {
    fn default() -> &'a DebugMoneroDiagAck {
        <DebugMoneroDiagAck as ::protobuf::Message>::default_instance()
    }
}

impl DebugMoneroDiagAck {
    pub fn new() -> DebugMoneroDiagAck {
        ::std::default::Default::default()
    }

    // optional uint64 ins = 1;

    pub fn ins(&self) -> u64 {
        self.ins.unwrap_or(0)
    }

    pub fn clear_ins(&mut self) {
        self.ins = ::std::option::Option::None;
    }

    pub fn has_ins(&self) -> bool {
        self.ins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ins(&mut self, v: u64) {
        self.ins = ::std::option::Option::Some(v);
    }

    // optional uint64 p1 = 2;

    pub fn p1(&self) -> u64 {
        self.p1.unwrap_or(0)
    }

    pub fn clear_p1(&mut self) {
        self.p1 = ::std::option::Option::None;
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: u64) {
        self.p1 = ::std::option::Option::Some(v);
    }

    // optional uint64 p2 = 3;

    pub fn p2(&self) -> u64 {
        self.p2.unwrap_or(0)
    }

    pub fn clear_p2(&mut self) {
        self.p2 = ::std::option::Option::None;
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: u64) {
        self.p2 = ::std::option::Option::Some(v);
    }

    // optional bytes data1 = 5;

    pub fn data1(&self) -> &[u8] {
        match self.data1.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data1(&mut self) {
        self.data1 = ::std::option::Option::None;
    }

    pub fn has_data1(&self) -> bool {
        self.data1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data1(&mut self, v: ::std::vec::Vec<u8>) {
        self.data1 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data1(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data1.is_none() {
            self.data1 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data1.as_mut().unwrap()
    }

    // Take field
    pub fn take_data1(&mut self) -> ::std::vec::Vec<u8> {
        self.data1.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes data2 = 6;

    pub fn data2(&self) -> &[u8] {
        match self.data2.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data2(&mut self) {
        self.data2 = ::std::option::Option::None;
    }

    pub fn has_data2(&self) -> bool {
        self.data2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data2(&mut self, v: ::std::vec::Vec<u8>) {
        self.data2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data2(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data2.is_none() {
            self.data2 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data2.as_mut().unwrap()
    }

    // Take field
    pub fn take_data2(&mut self) -> ::std::vec::Vec<u8> {
        self.data2.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ins",
            |m: &DebugMoneroDiagAck| { &m.ins },
            |m: &mut DebugMoneroDiagAck| { &mut m.ins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "p1",
            |m: &DebugMoneroDiagAck| { &m.p1 },
            |m: &mut DebugMoneroDiagAck| { &mut m.p1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "p2",
            |m: &DebugMoneroDiagAck| { &m.p2 },
            |m: &mut DebugMoneroDiagAck| { &mut m.p2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pd",
            |m: &DebugMoneroDiagAck| { &m.pd },
            |m: &mut DebugMoneroDiagAck| { &mut m.pd },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data1",
            |m: &DebugMoneroDiagAck| { &m.data1 },
            |m: &mut DebugMoneroDiagAck| { &mut m.data1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data2",
            |m: &DebugMoneroDiagAck| { &m.data2 },
            |m: &mut DebugMoneroDiagAck| { &mut m.data2 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DebugMoneroDiagAck>(
            "DebugMoneroDiagAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DebugMoneroDiagAck {
    const NAME: &'static str = "DebugMoneroDiagAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ins = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.p1 = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.p2 = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    is.read_repeated_packed_uint64_into(&mut self.pd)?;
                },
                32 => {
                    self.pd.push(is.read_uint64()?);
                },
                42 => {
                    self.data1 = ::std::option::Option::Some(is.read_bytes()?);
                },
                50 => {
                    self.data2 = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ins {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.p1 {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.p2 {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        for value in &self.pd {
            my_size += ::protobuf::rt::uint64_size(4, *value);
        };
        if let Some(v) = self.data1.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.data2.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ins {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.p1 {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.p2 {
            os.write_uint64(3, v)?;
        }
        for v in &self.pd {
            os.write_uint64(4, *v)?;
        };
        if let Some(v) = self.data1.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.data2.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DebugMoneroDiagAck {
        DebugMoneroDiagAck::new()
    }

    fn clear(&mut self) {
        self.ins = ::std::option::Option::None;
        self.p1 = ::std::option::Option::None;
        self.p2 = ::std::option::Option::None;
        self.pd.clear();
        self.data1 = ::std::option::Option::None;
        self.data2 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DebugMoneroDiagAck {
        static instance: DebugMoneroDiagAck = DebugMoneroDiagAck {
            ins: ::std::option::Option::None,
            p1: ::std::option::Option::None,
            p2: ::std::option::Option::None,
            pd: ::std::vec::Vec::new(),
            data1: ::std::option::Option::None,
            data2: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DebugMoneroDiagAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DebugMoneroDiagAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DebugMoneroDiagAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugMoneroDiagAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:hw.trezor.messages.monero.MoneroNetworkType)
pub enum MoneroNetworkType {
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.monero.MoneroNetworkType.MAINNET)
    MAINNET = 0,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.monero.MoneroNetworkType.TESTNET)
    TESTNET = 1,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.monero.MoneroNetworkType.STAGENET)
    STAGENET = 2,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.monero.MoneroNetworkType.FAKECHAIN)
    FAKECHAIN = 3,
}

impl ::protobuf::Enum for MoneroNetworkType {
    const NAME: &'static str = "MoneroNetworkType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MoneroNetworkType> {
        match value {
            0 => ::std::option::Option::Some(MoneroNetworkType::MAINNET),
            1 => ::std::option::Option::Some(MoneroNetworkType::TESTNET),
            2 => ::std::option::Option::Some(MoneroNetworkType::STAGENET),
            3 => ::std::option::Option::Some(MoneroNetworkType::FAKECHAIN),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MoneroNetworkType] = &[
        MoneroNetworkType::MAINNET,
        MoneroNetworkType::TESTNET,
        MoneroNetworkType::STAGENET,
        MoneroNetworkType::FAKECHAIN,
    ];
}

impl ::protobuf::EnumFull for MoneroNetworkType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MoneroNetworkType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MoneroNetworkType {
    fn default() -> Self {
        MoneroNetworkType::MAINNET
    }
}

impl MoneroNetworkType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MoneroNetworkType>("MoneroNetworkType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15messages-monero.proto\x12\x19hw.trezor.messages.monero\"\xc9\x06\n\
    \x1cMoneroTransactionSourceEntry\x12c\n\x07outputs\x18\x01\x20\x03(\x0b2\
    I.hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEnt\
    ryR\x07outputs\x12\x1f\n\x0breal_output\x18\x02\x20\x01(\x04R\nrealOutpu\
    t\x12%\n\x0freal_out_tx_key\x18\x03\x20\x01(\x0cR\x0crealOutTxKey\x12<\n\
    \x1breal_out_additional_tx_keys\x18\x04\x20\x03(\x0cR\x17realOutAddition\
    alTxKeys\x124\n\x17real_output_in_tx_index\x18\x05\x20\x01(\x04R\x13real\
    OutputInTxIndex\x12\x16\n\x06amount\x18\x06\x20\x01(\x04R\x06amount\x12\
    \x10\n\x03rct\x18\x07\x20\x01(\x08R\x03rct\x12\x12\n\x04mask\x18\x08\x20\
    \x01(\x0cR\x04mask\x12r\n\x0emultisig_kLRki\x18\t\x20\x01(\x0b2K.hw.trez\
    or.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRkiR\rmu\
    ltisigKLRki\x12#\n\rsubaddr_minor\x18\n\x20\x01(\rR\x0csubaddrMinor\x1a\
    \xdf\x01\n\x11MoneroOutputEntry\x12\x10\n\x03idx\x18\x01\x20\x01(\x04R\
    \x03idx\x12n\n\x03key\x18\x02\x20\x01(\x0b2\\.hw.trezor.messages.monero.\
    MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublicR\x03ke\
    y\x1aH\n\x12MoneroRctKeyPublic\x12\x12\n\x04dest\x18\x01\x20\x02(\x0cR\
    \x04dest\x12\x1e\n\ncommitment\x18\x02\x20\x02(\x0cR\ncommitment\x1aO\n\
    \x13MoneroMultisigKLRki\x12\x0c\n\x01K\x18\x01\x20\x01(\x0cR\x01K\x12\
    \x0c\n\x01L\x18\x02\x20\x01(\x0cR\x01L\x12\x0c\n\x01R\x18\x03\x20\x01(\
    \x0cR\x01R\x12\x0e\n\x02ki\x18\x04\x20\x01(\x0cR\x02ki\"\xfe\x02\n!Moner\
    oTransactionDestinationEntry\x12\x16\n\x06amount\x18\x01\x20\x01(\x04R\
    \x06amount\x12k\n\x04addr\x18\x02\x20\x01(\x0b2W.hw.trezor.messages.mone\
    ro.MoneroTransactionDestinationEntry.MoneroAccountPublicAddressR\x04addr\
    \x12#\n\ris_subaddress\x18\x03\x20\x01(\x08R\x0cisSubaddress\x12\x1a\n\
    \x08original\x18\x04\x20\x01(\x0cR\x08original\x12#\n\ris_integrated\x18\
    \x05\x20\x01(\x08R\x0cisIntegrated\x1an\n\x1aMoneroAccountPublicAddress\
    \x12(\n\x10spend_public_key\x18\x01\x20\x01(\x0cR\x0espendPublicKey\x12&\
    \n\x0fview_public_key\x18\x02\x20\x01(\x0cR\rviewPublicKey\"\xdd\x01\n\
    \x19MoneroTransactionRsigData\x12\x1b\n\trsig_type\x18\x01\x20\x01(\rR\
    \x08rsigType\x12!\n\x0coffload_type\x18\x02\x20\x01(\rR\x0boffloadType\
    \x12\x1a\n\x08grouping\x18\x03\x20\x03(\x04R\x08grouping\x12\x12\n\x04ma\
    sk\x18\x04\x20\x01(\x0cR\x04mask\x12\x12\n\x04rsig\x18\x05\x20\x01(\x0cR\
    \x04rsig\x12\x1d\n\nrsig_parts\x18\x06\x20\x03(\x0cR\trsigParts\x12\x1d\
    \n\nbp_version\x18\x07\x20\x01(\rR\tbpVersion\"\x97\x02\n\x10MoneroGetAd\
    dress\x12\x1b\n\taddress_n\x18\x01\x20\x03(\rR\x08addressN\x12!\n\x0csho\
    w_display\x18\x02\x20\x01(\x08R\x0bshowDisplay\x12X\n\x0cnetwork_type\
    \x18\x03\x20\x01(\x0e2,.hw.trezor.messages.monero.MoneroNetworkType:\x07\
    MAINNETR\x0bnetworkType\x12\x18\n\x07account\x18\x04\x20\x01(\rR\x07acco\
    unt\x12\x14\n\x05minor\x18\x05\x20\x01(\rR\x05minor\x12\x1d\n\npayment_i\
    d\x18\x06\x20\x01(\x0cR\tpaymentId\x12\x1a\n\x08chunkify\x18\x07\x20\x01\
    (\x08R\x08chunkify\")\n\rMoneroAddress\x12\x18\n\x07address\x18\x01\x20\
    \x01(\x0cR\x07address\"\x8a\x01\n\x11MoneroGetWatchKey\x12\x1b\n\taddres\
    s_n\x18\x01\x20\x03(\rR\x08addressN\x12X\n\x0cnetwork_type\x18\x02\x20\
    \x01(\x0e2,.hw.trezor.messages.monero.MoneroNetworkType:\x07MAINNETR\x0b\
    networkType\"G\n\x0eMoneroWatchKey\x12\x1b\n\twatch_key\x18\x01\x20\x01(\
    \x0cR\x08watchKey\x12\x18\n\x07address\x18\x02\x20\x01(\x0cR\x07address\
    \"\xd1\x07\n\x1cMoneroTransactionInitRequest\x12\x18\n\x07version\x18\
    \x01\x20\x01(\rR\x07version\x12\x1b\n\taddress_n\x18\x02\x20\x03(\rR\x08\
    addressN\x12X\n\x0cnetwork_type\x18\x03\x20\x01(\x0e2,.hw.trezor.message\
    s.monero.MoneroNetworkType:\x07MAINNETR\x0bnetworkType\x12h\n\x08tsx_dat\
    a\x18\x04\x20\x01(\x0b2M.hw.trezor.messages.monero.MoneroTransactionInit\
    Request.MoneroTransactionDataR\x07tsxData\x1a\xb5\x05\n\x15MoneroTransac\
    tionData\x12\x18\n\x07version\x18\x01\x20\x01(\rR\x07version\x12\x1d\n\n\
    payment_id\x18\x02\x20\x01(\x0cR\tpaymentId\x12\x1f\n\x0bunlock_time\x18\
    \x03\x20\x01(\x04R\nunlockTime\x12V\n\x07outputs\x18\x04\x20\x03(\x0b2<.\
    hw.trezor.messages.monero.MoneroTransactionDestinationEntryR\x07outputs\
    \x12[\n\nchange_dts\x18\x05\x20\x01(\x0b2<.hw.trezor.messages.monero.Mon\
    eroTransactionDestinationEntryR\tchangeDts\x12\x1d\n\nnum_inputs\x18\x06\
    \x20\x01(\rR\tnumInputs\x12\x14\n\x05mixin\x18\x07\x20\x01(\rR\x05mixin\
    \x12\x10\n\x03fee\x18\x08\x20\x01(\x04R\x03fee\x12\x18\n\x07account\x18\
    \t\x20\x01(\rR\x07account\x12#\n\rminor_indices\x18\n\x20\x03(\rR\x0cmin\
    orIndices\x12Q\n\trsig_data\x18\x0b\x20\x01(\x0b24.hw.trezor.messages.mo\
    nero.MoneroTransactionRsigDataR\x08rsigData\x12-\n\x12integrated_indices\
    \x18\x0c\x20\x03(\rR\x11integratedIndices\x12%\n\x0eclient_version\x18\r\
    \x20\x01(\rR\rclientVersion\x12\x1b\n\thard_fork\x18\x0e\x20\x01(\rR\x08\
    hardFork\x12%\n\x0emonero_version\x18\x0f\x20\x01(\x0cR\rmoneroVersion\
    \x12\x1a\n\x08chunkify\x18\x10\x20\x01(\x08R\x08chunkify\"\x83\x01\n\x18\
    MoneroTransactionInitAck\x12\x14\n\x05hmacs\x18\x01\x20\x03(\x0cR\x05hma\
    cs\x12Q\n\trsig_data\x18\x02\x20\x01(\x0b24.hw.trezor.messages.monero.Mo\
    neroTransactionRsigDataR\x08rsigData\"v\n\x20MoneroTransactionSetInputRe\
    quest\x12R\n\x08src_entr\x18\x01\x20\x01(\x0b27.hw.trezor.messages.moner\
    o.MoneroTransactionSourceEntryR\x07srcEntr\"\xdd\x01\n\x1cMoneroTransact\
    ionSetInputAck\x12\x12\n\x04vini\x18\x01\x20\x01(\x0cR\x04vini\x12\x1b\n\
    \tvini_hmac\x18\x02\x20\x01(\x0cR\x08viniHmac\x12\x1d\n\npseudo_out\x18\
    \x03\x20\x01(\x0cR\tpseudoOut\x12&\n\x0fpseudo_out_hmac\x18\x04\x20\x01(\
    \x0cR\rpseudoOutHmac\x12(\n\x10pseudo_out_alpha\x18\x05\x20\x01(\x0cR\
    \x0epseudoOutAlpha\x12\x1b\n\tspend_key\x18\x06\x20\x01(\x0cR\x08spendKe\
    y\"\x8a\x02\n!MoneroTransactionInputViniRequest\x12R\n\x08src_entr\x18\
    \x01\x20\x01(\x0b27.hw.trezor.messages.monero.MoneroTransactionSourceEnt\
    ryR\x07srcEntr\x12\x12\n\x04vini\x18\x02\x20\x01(\x0cR\x04vini\x12\x1b\n\
    \tvini_hmac\x18\x03\x20\x01(\x0cR\x08viniHmac\x12\x1d\n\npseudo_out\x18\
    \x04\x20\x01(\x0cR\tpseudoOut\x12&\n\x0fpseudo_out_hmac\x18\x05\x20\x01(\
    \x0cR\rpseudoOutHmac\x12\x19\n\x08orig_idx\x18\x06\x20\x01(\rR\x07origId\
    x\"\x1f\n\x1dMoneroTransactionInputViniAck\"&\n$MoneroTransactionAllInpu\
    tsSetRequest\"u\n\x20MoneroTransactionAllInputsSetAck\x12Q\n\trsig_data\
    \x18\x01\x20\x01(\x0b24.hw.trezor.messages.monero.MoneroTransactionRsigD\
    ataR\x08rsigData\"\x9b\x02\n!MoneroTransactionSetOutputRequest\x12W\n\
    \x08dst_entr\x18\x01\x20\x01(\x0b2<.hw.trezor.messages.monero.MoneroTran\
    sactionDestinationEntryR\x07dstEntr\x12\"\n\rdst_entr_hmac\x18\x02\x20\
    \x01(\x0cR\x0bdstEntrHmac\x12Q\n\trsig_data\x18\x03\x20\x01(\x0b24.hw.tr\
    ezor.messages.monero.MoneroTransactionRsigDataR\x08rsigData\x12&\n\x0fis\
    _offloaded_bp\x18\x04\x20\x01(\x08R\risOffloadedBp\"\xdc\x01\n\x1dMonero\
    TransactionSetOutputAck\x12\x15\n\x06tx_out\x18\x01\x20\x01(\x0cR\x05txO\
    ut\x12\x1d\n\nvouti_hmac\x18\x02\x20\x01(\x0cR\tvoutiHmac\x12Q\n\trsig_d\
    ata\x18\x03\x20\x01(\x0b24.hw.trezor.messages.monero.MoneroTransactionRs\
    igDataR\x08rsigData\x12\x15\n\x06out_pk\x18\x04\x20\x01(\x0cR\x05outPk\
    \x12\x1b\n\tecdh_info\x18\x05\x20\x01(\x0cR\x08ecdhInfo\"v\n!MoneroTrans\
    actionAllOutSetRequest\x12Q\n\trsig_data\x18\x01\x20\x01(\x0b24.hw.trezo\
    r.messages.monero.MoneroTransactionRsigDataR\x08rsigData\"\xc0\x02\n\x1d\
    MoneroTransactionAllOutSetAck\x12\x14\n\x05extra\x18\x01\x20\x01(\x0cR\
    \x05extra\x12$\n\x0etx_prefix_hash\x18\x02\x20\x01(\x0cR\x0ctxPrefixHash\
    \x12X\n\x02rv\x18\x04\x20\x01(\x0b2H.hw.trezor.messages.monero.MoneroTra\
    nsactionAllOutSetAck.MoneroRingCtSigR\x02rv\x12*\n\x11full_message_hash\
    \x18\x05\x20\x01(\x0cR\x0ffullMessageHash\x1a]\n\x0fMoneroRingCtSig\x12\
    \x17\n\x07txn_fee\x18\x01\x20\x01(\x04R\x06txnFee\x12\x18\n\x07message\
    \x18\x02\x20\x01(\x0cR\x07message\x12\x17\n\x07rv_type\x18\x03\x20\x01(\
    \rR\x06rvType\"\xd1\x02\n!MoneroTransactionSignInputRequest\x12R\n\x08sr\
    c_entr\x18\x01\x20\x01(\x0b27.hw.trezor.messages.monero.MoneroTransactio\
    nSourceEntryR\x07srcEntr\x12\x12\n\x04vini\x18\x02\x20\x01(\x0cR\x04vini\
    \x12\x1b\n\tvini_hmac\x18\x03\x20\x01(\x0cR\x08viniHmac\x12\x1d\n\npseud\
    o_out\x18\x04\x20\x01(\x0cR\tpseudoOut\x12&\n\x0fpseudo_out_hmac\x18\x05\
    \x20\x01(\x0cR\rpseudoOutHmac\x12(\n\x10pseudo_out_alpha\x18\x06\x20\x01\
    (\x0cR\x0epseudoOutAlpha\x12\x1b\n\tspend_key\x18\x07\x20\x01(\x0cR\x08s\
    pendKey\x12\x19\n\x08orig_idx\x18\x08\x20\x01(\rR\x07origIdx\"\\\n\x1dMo\
    neroTransactionSignInputAck\x12\x1c\n\tsignature\x18\x01\x20\x01(\x0cR\t\
    signature\x12\x1d\n\npseudo_out\x18\x02\x20\x01(\x0cR\tpseudoOut\"\x1f\n\
    \x1dMoneroTransactionFinalRequest\"\xa8\x01\n\x19MoneroTransactionFinalA\
    ck\x12\x19\n\x08cout_key\x18\x01\x20\x01(\x0cR\x07coutKey\x12\x12\n\x04s\
    alt\x18\x02\x20\x01(\x0cR\x04salt\x12\x1b\n\trand_mult\x18\x03\x20\x01(\
    \x0cR\x08randMult\x12\x1e\n\x0btx_enc_keys\x18\x04\x20\x01(\x0cR\ttxEncK\
    eys\x12\x1f\n\x0bopening_key\x18\x05\x20\x01(\x0cR\nopeningKey\"\x88\x03\
    \n\x1fMoneroKeyImageExportInitRequest\x12\x10\n\x03num\x18\x01\x20\x02(\
    \x04R\x03num\x12\x12\n\x04hash\x18\x02\x20\x02(\x0cR\x04hash\x12\x1b\n\t\
    address_n\x18\x03\x20\x03(\rR\x08addressN\x12X\n\x0cnetwork_type\x18\x04\
    \x20\x01(\x0e2,.hw.trezor.messages.monero.MoneroNetworkType:\x07MAINNETR\
    \x0bnetworkType\x12j\n\x04subs\x18\x05\x20\x03(\x0b2V.hw.trezor.messages\
    .monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesListR\x04\
    subs\x1a\\\n\x1bMoneroSubAddressIndicesList\x12\x18\n\x07account\x18\x01\
    \x20\x02(\rR\x07account\x12#\n\rminor_indices\x18\x02\x20\x03(\rR\x0cmin\
    orIndices\"\x1d\n\x1bMoneroKeyImageExportInitAck\"\x89\x03\n\x1dMoneroKe\
    yImageSyncStepRequest\x12b\n\x04tdis\x18\x01\x20\x03(\x0b2N.hw.trezor.me\
    ssages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetailsR\x04td\
    is\x1a\x83\x02\n\x15MoneroTransferDetails\x12\x17\n\x07out_key\x18\x01\
    \x20\x02(\x0cR\x06outKey\x12\x1c\n\ntx_pub_key\x18\x02\x20\x02(\x0cR\x08\
    txPubKey\x123\n\x16additional_tx_pub_keys\x18\x03\x20\x03(\x0cR\x13addit\
    ionalTxPubKeys\x122\n\x15internal_output_index\x18\x04\x20\x02(\x04R\x13\
    internalOutputIndex\x12$\n\x0esub_addr_major\x18\x05\x20\x01(\rR\x0csubA\
    ddrMajor\x12$\n\x0esub_addr_minor\x18\x06\x20\x01(\rR\x0csubAddrMinor\"\
    \xb8\x01\n\x19MoneroKeyImageSyncStepAck\x12]\n\x03kis\x18\x01\x20\x03(\
    \x0b2K.hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExporte\
    dKeyImageR\x03kis\x1a<\n\x16MoneroExportedKeyImage\x12\x0e\n\x02iv\x18\
    \x01\x20\x01(\x0cR\x02iv\x12\x12\n\x04blob\x18\x03\x20\x01(\x0cR\x04blob\
    \"\x20\n\x1eMoneroKeyImageSyncFinalRequest\"5\n\x1aMoneroKeyImageSyncFin\
    alAck\x12\x17\n\x07enc_key\x18\x01\x20\x01(\x0cR\x06encKey\"\xc0\x02\n\
    \x15MoneroGetTxKeyRequest\x12\x1b\n\taddress_n\x18\x01\x20\x03(\rR\x08ad\
    dressN\x12X\n\x0cnetwork_type\x18\x02\x20\x01(\x0e2,.hw.trezor.messages.\
    monero.MoneroNetworkType:\x07MAINNETR\x0bnetworkType\x12\x14\n\x05salt1\
    \x18\x03\x20\x02(\x0cR\x05salt1\x12\x14\n\x05salt2\x18\x04\x20\x02(\x0cR\
    \x05salt2\x12\x1e\n\x0btx_enc_keys\x18\x05\x20\x02(\x0cR\ttxEncKeys\x12$\
    \n\x0etx_prefix_hash\x18\x06\x20\x02(\x0cR\x0ctxPrefixHash\x12\x16\n\x06\
    reason\x18\x07\x20\x01(\rR\x06reason\x12&\n\x0fview_public_key\x18\x08\
    \x20\x01(\x0cR\rviewPublicKey\"g\n\x11MoneroGetTxKeyAck\x12\x12\n\x04sal\
    t\x18\x01\x20\x01(\x0cR\x04salt\x12\x17\n\x07tx_keys\x18\x02\x20\x01(\
    \x0cR\x06txKeys\x12%\n\x0etx_derivations\x18\x03\x20\x01(\x0cR\rtxDeriva\
    tions\"\x96\x01\n\x1dMoneroLiveRefreshStartRequest\x12\x1b\n\taddress_n\
    \x18\x01\x20\x03(\rR\x08addressN\x12X\n\x0cnetwork_type\x18\x02\x20\x01(\
    \x0e2,.hw.trezor.messages.monero.MoneroNetworkType:\x07MAINNETR\x0bnetwo\
    rkType\"\x1b\n\x19MoneroLiveRefreshStartAck\"\xc4\x01\n\x1cMoneroLiveRef\
    reshStepRequest\x12\x17\n\x07out_key\x18\x01\x20\x02(\x0cR\x06outKey\x12\
    \x1d\n\nrecv_deriv\x18\x02\x20\x02(\x0cR\trecvDeriv\x12\x20\n\x0creal_ou\
    t_idx\x18\x03\x20\x02(\x04R\nrealOutIdx\x12$\n\x0esub_addr_major\x18\x04\
    \x20\x02(\rR\x0csubAddrMajor\x12$\n\x0esub_addr_minor\x18\x05\x20\x02(\r\
    R\x0csubAddrMinor\"K\n\x18MoneroLiveRefreshStepAck\x12\x12\n\x04salt\x18\
    \x01\x20\x01(\x0cR\x04salt\x12\x1b\n\tkey_image\x18\x02\x20\x01(\x0cR\
    \x08keyImage\"\x1f\n\x1dMoneroLiveRefreshFinalRequest\"\x1b\n\x19MoneroL\
    iveRefreshFinalAck\"\x86\x01\n\x16DebugMoneroDiagRequest\x12\x10\n\x03in\
    s\x18\x01\x20\x01(\x04R\x03ins\x12\x0e\n\x02p1\x18\x02\x20\x01(\x04R\x02\
    p1\x12\x0e\n\x02p2\x18\x03\x20\x01(\x04R\x02p2\x12\x0e\n\x02pd\x18\x04\
    \x20\x03(\x04R\x02pd\x12\x14\n\x05data1\x18\x05\x20\x01(\x0cR\x05data1\
    \x12\x14\n\x05data2\x18\x06\x20\x01(\x0cR\x05data2\"\x82\x01\n\x12DebugM\
    oneroDiagAck\x12\x10\n\x03ins\x18\x01\x20\x01(\x04R\x03ins\x12\x0e\n\x02\
    p1\x18\x02\x20\x01(\x04R\x02p1\x12\x0e\n\x02p2\x18\x03\x20\x01(\x04R\x02\
    p2\x12\x0e\n\x02pd\x18\x04\x20\x03(\x04R\x02pd\x12\x14\n\x05data1\x18\
    \x05\x20\x01(\x0cR\x05data1\x12\x14\n\x05data2\x18\x06\x20\x01(\x0cR\x05\
    data2*J\n\x11MoneroNetworkType\x12\x0b\n\x07MAINNET\x10\0\x12\x0b\n\x07T\
    ESTNET\x10\x01\x12\x0c\n\x08STAGENET\x10\x02\x12\r\n\tFAKECHAIN\x10\x03B\
    :\n#com.satoshilabs.trezor.lib.protobufB\x13TrezorMessageMonero\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(48);
            messages.push(MoneroTransactionSourceEntry::generated_message_descriptor_data());
            messages.push(MoneroTransactionDestinationEntry::generated_message_descriptor_data());
            messages.push(MoneroTransactionRsigData::generated_message_descriptor_data());
            messages.push(MoneroGetAddress::generated_message_descriptor_data());
            messages.push(MoneroAddress::generated_message_descriptor_data());
            messages.push(MoneroGetWatchKey::generated_message_descriptor_data());
            messages.push(MoneroWatchKey::generated_message_descriptor_data());
            messages.push(MoneroTransactionInitRequest::generated_message_descriptor_data());
            messages.push(MoneroTransactionInitAck::generated_message_descriptor_data());
            messages.push(MoneroTransactionSetInputRequest::generated_message_descriptor_data());
            messages.push(MoneroTransactionSetInputAck::generated_message_descriptor_data());
            messages.push(MoneroTransactionInputViniRequest::generated_message_descriptor_data());
            messages.push(MoneroTransactionInputViniAck::generated_message_descriptor_data());
            messages.push(MoneroTransactionAllInputsSetRequest::generated_message_descriptor_data());
            messages.push(MoneroTransactionAllInputsSetAck::generated_message_descriptor_data());
            messages.push(MoneroTransactionSetOutputRequest::generated_message_descriptor_data());
            messages.push(MoneroTransactionSetOutputAck::generated_message_descriptor_data());
            messages.push(MoneroTransactionAllOutSetRequest::generated_message_descriptor_data());
            messages.push(MoneroTransactionAllOutSetAck::generated_message_descriptor_data());
            messages.push(MoneroTransactionSignInputRequest::generated_message_descriptor_data());
            messages.push(MoneroTransactionSignInputAck::generated_message_descriptor_data());
            messages.push(MoneroTransactionFinalRequest::generated_message_descriptor_data());
            messages.push(MoneroTransactionFinalAck::generated_message_descriptor_data());
            messages.push(MoneroKeyImageExportInitRequest::generated_message_descriptor_data());
            messages.push(MoneroKeyImageExportInitAck::generated_message_descriptor_data());
            messages.push(MoneroKeyImageSyncStepRequest::generated_message_descriptor_data());
            messages.push(MoneroKeyImageSyncStepAck::generated_message_descriptor_data());
            messages.push(MoneroKeyImageSyncFinalRequest::generated_message_descriptor_data());
            messages.push(MoneroKeyImageSyncFinalAck::generated_message_descriptor_data());
            messages.push(MoneroGetTxKeyRequest::generated_message_descriptor_data());
            messages.push(MoneroGetTxKeyAck::generated_message_descriptor_data());
            messages.push(MoneroLiveRefreshStartRequest::generated_message_descriptor_data());
            messages.push(MoneroLiveRefreshStartAck::generated_message_descriptor_data());
            messages.push(MoneroLiveRefreshStepRequest::generated_message_descriptor_data());
            messages.push(MoneroLiveRefreshStepAck::generated_message_descriptor_data());
            messages.push(MoneroLiveRefreshFinalRequest::generated_message_descriptor_data());
            messages.push(MoneroLiveRefreshFinalAck::generated_message_descriptor_data());
            messages.push(DebugMoneroDiagRequest::generated_message_descriptor_data());
            messages.push(DebugMoneroDiagAck::generated_message_descriptor_data());
            messages.push(monero_transaction_source_entry::MoneroOutputEntry::generated_message_descriptor_data());
            messages.push(monero_transaction_source_entry::MoneroMultisigKLRki::generated_message_descriptor_data());
            messages.push(monero_transaction_source_entry::monero_output_entry::MoneroRctKeyPublic::generated_message_descriptor_data());
            messages.push(monero_transaction_destination_entry::MoneroAccountPublicAddress::generated_message_descriptor_data());
            messages.push(monero_transaction_init_request::MoneroTransactionData::generated_message_descriptor_data());
            messages.push(monero_transaction_all_out_set_ack::MoneroRingCtSig::generated_message_descriptor_data());
            messages.push(monero_key_image_export_init_request::MoneroSubAddressIndicesList::generated_message_descriptor_data());
            messages.push(monero_key_image_sync_step_request::MoneroTransferDetails::generated_message_descriptor_data());
            messages.push(monero_key_image_sync_step_ack::MoneroExportedKeyImage::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(MoneroNetworkType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
