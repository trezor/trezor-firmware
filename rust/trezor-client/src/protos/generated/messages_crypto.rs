// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc 3.19.6
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `messages-crypto.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.crypto.CipherKeyValue)
pub struct CipherKeyValue {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.CipherKeyValue.address_n)
    pub address_n: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.CipherKeyValue.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.CipherKeyValue.value)
    pub value: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.CipherKeyValue.encrypt)
    pub encrypt: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.CipherKeyValue.ask_on_encrypt)
    pub ask_on_encrypt: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.CipherKeyValue.ask_on_decrypt)
    pub ask_on_decrypt: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.CipherKeyValue.iv)
    pub iv: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.crypto.CipherKeyValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CipherKeyValue {
    fn default() -> &'a CipherKeyValue {
        <CipherKeyValue as ::protobuf::Message>::default_instance()
    }
}

impl CipherKeyValue {
    pub fn new() -> CipherKeyValue {
        ::std::default::Default::default()
    }

    // required string key = 2;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bytes value = 3;

    pub fn value(&self) -> &[u8] {
        match self.value.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        self.value.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool encrypt = 4;

    pub fn encrypt(&self) -> bool {
        self.encrypt.unwrap_or(false)
    }

    pub fn clear_encrypt(&mut self) {
        self.encrypt = ::std::option::Option::None;
    }

    pub fn has_encrypt(&self) -> bool {
        self.encrypt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypt(&mut self, v: bool) {
        self.encrypt = ::std::option::Option::Some(v);
    }

    // optional bool ask_on_encrypt = 5;

    pub fn ask_on_encrypt(&self) -> bool {
        self.ask_on_encrypt.unwrap_or(false)
    }

    pub fn clear_ask_on_encrypt(&mut self) {
        self.ask_on_encrypt = ::std::option::Option::None;
    }

    pub fn has_ask_on_encrypt(&self) -> bool {
        self.ask_on_encrypt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ask_on_encrypt(&mut self, v: bool) {
        self.ask_on_encrypt = ::std::option::Option::Some(v);
    }

    // optional bool ask_on_decrypt = 6;

    pub fn ask_on_decrypt(&self) -> bool {
        self.ask_on_decrypt.unwrap_or(false)
    }

    pub fn clear_ask_on_decrypt(&mut self) {
        self.ask_on_decrypt = ::std::option::Option::None;
    }

    pub fn has_ask_on_decrypt(&self) -> bool {
        self.ask_on_decrypt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ask_on_decrypt(&mut self, v: bool) {
        self.ask_on_decrypt = ::std::option::Option::Some(v);
    }

    // optional bytes iv = 7;

    pub fn iv(&self) -> &[u8] {
        match self.iv.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_iv(&mut self) {
        self.iv = ::std::option::Option::None;
    }

    pub fn has_iv(&self) -> bool {
        self.iv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iv(&mut self, v: ::std::vec::Vec<u8>) {
        self.iv = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iv(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.iv.is_none() {
            self.iv = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.iv.as_mut().unwrap()
    }

    // Take field
    pub fn take_iv(&mut self) -> ::std::vec::Vec<u8> {
        self.iv.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "address_n",
            |m: &CipherKeyValue| { &m.address_n },
            |m: &mut CipherKeyValue| { &mut m.address_n },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &CipherKeyValue| { &m.key },
            |m: &mut CipherKeyValue| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CipherKeyValue| { &m.value },
            |m: &mut CipherKeyValue| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encrypt",
            |m: &CipherKeyValue| { &m.encrypt },
            |m: &mut CipherKeyValue| { &mut m.encrypt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ask_on_encrypt",
            |m: &CipherKeyValue| { &m.ask_on_encrypt },
            |m: &mut CipherKeyValue| { &mut m.ask_on_encrypt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ask_on_decrypt",
            |m: &CipherKeyValue| { &m.ask_on_decrypt },
            |m: &mut CipherKeyValue| { &mut m.ask_on_decrypt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "iv",
            |m: &CipherKeyValue| { &m.iv },
            |m: &mut CipherKeyValue| { &mut m.iv },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CipherKeyValue>(
            "CipherKeyValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CipherKeyValue {
    const NAME: &'static str = "CipherKeyValue";

    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.address_n)?;
                },
                8 => {
                    self.address_n.push(is.read_uint32()?);
                },
                18 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.value = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.encrypt = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.ask_on_encrypt = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.ask_on_decrypt = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    self.iv = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.encrypt {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ask_on_encrypt {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ask_on_decrypt {
            my_size += 1 + 1;
        }
        if let Some(v) = self.iv.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.key.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.encrypt {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.ask_on_encrypt {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.ask_on_decrypt {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.iv.as_ref() {
            os.write_bytes(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CipherKeyValue {
        CipherKeyValue::new()
    }

    fn clear(&mut self) {
        self.address_n.clear();
        self.key = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.encrypt = ::std::option::Option::None;
        self.ask_on_encrypt = ::std::option::Option::None;
        self.ask_on_decrypt = ::std::option::Option::None;
        self.iv = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CipherKeyValue {
        static instance: CipherKeyValue = CipherKeyValue {
            address_n: ::std::vec::Vec::new(),
            key: ::std::option::Option::None,
            value: ::std::option::Option::None,
            encrypt: ::std::option::Option::None,
            ask_on_encrypt: ::std::option::Option::None,
            ask_on_decrypt: ::std::option::Option::None,
            iv: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CipherKeyValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CipherKeyValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CipherKeyValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CipherKeyValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.crypto.CipheredKeyValue)
pub struct CipheredKeyValue {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.CipheredKeyValue.value)
    pub value: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.crypto.CipheredKeyValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CipheredKeyValue {
    fn default() -> &'a CipheredKeyValue {
        <CipheredKeyValue as ::protobuf::Message>::default_instance()
    }
}

impl CipheredKeyValue {
    pub fn new() -> CipheredKeyValue {
        ::std::default::Default::default()
    }

    // required bytes value = 1;

    pub fn value(&self) -> &[u8] {
        match self.value.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        self.value.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CipheredKeyValue| { &m.value },
            |m: &mut CipheredKeyValue| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CipheredKeyValue>(
            "CipheredKeyValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CipheredKeyValue {
    const NAME: &'static str = "CipheredKeyValue";

    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.value = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.value.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CipheredKeyValue {
        CipheredKeyValue::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CipheredKeyValue {
        static instance: CipheredKeyValue = CipheredKeyValue {
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CipheredKeyValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CipheredKeyValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CipheredKeyValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CipheredKeyValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.crypto.IdentityType)
pub struct IdentityType {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.IdentityType.proto)
    pub proto: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.IdentityType.user)
    pub user: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.IdentityType.host)
    pub host: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.IdentityType.port)
    pub port: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.IdentityType.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.IdentityType.index)
    pub index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.crypto.IdentityType.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IdentityType {
    fn default() -> &'a IdentityType {
        <IdentityType as ::protobuf::Message>::default_instance()
    }
}

impl IdentityType {
    pub fn new() -> IdentityType {
        ::std::default::Default::default()
    }

    // optional string proto = 1;

    pub fn proto(&self) -> &str {
        match self.proto.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_proto(&mut self) {
        self.proto = ::std::option::Option::None;
    }

    pub fn has_proto(&self) -> bool {
        self.proto.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proto(&mut self, v: ::std::string::String) {
        self.proto = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proto(&mut self) -> &mut ::std::string::String {
        if self.proto.is_none() {
            self.proto = ::std::option::Option::Some(::std::string::String::new());
        }
        self.proto.as_mut().unwrap()
    }

    // Take field
    pub fn take_proto(&mut self) -> ::std::string::String {
        self.proto.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string user = 2;

    pub fn user(&self) -> &str {
        match self.user.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_user(&mut self) {
        self.user = ::std::option::Option::None;
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        if self.user.is_none() {
            self.user = ::std::option::Option::Some(::std::string::String::new());
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string host = 3;

    pub fn host(&self) -> &str {
        match self.host.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_host(&mut self) {
        self.host = ::std::option::Option::None;
    }

    pub fn has_host(&self) -> bool {
        self.host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        if self.host.is_none() {
            self.host = ::std::option::Option::Some(::std::string::String::new());
        }
        self.host.as_mut().unwrap()
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        self.host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string port = 4;

    pub fn port(&self) -> &str {
        match self.port.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: ::std::string::String) {
        self.port = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_port(&mut self) -> &mut ::std::string::String {
        if self.port.is_none() {
            self.port = ::std::option::Option::Some(::std::string::String::new());
        }
        self.port.as_mut().unwrap()
    }

    // Take field
    pub fn take_port(&mut self) -> ::std::string::String {
        self.port.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string path = 5;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 index = 6;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0u32)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "proto",
            |m: &IdentityType| { &m.proto },
            |m: &mut IdentityType| { &mut m.proto },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user",
            |m: &IdentityType| { &m.user },
            |m: &mut IdentityType| { &mut m.user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "host",
            |m: &IdentityType| { &m.host },
            |m: &mut IdentityType| { &mut m.host },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "port",
            |m: &IdentityType| { &m.port },
            |m: &mut IdentityType| { &mut m.port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &IdentityType| { &m.path },
            |m: &mut IdentityType| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &IdentityType| { &m.index },
            |m: &mut IdentityType| { &mut m.index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IdentityType>(
            "IdentityType",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IdentityType {
    const NAME: &'static str = "IdentityType";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.proto = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.user = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.host = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.port = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.proto.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.user.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.host.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.port.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.proto.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.user.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.host.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.port.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.index {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IdentityType {
        IdentityType::new()
    }

    fn clear(&mut self) {
        self.proto = ::std::option::Option::None;
        self.user = ::std::option::Option::None;
        self.host = ::std::option::Option::None;
        self.port = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IdentityType {
        static instance: IdentityType = IdentityType {
            proto: ::std::option::Option::None,
            user: ::std::option::Option::None,
            host: ::std::option::Option::None,
            port: ::std::option::Option::None,
            path: ::std::option::Option::None,
            index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IdentityType {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IdentityType").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IdentityType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IdentityType {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.crypto.SignIdentity)
pub struct SignIdentity {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.SignIdentity.identity)
    pub identity: ::protobuf::MessageField<IdentityType>,
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.SignIdentity.challenge_hidden)
    pub challenge_hidden: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.SignIdentity.challenge_visual)
    pub challenge_visual: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.SignIdentity.ecdsa_curve_name)
    pub ecdsa_curve_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.crypto.SignIdentity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SignIdentity {
    fn default() -> &'a SignIdentity {
        <SignIdentity as ::protobuf::Message>::default_instance()
    }
}

impl SignIdentity {
    pub fn new() -> SignIdentity {
        ::std::default::Default::default()
    }

    // optional bytes challenge_hidden = 2;

    pub fn challenge_hidden(&self) -> &[u8] {
        match self.challenge_hidden.as_ref() {
            Some(v) => v,
            None => b"",
        }
    }

    pub fn clear_challenge_hidden(&mut self) {
        self.challenge_hidden = ::std::option::Option::None;
    }

    pub fn has_challenge_hidden(&self) -> bool {
        self.challenge_hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_hidden(&mut self, v: ::std::vec::Vec<u8>) {
        self.challenge_hidden = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_challenge_hidden(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.challenge_hidden.is_none() {
            self.challenge_hidden = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.challenge_hidden.as_mut().unwrap()
    }

    // Take field
    pub fn take_challenge_hidden(&mut self) -> ::std::vec::Vec<u8> {
        self.challenge_hidden.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string challenge_visual = 3;

    pub fn challenge_visual(&self) -> &str {
        match self.challenge_visual.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_challenge_visual(&mut self) {
        self.challenge_visual = ::std::option::Option::None;
    }

    pub fn has_challenge_visual(&self) -> bool {
        self.challenge_visual.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_visual(&mut self, v: ::std::string::String) {
        self.challenge_visual = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_challenge_visual(&mut self) -> &mut ::std::string::String {
        if self.challenge_visual.is_none() {
            self.challenge_visual = ::std::option::Option::Some(::std::string::String::new());
        }
        self.challenge_visual.as_mut().unwrap()
    }

    // Take field
    pub fn take_challenge_visual(&mut self) -> ::std::string::String {
        self.challenge_visual.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string ecdsa_curve_name = 4;

    pub fn ecdsa_curve_name(&self) -> &str {
        match self.ecdsa_curve_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ecdsa_curve_name(&mut self) {
        self.ecdsa_curve_name = ::std::option::Option::None;
    }

    pub fn has_ecdsa_curve_name(&self) -> bool {
        self.ecdsa_curve_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ecdsa_curve_name(&mut self, v: ::std::string::String) {
        self.ecdsa_curve_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ecdsa_curve_name(&mut self) -> &mut ::std::string::String {
        if self.ecdsa_curve_name.is_none() {
            self.ecdsa_curve_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ecdsa_curve_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_ecdsa_curve_name(&mut self) -> ::std::string::String {
        self.ecdsa_curve_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IdentityType>(
            "identity",
            |m: &SignIdentity| { &m.identity },
            |m: &mut SignIdentity| { &mut m.identity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_hidden",
            |m: &SignIdentity| { &m.challenge_hidden },
            |m: &mut SignIdentity| { &mut m.challenge_hidden },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_visual",
            |m: &SignIdentity| { &m.challenge_visual },
            |m: &mut SignIdentity| { &mut m.challenge_visual },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ecdsa_curve_name",
            |m: &SignIdentity| { &m.ecdsa_curve_name },
            |m: &mut SignIdentity| { &mut m.ecdsa_curve_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SignIdentity>(
            "SignIdentity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SignIdentity {
    const NAME: &'static str = "SignIdentity";

    fn is_initialized(&self) -> bool {
        if self.identity.is_none() {
            return false;
        }
        for v in &self.identity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.identity)?;
                },
                18 => {
                    self.challenge_hidden = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.challenge_visual = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.ecdsa_curve_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.identity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.challenge_hidden.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.challenge_visual.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.ecdsa_curve_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.identity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.challenge_hidden.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.challenge_visual.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.ecdsa_curve_name.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SignIdentity {
        SignIdentity::new()
    }

    fn clear(&mut self) {
        self.identity.clear();
        self.challenge_hidden = ::std::option::Option::None;
        self.challenge_visual = ::std::option::Option::None;
        self.ecdsa_curve_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SignIdentity {
        static instance: SignIdentity = SignIdentity {
            identity: ::protobuf::MessageField::none(),
            challenge_hidden: ::std::option::Option::None,
            challenge_visual: ::std::option::Option::None,
            ecdsa_curve_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SignIdentity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SignIdentity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SignIdentity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignIdentity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.crypto.SignedIdentity)
pub struct SignedIdentity {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.SignedIdentity.address)
    pub address: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.SignedIdentity.public_key)
    pub public_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.SignedIdentity.signature)
    pub signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.crypto.SignedIdentity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SignedIdentity {
    fn default() -> &'a SignedIdentity {
        <SignedIdentity as ::protobuf::Message>::default_instance()
    }
}

impl SignedIdentity {
    pub fn new() -> SignedIdentity {
        ::std::default::Default::default()
    }

    // optional string address = 1;

    pub fn address(&self) -> &str {
        match self.address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_address(&mut self) {
        self.address = ::std::option::Option::None;
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        if self.address.is_none() {
            self.address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        self.address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bytes public_key = 2;

    pub fn public_key(&self) -> &[u8] {
        match self.public_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_public_key(&mut self) {
        self.public_key = ::std::option::Option::None;
    }

    pub fn has_public_key(&self) -> bool {
        self.public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.public_key.is_none() {
            self.public_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes signature = 3;

    pub fn signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "address",
            |m: &SignedIdentity| { &m.address },
            |m: &mut SignedIdentity| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "public_key",
            |m: &SignedIdentity| { &m.public_key },
            |m: &mut SignedIdentity| { &mut m.public_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signature",
            |m: &SignedIdentity| { &m.signature },
            |m: &mut SignedIdentity| { &mut m.signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SignedIdentity>(
            "SignedIdentity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SignedIdentity {
    const NAME: &'static str = "SignedIdentity";

    fn is_initialized(&self) -> bool {
        if self.public_key.is_none() {
            return false;
        }
        if self.signature.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.public_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.address.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.address.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.public_key.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SignedIdentity {
        SignedIdentity::new()
    }

    fn clear(&mut self) {
        self.address = ::std::option::Option::None;
        self.public_key = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SignedIdentity {
        static instance: SignedIdentity = SignedIdentity {
            address: ::std::option::Option::None,
            public_key: ::std::option::Option::None,
            signature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SignedIdentity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SignedIdentity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SignedIdentity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignedIdentity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.crypto.GetECDHSessionKey)
pub struct GetECDHSessionKey {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.GetECDHSessionKey.identity)
    pub identity: ::protobuf::MessageField<IdentityType>,
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.GetECDHSessionKey.peer_public_key)
    pub peer_public_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.GetECDHSessionKey.ecdsa_curve_name)
    pub ecdsa_curve_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.crypto.GetECDHSessionKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetECDHSessionKey {
    fn default() -> &'a GetECDHSessionKey {
        <GetECDHSessionKey as ::protobuf::Message>::default_instance()
    }
}

impl GetECDHSessionKey {
    pub fn new() -> GetECDHSessionKey {
        ::std::default::Default::default()
    }

    // required bytes peer_public_key = 2;

    pub fn peer_public_key(&self) -> &[u8] {
        match self.peer_public_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_peer_public_key(&mut self) {
        self.peer_public_key = ::std::option::Option::None;
    }

    pub fn has_peer_public_key(&self) -> bool {
        self.peer_public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.peer_public_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peer_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.peer_public_key.is_none() {
            self.peer_public_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.peer_public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_peer_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.peer_public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string ecdsa_curve_name = 3;

    pub fn ecdsa_curve_name(&self) -> &str {
        match self.ecdsa_curve_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ecdsa_curve_name(&mut self) {
        self.ecdsa_curve_name = ::std::option::Option::None;
    }

    pub fn has_ecdsa_curve_name(&self) -> bool {
        self.ecdsa_curve_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ecdsa_curve_name(&mut self, v: ::std::string::String) {
        self.ecdsa_curve_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ecdsa_curve_name(&mut self) -> &mut ::std::string::String {
        if self.ecdsa_curve_name.is_none() {
            self.ecdsa_curve_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ecdsa_curve_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_ecdsa_curve_name(&mut self) -> ::std::string::String {
        self.ecdsa_curve_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IdentityType>(
            "identity",
            |m: &GetECDHSessionKey| { &m.identity },
            |m: &mut GetECDHSessionKey| { &mut m.identity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "peer_public_key",
            |m: &GetECDHSessionKey| { &m.peer_public_key },
            |m: &mut GetECDHSessionKey| { &mut m.peer_public_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ecdsa_curve_name",
            |m: &GetECDHSessionKey| { &m.ecdsa_curve_name },
            |m: &mut GetECDHSessionKey| { &mut m.ecdsa_curve_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetECDHSessionKey>(
            "GetECDHSessionKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetECDHSessionKey {
    const NAME: &'static str = "GetECDHSessionKey";

    fn is_initialized(&self) -> bool {
        if self.identity.is_none() {
            return false;
        }
        if self.peer_public_key.is_none() {
            return false;
        }
        for v in &self.identity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.identity)?;
                },
                18 => {
                    self.peer_public_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.ecdsa_curve_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.identity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.peer_public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.ecdsa_curve_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.identity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.peer_public_key.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.ecdsa_curve_name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetECDHSessionKey {
        GetECDHSessionKey::new()
    }

    fn clear(&mut self) {
        self.identity.clear();
        self.peer_public_key = ::std::option::Option::None;
        self.ecdsa_curve_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetECDHSessionKey {
        static instance: GetECDHSessionKey = GetECDHSessionKey {
            identity: ::protobuf::MessageField::none(),
            peer_public_key: ::std::option::Option::None,
            ecdsa_curve_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetECDHSessionKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetECDHSessionKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetECDHSessionKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetECDHSessionKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.crypto.ECDHSessionKey)
pub struct ECDHSessionKey {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.ECDHSessionKey.session_key)
    pub session_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.ECDHSessionKey.public_key)
    pub public_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.crypto.ECDHSessionKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ECDHSessionKey {
    fn default() -> &'a ECDHSessionKey {
        <ECDHSessionKey as ::protobuf::Message>::default_instance()
    }
}

impl ECDHSessionKey {
    pub fn new() -> ECDHSessionKey {
        ::std::default::Default::default()
    }

    // required bytes session_key = 1;

    pub fn session_key(&self) -> &[u8] {
        match self.session_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_session_key(&mut self) {
        self.session_key = ::std::option::Option::None;
    }

    pub fn has_session_key(&self) -> bool {
        self.session_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.session_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.session_key.is_none() {
            self.session_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.session_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_session_key(&mut self) -> ::std::vec::Vec<u8> {
        self.session_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes public_key = 2;

    pub fn public_key(&self) -> &[u8] {
        match self.public_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_public_key(&mut self) {
        self.public_key = ::std::option::Option::None;
    }

    pub fn has_public_key(&self) -> bool {
        self.public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.public_key.is_none() {
            self.public_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session_key",
            |m: &ECDHSessionKey| { &m.session_key },
            |m: &mut ECDHSessionKey| { &mut m.session_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "public_key",
            |m: &ECDHSessionKey| { &m.public_key },
            |m: &mut ECDHSessionKey| { &mut m.public_key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ECDHSessionKey>(
            "ECDHSessionKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ECDHSessionKey {
    const NAME: &'static str = "ECDHSessionKey";

    fn is_initialized(&self) -> bool {
        if self.session_key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.public_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.session_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.session_key.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.public_key.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ECDHSessionKey {
        ECDHSessionKey::new()
    }

    fn clear(&mut self) {
        self.session_key = ::std::option::Option::None;
        self.public_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ECDHSessionKey {
        static instance: ECDHSessionKey = ECDHSessionKey {
            session_key: ::std::option::Option::None,
            public_key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ECDHSessionKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ECDHSessionKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ECDHSessionKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ECDHSessionKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.crypto.CosiCommit)
pub struct CosiCommit {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.CosiCommit.address_n)
    pub address_n: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.CosiCommit.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.crypto.CosiCommit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CosiCommit {
    fn default() -> &'a CosiCommit {
        <CosiCommit as ::protobuf::Message>::default_instance()
    }
}

impl CosiCommit {
    pub fn new() -> CosiCommit {
        ::std::default::Default::default()
    }

    // optional bytes data = 2;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "address_n",
            |m: &CosiCommit| { &m.address_n },
            |m: &mut CosiCommit| { &mut m.address_n },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CosiCommit| { &m.data },
            |m: &mut CosiCommit| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CosiCommit>(
            "CosiCommit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CosiCommit {
    const NAME: &'static str = "CosiCommit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.address_n)?;
                },
                8 => {
                    self.address_n.push(is.read_uint32()?);
                },
                18 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CosiCommit {
        CosiCommit::new()
    }

    fn clear(&mut self) {
        self.address_n.clear();
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CosiCommit {
        static instance: CosiCommit = CosiCommit {
            address_n: ::std::vec::Vec::new(),
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CosiCommit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CosiCommit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CosiCommit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CosiCommit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.crypto.CosiCommitment)
pub struct CosiCommitment {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.CosiCommitment.commitment)
    pub commitment: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.CosiCommitment.pubkey)
    pub pubkey: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.crypto.CosiCommitment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CosiCommitment {
    fn default() -> &'a CosiCommitment {
        <CosiCommitment as ::protobuf::Message>::default_instance()
    }
}

impl CosiCommitment {
    pub fn new() -> CosiCommitment {
        ::std::default::Default::default()
    }

    // required bytes commitment = 1;

    pub fn commitment(&self) -> &[u8] {
        match self.commitment.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_commitment(&mut self) {
        self.commitment = ::std::option::Option::None;
    }

    pub fn has_commitment(&self) -> bool {
        self.commitment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commitment(&mut self, v: ::std::vec::Vec<u8>) {
        self.commitment = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commitment(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.commitment.is_none() {
            self.commitment = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.commitment.as_mut().unwrap()
    }

    // Take field
    pub fn take_commitment(&mut self) -> ::std::vec::Vec<u8> {
        self.commitment.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes pubkey = 2;

    pub fn pubkey(&self) -> &[u8] {
        match self.pubkey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pubkey(&mut self) {
        self.pubkey = ::std::option::Option::None;
    }

    pub fn has_pubkey(&self) -> bool {
        self.pubkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pubkey(&mut self, v: ::std::vec::Vec<u8>) {
        self.pubkey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubkey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pubkey.is_none() {
            self.pubkey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.pubkey.as_mut().unwrap()
    }

    // Take field
    pub fn take_pubkey(&mut self) -> ::std::vec::Vec<u8> {
        self.pubkey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "commitment",
            |m: &CosiCommitment| { &m.commitment },
            |m: &mut CosiCommitment| { &mut m.commitment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pubkey",
            |m: &CosiCommitment| { &m.pubkey },
            |m: &mut CosiCommitment| { &mut m.pubkey },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CosiCommitment>(
            "CosiCommitment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CosiCommitment {
    const NAME: &'static str = "CosiCommitment";

    fn is_initialized(&self) -> bool {
        if self.commitment.is_none() {
            return false;
        }
        if self.pubkey.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.commitment = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.pubkey = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.commitment.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.pubkey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.commitment.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.pubkey.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CosiCommitment {
        CosiCommitment::new()
    }

    fn clear(&mut self) {
        self.commitment = ::std::option::Option::None;
        self.pubkey = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CosiCommitment {
        static instance: CosiCommitment = CosiCommitment {
            commitment: ::std::option::Option::None,
            pubkey: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CosiCommitment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CosiCommitment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CosiCommitment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CosiCommitment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.crypto.CosiSign)
pub struct CosiSign {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.CosiSign.address_n)
    pub address_n: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.CosiSign.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.CosiSign.global_commitment)
    pub global_commitment: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.CosiSign.global_pubkey)
    pub global_pubkey: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.crypto.CosiSign.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CosiSign {
    fn default() -> &'a CosiSign {
        <CosiSign as ::protobuf::Message>::default_instance()
    }
}

impl CosiSign {
    pub fn new() -> CosiSign {
        ::std::default::Default::default()
    }

    // required bytes data = 2;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes global_commitment = 3;

    pub fn global_commitment(&self) -> &[u8] {
        match self.global_commitment.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_global_commitment(&mut self) {
        self.global_commitment = ::std::option::Option::None;
    }

    pub fn has_global_commitment(&self) -> bool {
        self.global_commitment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_global_commitment(&mut self, v: ::std::vec::Vec<u8>) {
        self.global_commitment = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_global_commitment(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.global_commitment.is_none() {
            self.global_commitment = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.global_commitment.as_mut().unwrap()
    }

    // Take field
    pub fn take_global_commitment(&mut self) -> ::std::vec::Vec<u8> {
        self.global_commitment.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes global_pubkey = 4;

    pub fn global_pubkey(&self) -> &[u8] {
        match self.global_pubkey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_global_pubkey(&mut self) {
        self.global_pubkey = ::std::option::Option::None;
    }

    pub fn has_global_pubkey(&self) -> bool {
        self.global_pubkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_global_pubkey(&mut self, v: ::std::vec::Vec<u8>) {
        self.global_pubkey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_global_pubkey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.global_pubkey.is_none() {
            self.global_pubkey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.global_pubkey.as_mut().unwrap()
    }

    // Take field
    pub fn take_global_pubkey(&mut self) -> ::std::vec::Vec<u8> {
        self.global_pubkey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "address_n",
            |m: &CosiSign| { &m.address_n },
            |m: &mut CosiSign| { &mut m.address_n },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CosiSign| { &m.data },
            |m: &mut CosiSign| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "global_commitment",
            |m: &CosiSign| { &m.global_commitment },
            |m: &mut CosiSign| { &mut m.global_commitment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "global_pubkey",
            |m: &CosiSign| { &m.global_pubkey },
            |m: &mut CosiSign| { &mut m.global_pubkey },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CosiSign>(
            "CosiSign",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CosiSign {
    const NAME: &'static str = "CosiSign";

    fn is_initialized(&self) -> bool {
        if self.data.is_none() {
            return false;
        }
        if self.global_commitment.is_none() {
            return false;
        }
        if self.global_pubkey.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.address_n)?;
                },
                8 => {
                    self.address_n.push(is.read_uint32()?);
                },
                18 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.global_commitment = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.global_pubkey = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.global_commitment.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.global_pubkey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.global_commitment.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.global_pubkey.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CosiSign {
        CosiSign::new()
    }

    fn clear(&mut self) {
        self.address_n.clear();
        self.data = ::std::option::Option::None;
        self.global_commitment = ::std::option::Option::None;
        self.global_pubkey = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CosiSign {
        static instance: CosiSign = CosiSign {
            address_n: ::std::vec::Vec::new(),
            data: ::std::option::Option::None,
            global_commitment: ::std::option::Option::None,
            global_pubkey: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CosiSign {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CosiSign").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CosiSign {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CosiSign {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.crypto.CosiSignature)
pub struct CosiSignature {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.crypto.CosiSignature.signature)
    pub signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.crypto.CosiSignature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CosiSignature {
    fn default() -> &'a CosiSignature {
        <CosiSignature as ::protobuf::Message>::default_instance()
    }
}

impl CosiSignature {
    pub fn new() -> CosiSignature {
        ::std::default::Default::default()
    }

    // required bytes signature = 1;

    pub fn signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signature",
            |m: &CosiSignature| { &m.signature },
            |m: &mut CosiSignature| { &mut m.signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CosiSignature>(
            "CosiSignature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CosiSignature {
    const NAME: &'static str = "CosiSignature";

    fn is_initialized(&self) -> bool {
        if self.signature.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.signature.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CosiSignature {
        CosiSignature::new()
    }

    fn clear(&mut self) {
        self.signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CosiSignature {
        static instance: CosiSignature = CosiSignature {
            signature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CosiSignature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CosiSignature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CosiSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CosiSignature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15messages-crypto.proto\x12\x19hw.trezor.messages.crypto\x1a\x0emess\
    ages.proto\"\xcb\x01\n\x0eCipherKeyValue\x12\x1b\n\taddress_n\x18\x01\
    \x20\x03(\rR\x08addressN\x12\x10\n\x03key\x18\x02\x20\x02(\tR\x03key\x12\
    \x14\n\x05value\x18\x03\x20\x02(\x0cR\x05value\x12\x18\n\x07encrypt\x18\
    \x04\x20\x01(\x08R\x07encrypt\x12$\n\x0eask_on_encrypt\x18\x05\x20\x01(\
    \x08R\x0caskOnEncrypt\x12$\n\x0eask_on_decrypt\x18\x06\x20\x01(\x08R\x0c\
    askOnDecrypt\x12\x0e\n\x02iv\x18\x07\x20\x01(\x0cR\x02iv\"(\n\x10Ciphere\
    dKeyValue\x12\x14\n\x05value\x18\x01\x20\x02(\x0cR\x05value\"\x8d\x01\n\
    \x0cIdentityType\x12\x14\n\x05proto\x18\x01\x20\x01(\tR\x05proto\x12\x12\
    \n\x04user\x18\x02\x20\x01(\tR\x04user\x12\x12\n\x04host\x18\x03\x20\x01\
    (\tR\x04host\x12\x12\n\x04port\x18\x04\x20\x01(\tR\x04port\x12\x12\n\x04\
    path\x18\x05\x20\x01(\tR\x04path\x12\x17\n\x05index\x18\x06\x20\x01(\r:\
    \x010R\x05index\"\xd7\x01\n\x0cSignIdentity\x12C\n\x08identity\x18\x01\
    \x20\x02(\x0b2'.hw.trezor.messages.crypto.IdentityTypeR\x08identity\x12+\
    \n\x10challenge_hidden\x18\x02\x20\x01(\x0c:\0R\x0fchallengeHidden\x12+\
    \n\x10challenge_visual\x18\x03\x20\x01(\t:\0R\x0fchallengeVisual\x12(\n\
    \x10ecdsa_curve_name\x18\x04\x20\x01(\tR\x0eecdsaCurveName\"g\n\x0eSigne\
    dIdentity\x12\x18\n\x07address\x18\x01\x20\x01(\tR\x07address\x12\x1d\n\
    \npublic_key\x18\x02\x20\x02(\x0cR\tpublicKey\x12\x1c\n\tsignature\x18\
    \x03\x20\x02(\x0cR\tsignature\"\xaa\x01\n\x11GetECDHSessionKey\x12C\n\
    \x08identity\x18\x01\x20\x02(\x0b2'.hw.trezor.messages.crypto.IdentityTy\
    peR\x08identity\x12&\n\x0fpeer_public_key\x18\x02\x20\x02(\x0cR\rpeerPub\
    licKey\x12(\n\x10ecdsa_curve_name\x18\x03\x20\x01(\tR\x0eecdsaCurveName\
    \"P\n\x0eECDHSessionKey\x12\x1f\n\x0bsession_key\x18\x01\x20\x02(\x0cR\n\
    sessionKey\x12\x1d\n\npublic_key\x18\x02\x20\x01(\x0cR\tpublicKey\"A\n\n\
    CosiCommit\x12\x1b\n\taddress_n\x18\x01\x20\x03(\rR\x08addressN\x12\x16\
    \n\x04data\x18\x02\x20\x01(\x0cR\x04dataB\x02\x18\x01\"H\n\x0eCosiCommit\
    ment\x12\x1e\n\ncommitment\x18\x01\x20\x02(\x0cR\ncommitment\x12\x16\n\
    \x06pubkey\x18\x02\x20\x02(\x0cR\x06pubkey\"\x8d\x01\n\x08CosiSign\x12\
    \x1b\n\taddress_n\x18\x01\x20\x03(\rR\x08addressN\x12\x12\n\x04data\x18\
    \x02\x20\x02(\x0cR\x04data\x12+\n\x11global_commitment\x18\x03\x20\x02(\
    \x0cR\x10globalCommitment\x12#\n\rglobal_pubkey\x18\x04\x20\x02(\x0cR\
    \x0cglobalPubkey\"-\n\rCosiSignature\x12\x1c\n\tsignature\x18\x01\x20\
    \x02(\x0cR\tsignatureB>\n#com.satoshilabs.trezor.lib.protobufB\x13Trezor\
    MessageCrypto\x80\xa6\x1d\x01\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::messages::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(11);
            messages.push(CipherKeyValue::generated_message_descriptor_data());
            messages.push(CipheredKeyValue::generated_message_descriptor_data());
            messages.push(IdentityType::generated_message_descriptor_data());
            messages.push(SignIdentity::generated_message_descriptor_data());
            messages.push(SignedIdentity::generated_message_descriptor_data());
            messages.push(GetECDHSessionKey::generated_message_descriptor_data());
            messages.push(ECDHSessionKey::generated_message_descriptor_data());
            messages.push(CosiCommit::generated_message_descriptor_data());
            messages.push(CosiCommitment::generated_message_descriptor_data());
            messages.push(CosiSign::generated_message_descriptor_data());
            messages.push(CosiSignature::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
