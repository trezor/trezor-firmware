// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.6
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `messages-management.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:hw.trezor.messages.management.Initialize)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Initialize {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Initialize.session_id)
    pub session_id: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Initialize._skip_passphrase)
    pub _skip_passphrase: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Initialize.derive_cardano)
    pub derive_cardano: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.Initialize.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Initialize {
    fn default() -> &'a Initialize {
        <Initialize as ::protobuf::Message>::default_instance()
    }
}

impl Initialize {
    pub fn new() -> Initialize {
        ::std::default::Default::default()
    }

    // optional bytes session_id = 1;

    pub fn session_id(&self) -> &[u8] {
        match self.session_id.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.session_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.session_id.is_none() {
            self.session_id = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.session_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_session_id(&mut self) -> ::std::vec::Vec<u8> {
        self.session_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool _skip_passphrase = 2;

    pub fn _skip_passphrase(&self) -> bool {
        self._skip_passphrase.unwrap_or(false)
    }

    pub fn clear__skip_passphrase(&mut self) {
        self._skip_passphrase = ::std::option::Option::None;
    }

    pub fn has__skip_passphrase(&self) -> bool {
        self._skip_passphrase.is_some()
    }

    // Param is passed by value, moved
    pub fn set__skip_passphrase(&mut self, v: bool) {
        self._skip_passphrase = ::std::option::Option::Some(v);
    }

    // optional bool derive_cardano = 3;

    pub fn derive_cardano(&self) -> bool {
        self.derive_cardano.unwrap_or(false)
    }

    pub fn clear_derive_cardano(&mut self) {
        self.derive_cardano = ::std::option::Option::None;
    }

    pub fn has_derive_cardano(&self) -> bool {
        self.derive_cardano.is_some()
    }

    // Param is passed by value, moved
    pub fn set_derive_cardano(&mut self, v: bool) {
        self.derive_cardano = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session_id",
            |m: &Initialize| { &m.session_id },
            |m: &mut Initialize| { &mut m.session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "_skip_passphrase",
            |m: &Initialize| { &m._skip_passphrase },
            |m: &mut Initialize| { &mut m._skip_passphrase },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "derive_cardano",
            |m: &Initialize| { &m.derive_cardano },
            |m: &mut Initialize| { &mut m.derive_cardano },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Initialize>(
            "Initialize",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Initialize {
    const NAME: &'static str = "Initialize";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session_id = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self._skip_passphrase = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.derive_cardano = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.session_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self._skip_passphrase {
            my_size += 1 + 1;
        }
        if let Some(v) = self.derive_cardano {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.session_id.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self._skip_passphrase {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.derive_cardano {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Initialize {
        Initialize::new()
    }

    fn clear(&mut self) {
        self.session_id = ::std::option::Option::None;
        self._skip_passphrase = ::std::option::Option::None;
        self.derive_cardano = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Initialize {
        static instance: Initialize = Initialize {
            session_id: ::std::option::Option::None,
            _skip_passphrase: ::std::option::Option::None,
            derive_cardano: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Initialize {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Initialize").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Initialize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Initialize {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.GetFeatures)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetFeatures {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.GetFeatures.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetFeatures {
    fn default() -> &'a GetFeatures {
        <GetFeatures as ::protobuf::Message>::default_instance()
    }
}

impl GetFeatures {
    pub fn new() -> GetFeatures {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetFeatures>(
            "GetFeatures",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetFeatures {
    const NAME: &'static str = "GetFeatures";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetFeatures {
        GetFeatures::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetFeatures {
        static instance: GetFeatures = GetFeatures {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetFeatures {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetFeatures").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetFeatures {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFeatures {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.Features)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Features {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.vendor)
    pub vendor: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.major_version)
    pub major_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.minor_version)
    pub minor_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.patch_version)
    pub patch_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.bootloader_mode)
    pub bootloader_mode: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.device_id)
    pub device_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.pin_protection)
    pub pin_protection: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.passphrase_protection)
    pub passphrase_protection: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.language)
    pub language: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.label)
    pub label: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.initialized)
    pub initialized: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.revision)
    pub revision: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.bootloader_hash)
    pub bootloader_hash: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.imported)
    pub imported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.unlocked)
    pub unlocked: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features._passphrase_cached)
    pub _passphrase_cached: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.firmware_present)
    pub firmware_present: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.backup_availability)
    pub backup_availability: ::std::option::Option<::protobuf::EnumOrUnknown<features::BackupAvailability>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.model)
    pub model: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.fw_major)
    pub fw_major: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.fw_minor)
    pub fw_minor: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.fw_patch)
    pub fw_patch: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.fw_vendor)
    pub fw_vendor: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.unfinished_backup)
    pub unfinished_backup: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.no_backup)
    pub no_backup: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.recovery_status)
    pub recovery_status: ::std::option::Option<::protobuf::EnumOrUnknown<features::RecoveryStatus>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.capabilities)
    pub capabilities: ::std::vec::Vec<::protobuf::EnumOrUnknown<features::Capability>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.backup_type)
    pub backup_type: ::std::option::Option<::protobuf::EnumOrUnknown<BackupType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.sd_card_present)
    pub sd_card_present: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.sd_protection)
    pub sd_protection: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.wipe_code_protection)
    pub wipe_code_protection: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.session_id)
    pub session_id: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.passphrase_always_on_device)
    pub passphrase_always_on_device: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.safety_checks)
    pub safety_checks: ::std::option::Option<::protobuf::EnumOrUnknown<SafetyCheckLevel>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.auto_lock_delay_ms)
    pub auto_lock_delay_ms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.display_rotation)
    pub display_rotation: ::std::option::Option<::protobuf::EnumOrUnknown<DisplayRotation>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.experimental_features)
    pub experimental_features: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.busy)
    pub busy: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.homescreen_format)
    pub homescreen_format: ::std::option::Option<::protobuf::EnumOrUnknown<HomescreenFormat>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.hide_passphrase_from_host)
    pub hide_passphrase_from_host: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.internal_model)
    pub internal_model: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.unit_color)
    pub unit_color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.unit_btconly)
    pub unit_btconly: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.homescreen_width)
    pub homescreen_width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.homescreen_height)
    pub homescreen_height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.bootloader_locked)
    pub bootloader_locked: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.language_version_matches)
    pub language_version_matches: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.unit_packaging)
    pub unit_packaging: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.haptic_feedback)
    pub haptic_feedback: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.recovery_type)
    pub recovery_type: ::std::option::Option<::protobuf::EnumOrUnknown<RecoveryType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Features.optiga_sec)
    pub optiga_sec: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.Features.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Features {
    fn default() -> &'a Features {
        <Features as ::protobuf::Message>::default_instance()
    }
}

impl Features {
    pub fn new() -> Features {
        ::std::default::Default::default()
    }

    // optional string vendor = 1;

    pub fn vendor(&self) -> &str {
        match self.vendor.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_vendor(&mut self) {
        self.vendor = ::std::option::Option::None;
    }

    pub fn has_vendor(&self) -> bool {
        self.vendor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vendor(&mut self, v: ::std::string::String) {
        self.vendor = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vendor(&mut self) -> &mut ::std::string::String {
        if self.vendor.is_none() {
            self.vendor = ::std::option::Option::Some(::std::string::String::new());
        }
        self.vendor.as_mut().unwrap()
    }

    // Take field
    pub fn take_vendor(&mut self) -> ::std::string::String {
        self.vendor.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint32 major_version = 2;

    pub fn major_version(&self) -> u32 {
        self.major_version.unwrap_or(0)
    }

    pub fn clear_major_version(&mut self) {
        self.major_version = ::std::option::Option::None;
    }

    pub fn has_major_version(&self) -> bool {
        self.major_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_major_version(&mut self, v: u32) {
        self.major_version = ::std::option::Option::Some(v);
    }

    // required uint32 minor_version = 3;

    pub fn minor_version(&self) -> u32 {
        self.minor_version.unwrap_or(0)
    }

    pub fn clear_minor_version(&mut self) {
        self.minor_version = ::std::option::Option::None;
    }

    pub fn has_minor_version(&self) -> bool {
        self.minor_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minor_version(&mut self, v: u32) {
        self.minor_version = ::std::option::Option::Some(v);
    }

    // required uint32 patch_version = 4;

    pub fn patch_version(&self) -> u32 {
        self.patch_version.unwrap_or(0)
    }

    pub fn clear_patch_version(&mut self) {
        self.patch_version = ::std::option::Option::None;
    }

    pub fn has_patch_version(&self) -> bool {
        self.patch_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_patch_version(&mut self, v: u32) {
        self.patch_version = ::std::option::Option::Some(v);
    }

    // optional bool bootloader_mode = 5;

    pub fn bootloader_mode(&self) -> bool {
        self.bootloader_mode.unwrap_or(false)
    }

    pub fn clear_bootloader_mode(&mut self) {
        self.bootloader_mode = ::std::option::Option::None;
    }

    pub fn has_bootloader_mode(&self) -> bool {
        self.bootloader_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bootloader_mode(&mut self, v: bool) {
        self.bootloader_mode = ::std::option::Option::Some(v);
    }

    // optional string device_id = 6;

    pub fn device_id(&self) -> &str {
        match self.device_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_id(&mut self) {
        self.device_id = ::std::option::Option::None;
    }

    pub fn has_device_id(&self) -> bool {
        self.device_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: ::std::string::String) {
        self.device_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_id(&mut self) -> &mut ::std::string::String {
        if self.device_id.is_none() {
            self.device_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_id(&mut self) -> ::std::string::String {
        self.device_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool pin_protection = 7;

    pub fn pin_protection(&self) -> bool {
        self.pin_protection.unwrap_or(false)
    }

    pub fn clear_pin_protection(&mut self) {
        self.pin_protection = ::std::option::Option::None;
    }

    pub fn has_pin_protection(&self) -> bool {
        self.pin_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pin_protection(&mut self, v: bool) {
        self.pin_protection = ::std::option::Option::Some(v);
    }

    // optional bool passphrase_protection = 8;

    pub fn passphrase_protection(&self) -> bool {
        self.passphrase_protection.unwrap_or(false)
    }

    pub fn clear_passphrase_protection(&mut self) {
        self.passphrase_protection = ::std::option::Option::None;
    }

    pub fn has_passphrase_protection(&self) -> bool {
        self.passphrase_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passphrase_protection(&mut self, v: bool) {
        self.passphrase_protection = ::std::option::Option::Some(v);
    }

    // optional string language = 9;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string label = 10;

    pub fn label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_label(&mut self) {
        self.label = ::std::option::Option::None;
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label = ::std::option::Option::Some(::std::string::String::new());
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool initialized = 12;

    pub fn initialized(&self) -> bool {
        self.initialized.unwrap_or(false)
    }

    pub fn clear_initialized(&mut self) {
        self.initialized = ::std::option::Option::None;
    }

    pub fn has_initialized(&self) -> bool {
        self.initialized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initialized(&mut self, v: bool) {
        self.initialized = ::std::option::Option::Some(v);
    }

    // optional bytes revision = 13;

    pub fn revision(&self) -> &[u8] {
        match self.revision.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: ::std::vec::Vec<u8>) {
        self.revision = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_revision(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.revision.is_none() {
            self.revision = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.revision.as_mut().unwrap()
    }

    // Take field
    pub fn take_revision(&mut self) -> ::std::vec::Vec<u8> {
        self.revision.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes bootloader_hash = 14;

    pub fn bootloader_hash(&self) -> &[u8] {
        match self.bootloader_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_bootloader_hash(&mut self) {
        self.bootloader_hash = ::std::option::Option::None;
    }

    pub fn has_bootloader_hash(&self) -> bool {
        self.bootloader_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bootloader_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.bootloader_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bootloader_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.bootloader_hash.is_none() {
            self.bootloader_hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.bootloader_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_bootloader_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.bootloader_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool imported = 15;

    pub fn imported(&self) -> bool {
        self.imported.unwrap_or(false)
    }

    pub fn clear_imported(&mut self) {
        self.imported = ::std::option::Option::None;
    }

    pub fn has_imported(&self) -> bool {
        self.imported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_imported(&mut self, v: bool) {
        self.imported = ::std::option::Option::Some(v);
    }

    // optional bool unlocked = 16;

    pub fn unlocked(&self) -> bool {
        self.unlocked.unwrap_or(false)
    }

    pub fn clear_unlocked(&mut self) {
        self.unlocked = ::std::option::Option::None;
    }

    pub fn has_unlocked(&self) -> bool {
        self.unlocked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unlocked(&mut self, v: bool) {
        self.unlocked = ::std::option::Option::Some(v);
    }

    // optional bool _passphrase_cached = 17;

    pub fn _passphrase_cached(&self) -> bool {
        self._passphrase_cached.unwrap_or(false)
    }

    pub fn clear__passphrase_cached(&mut self) {
        self._passphrase_cached = ::std::option::Option::None;
    }

    pub fn has__passphrase_cached(&self) -> bool {
        self._passphrase_cached.is_some()
    }

    // Param is passed by value, moved
    pub fn set__passphrase_cached(&mut self, v: bool) {
        self._passphrase_cached = ::std::option::Option::Some(v);
    }

    // optional bool firmware_present = 18;

    pub fn firmware_present(&self) -> bool {
        self.firmware_present.unwrap_or(false)
    }

    pub fn clear_firmware_present(&mut self) {
        self.firmware_present = ::std::option::Option::None;
    }

    pub fn has_firmware_present(&self) -> bool {
        self.firmware_present.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firmware_present(&mut self, v: bool) {
        self.firmware_present = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.management.Features.BackupAvailability backup_availability = 19;

    pub fn backup_availability(&self) -> features::BackupAvailability {
        match self.backup_availability {
            Some(e) => e.enum_value_or(features::BackupAvailability::NotAvailable),
            None => features::BackupAvailability::NotAvailable,
        }
    }

    pub fn clear_backup_availability(&mut self) {
        self.backup_availability = ::std::option::Option::None;
    }

    pub fn has_backup_availability(&self) -> bool {
        self.backup_availability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backup_availability(&mut self, v: features::BackupAvailability) {
        self.backup_availability = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 flags = 20;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional string model = 21;

    pub fn model(&self) -> &str {
        match self.model.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_model(&mut self) {
        self.model = ::std::option::Option::None;
    }

    pub fn has_model(&self) -> bool {
        self.model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: ::std::string::String) {
        self.model = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model(&mut self) -> &mut ::std::string::String {
        if self.model.is_none() {
            self.model = ::std::option::Option::Some(::std::string::String::new());
        }
        self.model.as_mut().unwrap()
    }

    // Take field
    pub fn take_model(&mut self) -> ::std::string::String {
        self.model.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 fw_major = 22;

    pub fn fw_major(&self) -> u32 {
        self.fw_major.unwrap_or(0)
    }

    pub fn clear_fw_major(&mut self) {
        self.fw_major = ::std::option::Option::None;
    }

    pub fn has_fw_major(&self) -> bool {
        self.fw_major.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fw_major(&mut self, v: u32) {
        self.fw_major = ::std::option::Option::Some(v);
    }

    // optional uint32 fw_minor = 23;

    pub fn fw_minor(&self) -> u32 {
        self.fw_minor.unwrap_or(0)
    }

    pub fn clear_fw_minor(&mut self) {
        self.fw_minor = ::std::option::Option::None;
    }

    pub fn has_fw_minor(&self) -> bool {
        self.fw_minor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fw_minor(&mut self, v: u32) {
        self.fw_minor = ::std::option::Option::Some(v);
    }

    // optional uint32 fw_patch = 24;

    pub fn fw_patch(&self) -> u32 {
        self.fw_patch.unwrap_or(0)
    }

    pub fn clear_fw_patch(&mut self) {
        self.fw_patch = ::std::option::Option::None;
    }

    pub fn has_fw_patch(&self) -> bool {
        self.fw_patch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fw_patch(&mut self, v: u32) {
        self.fw_patch = ::std::option::Option::Some(v);
    }

    // optional string fw_vendor = 25;

    pub fn fw_vendor(&self) -> &str {
        match self.fw_vendor.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fw_vendor(&mut self) {
        self.fw_vendor = ::std::option::Option::None;
    }

    pub fn has_fw_vendor(&self) -> bool {
        self.fw_vendor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fw_vendor(&mut self, v: ::std::string::String) {
        self.fw_vendor = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fw_vendor(&mut self) -> &mut ::std::string::String {
        if self.fw_vendor.is_none() {
            self.fw_vendor = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fw_vendor.as_mut().unwrap()
    }

    // Take field
    pub fn take_fw_vendor(&mut self) -> ::std::string::String {
        self.fw_vendor.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool unfinished_backup = 27;

    pub fn unfinished_backup(&self) -> bool {
        self.unfinished_backup.unwrap_or(false)
    }

    pub fn clear_unfinished_backup(&mut self) {
        self.unfinished_backup = ::std::option::Option::None;
    }

    pub fn has_unfinished_backup(&self) -> bool {
        self.unfinished_backup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unfinished_backup(&mut self, v: bool) {
        self.unfinished_backup = ::std::option::Option::Some(v);
    }

    // optional bool no_backup = 28;

    pub fn no_backup(&self) -> bool {
        self.no_backup.unwrap_or(false)
    }

    pub fn clear_no_backup(&mut self) {
        self.no_backup = ::std::option::Option::None;
    }

    pub fn has_no_backup(&self) -> bool {
        self.no_backup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_no_backup(&mut self, v: bool) {
        self.no_backup = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.management.Features.RecoveryStatus recovery_status = 29;

    pub fn recovery_status(&self) -> features::RecoveryStatus {
        match self.recovery_status {
            Some(e) => e.enum_value_or(features::RecoveryStatus::Nothing),
            None => features::RecoveryStatus::Nothing,
        }
    }

    pub fn clear_recovery_status(&mut self) {
        self.recovery_status = ::std::option::Option::None;
    }

    pub fn has_recovery_status(&self) -> bool {
        self.recovery_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recovery_status(&mut self, v: features::RecoveryStatus) {
        self.recovery_status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .hw.trezor.messages.management.BackupType backup_type = 31;

    pub fn backup_type(&self) -> BackupType {
        match self.backup_type {
            Some(e) => e.enum_value_or(BackupType::Bip39),
            None => BackupType::Bip39,
        }
    }

    pub fn clear_backup_type(&mut self) {
        self.backup_type = ::std::option::Option::None;
    }

    pub fn has_backup_type(&self) -> bool {
        self.backup_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backup_type(&mut self, v: BackupType) {
        self.backup_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool sd_card_present = 32;

    pub fn sd_card_present(&self) -> bool {
        self.sd_card_present.unwrap_or(false)
    }

    pub fn clear_sd_card_present(&mut self) {
        self.sd_card_present = ::std::option::Option::None;
    }

    pub fn has_sd_card_present(&self) -> bool {
        self.sd_card_present.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sd_card_present(&mut self, v: bool) {
        self.sd_card_present = ::std::option::Option::Some(v);
    }

    // optional bool sd_protection = 33;

    pub fn sd_protection(&self) -> bool {
        self.sd_protection.unwrap_or(false)
    }

    pub fn clear_sd_protection(&mut self) {
        self.sd_protection = ::std::option::Option::None;
    }

    pub fn has_sd_protection(&self) -> bool {
        self.sd_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sd_protection(&mut self, v: bool) {
        self.sd_protection = ::std::option::Option::Some(v);
    }

    // optional bool wipe_code_protection = 34;

    pub fn wipe_code_protection(&self) -> bool {
        self.wipe_code_protection.unwrap_or(false)
    }

    pub fn clear_wipe_code_protection(&mut self) {
        self.wipe_code_protection = ::std::option::Option::None;
    }

    pub fn has_wipe_code_protection(&self) -> bool {
        self.wipe_code_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wipe_code_protection(&mut self, v: bool) {
        self.wipe_code_protection = ::std::option::Option::Some(v);
    }

    // optional bytes session_id = 35;

    pub fn session_id(&self) -> &[u8] {
        match self.session_id.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.session_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.session_id.is_none() {
            self.session_id = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.session_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_session_id(&mut self) -> ::std::vec::Vec<u8> {
        self.session_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool passphrase_always_on_device = 36;

    pub fn passphrase_always_on_device(&self) -> bool {
        self.passphrase_always_on_device.unwrap_or(false)
    }

    pub fn clear_passphrase_always_on_device(&mut self) {
        self.passphrase_always_on_device = ::std::option::Option::None;
    }

    pub fn has_passphrase_always_on_device(&self) -> bool {
        self.passphrase_always_on_device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passphrase_always_on_device(&mut self, v: bool) {
        self.passphrase_always_on_device = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.management.SafetyCheckLevel safety_checks = 37;

    pub fn safety_checks(&self) -> SafetyCheckLevel {
        match self.safety_checks {
            Some(e) => e.enum_value_or(SafetyCheckLevel::Strict),
            None => SafetyCheckLevel::Strict,
        }
    }

    pub fn clear_safety_checks(&mut self) {
        self.safety_checks = ::std::option::Option::None;
    }

    pub fn has_safety_checks(&self) -> bool {
        self.safety_checks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_safety_checks(&mut self, v: SafetyCheckLevel) {
        self.safety_checks = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 auto_lock_delay_ms = 38;

    pub fn auto_lock_delay_ms(&self) -> u32 {
        self.auto_lock_delay_ms.unwrap_or(0)
    }

    pub fn clear_auto_lock_delay_ms(&mut self) {
        self.auto_lock_delay_ms = ::std::option::Option::None;
    }

    pub fn has_auto_lock_delay_ms(&self) -> bool {
        self.auto_lock_delay_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auto_lock_delay_ms(&mut self, v: u32) {
        self.auto_lock_delay_ms = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.management.DisplayRotation display_rotation = 39;

    pub fn display_rotation(&self) -> DisplayRotation {
        match self.display_rotation {
            Some(e) => e.enum_value_or(DisplayRotation::North),
            None => DisplayRotation::North,
        }
    }

    pub fn clear_display_rotation(&mut self) {
        self.display_rotation = ::std::option::Option::None;
    }

    pub fn has_display_rotation(&self) -> bool {
        self.display_rotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_rotation(&mut self, v: DisplayRotation) {
        self.display_rotation = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool experimental_features = 40;

    pub fn experimental_features(&self) -> bool {
        self.experimental_features.unwrap_or(false)
    }

    pub fn clear_experimental_features(&mut self) {
        self.experimental_features = ::std::option::Option::None;
    }

    pub fn has_experimental_features(&self) -> bool {
        self.experimental_features.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experimental_features(&mut self, v: bool) {
        self.experimental_features = ::std::option::Option::Some(v);
    }

    // optional bool busy = 41;

    pub fn busy(&self) -> bool {
        self.busy.unwrap_or(false)
    }

    pub fn clear_busy(&mut self) {
        self.busy = ::std::option::Option::None;
    }

    pub fn has_busy(&self) -> bool {
        self.busy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_busy(&mut self, v: bool) {
        self.busy = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.management.HomescreenFormat homescreen_format = 42;

    pub fn homescreen_format(&self) -> HomescreenFormat {
        match self.homescreen_format {
            Some(e) => e.enum_value_or(HomescreenFormat::Toif),
            None => HomescreenFormat::Toif,
        }
    }

    pub fn clear_homescreen_format(&mut self) {
        self.homescreen_format = ::std::option::Option::None;
    }

    pub fn has_homescreen_format(&self) -> bool {
        self.homescreen_format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_homescreen_format(&mut self, v: HomescreenFormat) {
        self.homescreen_format = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool hide_passphrase_from_host = 43;

    pub fn hide_passphrase_from_host(&self) -> bool {
        self.hide_passphrase_from_host.unwrap_or(false)
    }

    pub fn clear_hide_passphrase_from_host(&mut self) {
        self.hide_passphrase_from_host = ::std::option::Option::None;
    }

    pub fn has_hide_passphrase_from_host(&self) -> bool {
        self.hide_passphrase_from_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hide_passphrase_from_host(&mut self, v: bool) {
        self.hide_passphrase_from_host = ::std::option::Option::Some(v);
    }

    // optional string internal_model = 44;

    pub fn internal_model(&self) -> &str {
        match self.internal_model.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_internal_model(&mut self) {
        self.internal_model = ::std::option::Option::None;
    }

    pub fn has_internal_model(&self) -> bool {
        self.internal_model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_internal_model(&mut self, v: ::std::string::String) {
        self.internal_model = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_internal_model(&mut self) -> &mut ::std::string::String {
        if self.internal_model.is_none() {
            self.internal_model = ::std::option::Option::Some(::std::string::String::new());
        }
        self.internal_model.as_mut().unwrap()
    }

    // Take field
    pub fn take_internal_model(&mut self) -> ::std::string::String {
        self.internal_model.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 unit_color = 45;

    pub fn unit_color(&self) -> u32 {
        self.unit_color.unwrap_or(0)
    }

    pub fn clear_unit_color(&mut self) {
        self.unit_color = ::std::option::Option::None;
    }

    pub fn has_unit_color(&self) -> bool {
        self.unit_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_color(&mut self, v: u32) {
        self.unit_color = ::std::option::Option::Some(v);
    }

    // optional bool unit_btconly = 46;

    pub fn unit_btconly(&self) -> bool {
        self.unit_btconly.unwrap_or(false)
    }

    pub fn clear_unit_btconly(&mut self) {
        self.unit_btconly = ::std::option::Option::None;
    }

    pub fn has_unit_btconly(&self) -> bool {
        self.unit_btconly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_btconly(&mut self, v: bool) {
        self.unit_btconly = ::std::option::Option::Some(v);
    }

    // optional uint32 homescreen_width = 47;

    pub fn homescreen_width(&self) -> u32 {
        self.homescreen_width.unwrap_or(0)
    }

    pub fn clear_homescreen_width(&mut self) {
        self.homescreen_width = ::std::option::Option::None;
    }

    pub fn has_homescreen_width(&self) -> bool {
        self.homescreen_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_homescreen_width(&mut self, v: u32) {
        self.homescreen_width = ::std::option::Option::Some(v);
    }

    // optional uint32 homescreen_height = 48;

    pub fn homescreen_height(&self) -> u32 {
        self.homescreen_height.unwrap_or(0)
    }

    pub fn clear_homescreen_height(&mut self) {
        self.homescreen_height = ::std::option::Option::None;
    }

    pub fn has_homescreen_height(&self) -> bool {
        self.homescreen_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_homescreen_height(&mut self, v: u32) {
        self.homescreen_height = ::std::option::Option::Some(v);
    }

    // optional bool bootloader_locked = 49;

    pub fn bootloader_locked(&self) -> bool {
        self.bootloader_locked.unwrap_or(false)
    }

    pub fn clear_bootloader_locked(&mut self) {
        self.bootloader_locked = ::std::option::Option::None;
    }

    pub fn has_bootloader_locked(&self) -> bool {
        self.bootloader_locked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bootloader_locked(&mut self, v: bool) {
        self.bootloader_locked = ::std::option::Option::Some(v);
    }

    // optional bool language_version_matches = 50;

    pub fn language_version_matches(&self) -> bool {
        self.language_version_matches.unwrap_or(true)
    }

    pub fn clear_language_version_matches(&mut self) {
        self.language_version_matches = ::std::option::Option::None;
    }

    pub fn has_language_version_matches(&self) -> bool {
        self.language_version_matches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language_version_matches(&mut self, v: bool) {
        self.language_version_matches = ::std::option::Option::Some(v);
    }

    // optional uint32 unit_packaging = 51;

    pub fn unit_packaging(&self) -> u32 {
        self.unit_packaging.unwrap_or(0)
    }

    pub fn clear_unit_packaging(&mut self) {
        self.unit_packaging = ::std::option::Option::None;
    }

    pub fn has_unit_packaging(&self) -> bool {
        self.unit_packaging.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_packaging(&mut self, v: u32) {
        self.unit_packaging = ::std::option::Option::Some(v);
    }

    // optional bool haptic_feedback = 52;

    pub fn haptic_feedback(&self) -> bool {
        self.haptic_feedback.unwrap_or(false)
    }

    pub fn clear_haptic_feedback(&mut self) {
        self.haptic_feedback = ::std::option::Option::None;
    }

    pub fn has_haptic_feedback(&self) -> bool {
        self.haptic_feedback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_haptic_feedback(&mut self, v: bool) {
        self.haptic_feedback = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.management.RecoveryType recovery_type = 53;

    pub fn recovery_type(&self) -> RecoveryType {
        match self.recovery_type {
            Some(e) => e.enum_value_or(RecoveryType::NormalRecovery),
            None => RecoveryType::NormalRecovery,
        }
    }

    pub fn clear_recovery_type(&mut self) {
        self.recovery_type = ::std::option::Option::None;
    }

    pub fn has_recovery_type(&self) -> bool {
        self.recovery_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recovery_type(&mut self, v: RecoveryType) {
        self.recovery_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 optiga_sec = 54;

    pub fn optiga_sec(&self) -> u32 {
        self.optiga_sec.unwrap_or(0)
    }

    pub fn clear_optiga_sec(&mut self) {
        self.optiga_sec = ::std::option::Option::None;
    }

    pub fn has_optiga_sec(&self) -> bool {
        self.optiga_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optiga_sec(&mut self, v: u32) {
        self.optiga_sec = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(52);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vendor",
            |m: &Features| { &m.vendor },
            |m: &mut Features| { &mut m.vendor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "major_version",
            |m: &Features| { &m.major_version },
            |m: &mut Features| { &mut m.major_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minor_version",
            |m: &Features| { &m.minor_version },
            |m: &mut Features| { &mut m.minor_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "patch_version",
            |m: &Features| { &m.patch_version },
            |m: &mut Features| { &mut m.patch_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bootloader_mode",
            |m: &Features| { &m.bootloader_mode },
            |m: &mut Features| { &mut m.bootloader_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_id",
            |m: &Features| { &m.device_id },
            |m: &mut Features| { &mut m.device_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pin_protection",
            |m: &Features| { &m.pin_protection },
            |m: &mut Features| { &mut m.pin_protection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "passphrase_protection",
            |m: &Features| { &m.passphrase_protection },
            |m: &mut Features| { &mut m.passphrase_protection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &Features| { &m.language },
            |m: &mut Features| { &mut m.language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "label",
            |m: &Features| { &m.label },
            |m: &mut Features| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initialized",
            |m: &Features| { &m.initialized },
            |m: &mut Features| { &mut m.initialized },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revision",
            |m: &Features| { &m.revision },
            |m: &mut Features| { &mut m.revision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bootloader_hash",
            |m: &Features| { &m.bootloader_hash },
            |m: &mut Features| { &mut m.bootloader_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "imported",
            |m: &Features| { &m.imported },
            |m: &mut Features| { &mut m.imported },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unlocked",
            |m: &Features| { &m.unlocked },
            |m: &mut Features| { &mut m.unlocked },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "_passphrase_cached",
            |m: &Features| { &m._passphrase_cached },
            |m: &mut Features| { &mut m._passphrase_cached },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "firmware_present",
            |m: &Features| { &m.firmware_present },
            |m: &mut Features| { &mut m.firmware_present },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "backup_availability",
            |m: &Features| { &m.backup_availability },
            |m: &mut Features| { &mut m.backup_availability },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &Features| { &m.flags },
            |m: &mut Features| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "model",
            |m: &Features| { &m.model },
            |m: &mut Features| { &mut m.model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fw_major",
            |m: &Features| { &m.fw_major },
            |m: &mut Features| { &mut m.fw_major },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fw_minor",
            |m: &Features| { &m.fw_minor },
            |m: &mut Features| { &mut m.fw_minor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fw_patch",
            |m: &Features| { &m.fw_patch },
            |m: &mut Features| { &mut m.fw_patch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fw_vendor",
            |m: &Features| { &m.fw_vendor },
            |m: &mut Features| { &mut m.fw_vendor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unfinished_backup",
            |m: &Features| { &m.unfinished_backup },
            |m: &mut Features| { &mut m.unfinished_backup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "no_backup",
            |m: &Features| { &m.no_backup },
            |m: &mut Features| { &mut m.no_backup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recovery_status",
            |m: &Features| { &m.recovery_status },
            |m: &mut Features| { &mut m.recovery_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "capabilities",
            |m: &Features| { &m.capabilities },
            |m: &mut Features| { &mut m.capabilities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "backup_type",
            |m: &Features| { &m.backup_type },
            |m: &mut Features| { &mut m.backup_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sd_card_present",
            |m: &Features| { &m.sd_card_present },
            |m: &mut Features| { &mut m.sd_card_present },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sd_protection",
            |m: &Features| { &m.sd_protection },
            |m: &mut Features| { &mut m.sd_protection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wipe_code_protection",
            |m: &Features| { &m.wipe_code_protection },
            |m: &mut Features| { &mut m.wipe_code_protection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session_id",
            |m: &Features| { &m.session_id },
            |m: &mut Features| { &mut m.session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "passphrase_always_on_device",
            |m: &Features| { &m.passphrase_always_on_device },
            |m: &mut Features| { &mut m.passphrase_always_on_device },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "safety_checks",
            |m: &Features| { &m.safety_checks },
            |m: &mut Features| { &mut m.safety_checks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "auto_lock_delay_ms",
            |m: &Features| { &m.auto_lock_delay_ms },
            |m: &mut Features| { &mut m.auto_lock_delay_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_rotation",
            |m: &Features| { &m.display_rotation },
            |m: &mut Features| { &mut m.display_rotation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "experimental_features",
            |m: &Features| { &m.experimental_features },
            |m: &mut Features| { &mut m.experimental_features },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "busy",
            |m: &Features| { &m.busy },
            |m: &mut Features| { &mut m.busy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "homescreen_format",
            |m: &Features| { &m.homescreen_format },
            |m: &mut Features| { &mut m.homescreen_format },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hide_passphrase_from_host",
            |m: &Features| { &m.hide_passphrase_from_host },
            |m: &mut Features| { &mut m.hide_passphrase_from_host },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "internal_model",
            |m: &Features| { &m.internal_model },
            |m: &mut Features| { &mut m.internal_model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_color",
            |m: &Features| { &m.unit_color },
            |m: &mut Features| { &mut m.unit_color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_btconly",
            |m: &Features| { &m.unit_btconly },
            |m: &mut Features| { &mut m.unit_btconly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "homescreen_width",
            |m: &Features| { &m.homescreen_width },
            |m: &mut Features| { &mut m.homescreen_width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "homescreen_height",
            |m: &Features| { &m.homescreen_height },
            |m: &mut Features| { &mut m.homescreen_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bootloader_locked",
            |m: &Features| { &m.bootloader_locked },
            |m: &mut Features| { &mut m.bootloader_locked },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language_version_matches",
            |m: &Features| { &m.language_version_matches },
            |m: &mut Features| { &mut m.language_version_matches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_packaging",
            |m: &Features| { &m.unit_packaging },
            |m: &mut Features| { &mut m.unit_packaging },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "haptic_feedback",
            |m: &Features| { &m.haptic_feedback },
            |m: &mut Features| { &mut m.haptic_feedback },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recovery_type",
            |m: &Features| { &m.recovery_type },
            |m: &mut Features| { &mut m.recovery_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "optiga_sec",
            |m: &Features| { &m.optiga_sec },
            |m: &mut Features| { &mut m.optiga_sec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Features>(
            "Features",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Features {
    const NAME: &'static str = "Features";

    fn is_initialized(&self) -> bool {
        if self.major_version.is_none() {
            return false;
        }
        if self.minor_version.is_none() {
            return false;
        }
        if self.patch_version.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.vendor = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.major_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.minor_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.patch_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.bootloader_mode = ::std::option::Option::Some(is.read_bool()?);
                },
                50 => {
                    self.device_id = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.pin_protection = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.passphrase_protection = ::std::option::Option::Some(is.read_bool()?);
                },
                74 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.label = ::std::option::Option::Some(is.read_string()?);
                },
                96 => {
                    self.initialized = ::std::option::Option::Some(is.read_bool()?);
                },
                106 => {
                    self.revision = ::std::option::Option::Some(is.read_bytes()?);
                },
                114 => {
                    self.bootloader_hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                120 => {
                    self.imported = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.unlocked = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self._passphrase_cached = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.firmware_present = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.backup_availability = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                160 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                170 => {
                    self.model = ::std::option::Option::Some(is.read_string()?);
                },
                176 => {
                    self.fw_major = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.fw_minor = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.fw_patch = ::std::option::Option::Some(is.read_uint32()?);
                },
                202 => {
                    self.fw_vendor = ::std::option::Option::Some(is.read_string()?);
                },
                216 => {
                    self.unfinished_backup = ::std::option::Option::Some(is.read_bool()?);
                },
                224 => {
                    self.no_backup = ::std::option::Option::Some(is.read_bool()?);
                },
                232 => {
                    self.recovery_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                240 => {
                    self.capabilities.push(is.read_enum_or_unknown()?);
                },
                242 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.capabilities)?
                },
                248 => {
                    self.backup_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                256 => {
                    self.sd_card_present = ::std::option::Option::Some(is.read_bool()?);
                },
                264 => {
                    self.sd_protection = ::std::option::Option::Some(is.read_bool()?);
                },
                272 => {
                    self.wipe_code_protection = ::std::option::Option::Some(is.read_bool()?);
                },
                282 => {
                    self.session_id = ::std::option::Option::Some(is.read_bytes()?);
                },
                288 => {
                    self.passphrase_always_on_device = ::std::option::Option::Some(is.read_bool()?);
                },
                296 => {
                    self.safety_checks = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                304 => {
                    self.auto_lock_delay_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                312 => {
                    self.display_rotation = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                320 => {
                    self.experimental_features = ::std::option::Option::Some(is.read_bool()?);
                },
                328 => {
                    self.busy = ::std::option::Option::Some(is.read_bool()?);
                },
                336 => {
                    self.homescreen_format = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                344 => {
                    self.hide_passphrase_from_host = ::std::option::Option::Some(is.read_bool()?);
                },
                354 => {
                    self.internal_model = ::std::option::Option::Some(is.read_string()?);
                },
                360 => {
                    self.unit_color = ::std::option::Option::Some(is.read_uint32()?);
                },
                368 => {
                    self.unit_btconly = ::std::option::Option::Some(is.read_bool()?);
                },
                376 => {
                    self.homescreen_width = ::std::option::Option::Some(is.read_uint32()?);
                },
                384 => {
                    self.homescreen_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                392 => {
                    self.bootloader_locked = ::std::option::Option::Some(is.read_bool()?);
                },
                400 => {
                    self.language_version_matches = ::std::option::Option::Some(is.read_bool()?);
                },
                408 => {
                    self.unit_packaging = ::std::option::Option::Some(is.read_uint32()?);
                },
                416 => {
                    self.haptic_feedback = ::std::option::Option::Some(is.read_bool()?);
                },
                424 => {
                    self.recovery_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                432 => {
                    self.optiga_sec = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.vendor.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.major_version {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.minor_version {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.patch_version {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.bootloader_mode {
            my_size += 1 + 1;
        }
        if let Some(v) = self.device_id.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.pin_protection {
            my_size += 1 + 1;
        }
        if let Some(v) = self.passphrase_protection {
            my_size += 1 + 1;
        }
        if let Some(v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.initialized {
            my_size += 1 + 1;
        }
        if let Some(v) = self.revision.as_ref() {
            my_size += ::protobuf::rt::bytes_size(13, &v);
        }
        if let Some(v) = self.bootloader_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(14, &v);
        }
        if let Some(v) = self.imported {
            my_size += 1 + 1;
        }
        if let Some(v) = self.unlocked {
            my_size += 2 + 1;
        }
        if let Some(v) = self._passphrase_cached {
            my_size += 2 + 1;
        }
        if let Some(v) = self.firmware_present {
            my_size += 2 + 1;
        }
        if let Some(v) = self.backup_availability {
            my_size += ::protobuf::rt::int32_size(19, v.value());
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.model.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(v) = self.fw_major {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.fw_minor {
            my_size += ::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.fw_patch {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.fw_vendor.as_ref() {
            my_size += ::protobuf::rt::string_size(25, &v);
        }
        if let Some(v) = self.unfinished_backup {
            my_size += 2 + 1;
        }
        if let Some(v) = self.no_backup {
            my_size += 2 + 1;
        }
        if let Some(v) = self.recovery_status {
            my_size += ::protobuf::rt::int32_size(29, v.value());
        }
        for value in &self.capabilities {
            my_size += ::protobuf::rt::int32_size(30, value.value());
        };
        if let Some(v) = self.backup_type {
            my_size += ::protobuf::rt::int32_size(31, v.value());
        }
        if let Some(v) = self.sd_card_present {
            my_size += 2 + 1;
        }
        if let Some(v) = self.sd_protection {
            my_size += 2 + 1;
        }
        if let Some(v) = self.wipe_code_protection {
            my_size += 2 + 1;
        }
        if let Some(v) = self.session_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(35, &v);
        }
        if let Some(v) = self.passphrase_always_on_device {
            my_size += 2 + 1;
        }
        if let Some(v) = self.safety_checks {
            my_size += ::protobuf::rt::int32_size(37, v.value());
        }
        if let Some(v) = self.auto_lock_delay_ms {
            my_size += ::protobuf::rt::uint32_size(38, v);
        }
        if let Some(v) = self.display_rotation {
            my_size += ::protobuf::rt::int32_size(39, v.value());
        }
        if let Some(v) = self.experimental_features {
            my_size += 2 + 1;
        }
        if let Some(v) = self.busy {
            my_size += 2 + 1;
        }
        if let Some(v) = self.homescreen_format {
            my_size += ::protobuf::rt::int32_size(42, v.value());
        }
        if let Some(v) = self.hide_passphrase_from_host {
            my_size += 2 + 1;
        }
        if let Some(v) = self.internal_model.as_ref() {
            my_size += ::protobuf::rt::string_size(44, &v);
        }
        if let Some(v) = self.unit_color {
            my_size += ::protobuf::rt::uint32_size(45, v);
        }
        if let Some(v) = self.unit_btconly {
            my_size += 2 + 1;
        }
        if let Some(v) = self.homescreen_width {
            my_size += ::protobuf::rt::uint32_size(47, v);
        }
        if let Some(v) = self.homescreen_height {
            my_size += ::protobuf::rt::uint32_size(48, v);
        }
        if let Some(v) = self.bootloader_locked {
            my_size += 2 + 1;
        }
        if let Some(v) = self.language_version_matches {
            my_size += 2 + 1;
        }
        if let Some(v) = self.unit_packaging {
            my_size += ::protobuf::rt::uint32_size(51, v);
        }
        if let Some(v) = self.haptic_feedback {
            my_size += 2 + 1;
        }
        if let Some(v) = self.recovery_type {
            my_size += ::protobuf::rt::int32_size(53, v.value());
        }
        if let Some(v) = self.optiga_sec {
            my_size += ::protobuf::rt::uint32_size(54, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.vendor.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.major_version {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.minor_version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.patch_version {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.bootloader_mode {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.device_id.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.pin_protection {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.passphrase_protection {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.language.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.label.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.initialized {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.revision.as_ref() {
            os.write_bytes(13, v)?;
        }
        if let Some(v) = self.bootloader_hash.as_ref() {
            os.write_bytes(14, v)?;
        }
        if let Some(v) = self.imported {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.unlocked {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self._passphrase_cached {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.firmware_present {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.backup_availability {
            os.write_enum(19, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.model.as_ref() {
            os.write_string(21, v)?;
        }
        if let Some(v) = self.fw_major {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.fw_minor {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.fw_patch {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.fw_vendor.as_ref() {
            os.write_string(25, v)?;
        }
        if let Some(v) = self.unfinished_backup {
            os.write_bool(27, v)?;
        }
        if let Some(v) = self.no_backup {
            os.write_bool(28, v)?;
        }
        if let Some(v) = self.recovery_status {
            os.write_enum(29, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.capabilities {
            os.write_enum(30, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.backup_type {
            os.write_enum(31, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.sd_card_present {
            os.write_bool(32, v)?;
        }
        if let Some(v) = self.sd_protection {
            os.write_bool(33, v)?;
        }
        if let Some(v) = self.wipe_code_protection {
            os.write_bool(34, v)?;
        }
        if let Some(v) = self.session_id.as_ref() {
            os.write_bytes(35, v)?;
        }
        if let Some(v) = self.passphrase_always_on_device {
            os.write_bool(36, v)?;
        }
        if let Some(v) = self.safety_checks {
            os.write_enum(37, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.auto_lock_delay_ms {
            os.write_uint32(38, v)?;
        }
        if let Some(v) = self.display_rotation {
            os.write_enum(39, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.experimental_features {
            os.write_bool(40, v)?;
        }
        if let Some(v) = self.busy {
            os.write_bool(41, v)?;
        }
        if let Some(v) = self.homescreen_format {
            os.write_enum(42, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.hide_passphrase_from_host {
            os.write_bool(43, v)?;
        }
        if let Some(v) = self.internal_model.as_ref() {
            os.write_string(44, v)?;
        }
        if let Some(v) = self.unit_color {
            os.write_uint32(45, v)?;
        }
        if let Some(v) = self.unit_btconly {
            os.write_bool(46, v)?;
        }
        if let Some(v) = self.homescreen_width {
            os.write_uint32(47, v)?;
        }
        if let Some(v) = self.homescreen_height {
            os.write_uint32(48, v)?;
        }
        if let Some(v) = self.bootloader_locked {
            os.write_bool(49, v)?;
        }
        if let Some(v) = self.language_version_matches {
            os.write_bool(50, v)?;
        }
        if let Some(v) = self.unit_packaging {
            os.write_uint32(51, v)?;
        }
        if let Some(v) = self.haptic_feedback {
            os.write_bool(52, v)?;
        }
        if let Some(v) = self.recovery_type {
            os.write_enum(53, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.optiga_sec {
            os.write_uint32(54, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Features {
        Features::new()
    }

    fn clear(&mut self) {
        self.vendor = ::std::option::Option::None;
        self.major_version = ::std::option::Option::None;
        self.minor_version = ::std::option::Option::None;
        self.patch_version = ::std::option::Option::None;
        self.bootloader_mode = ::std::option::Option::None;
        self.device_id = ::std::option::Option::None;
        self.pin_protection = ::std::option::Option::None;
        self.passphrase_protection = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.label = ::std::option::Option::None;
        self.initialized = ::std::option::Option::None;
        self.revision = ::std::option::Option::None;
        self.bootloader_hash = ::std::option::Option::None;
        self.imported = ::std::option::Option::None;
        self.unlocked = ::std::option::Option::None;
        self._passphrase_cached = ::std::option::Option::None;
        self.firmware_present = ::std::option::Option::None;
        self.backup_availability = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.model = ::std::option::Option::None;
        self.fw_major = ::std::option::Option::None;
        self.fw_minor = ::std::option::Option::None;
        self.fw_patch = ::std::option::Option::None;
        self.fw_vendor = ::std::option::Option::None;
        self.unfinished_backup = ::std::option::Option::None;
        self.no_backup = ::std::option::Option::None;
        self.recovery_status = ::std::option::Option::None;
        self.capabilities.clear();
        self.backup_type = ::std::option::Option::None;
        self.sd_card_present = ::std::option::Option::None;
        self.sd_protection = ::std::option::Option::None;
        self.wipe_code_protection = ::std::option::Option::None;
        self.session_id = ::std::option::Option::None;
        self.passphrase_always_on_device = ::std::option::Option::None;
        self.safety_checks = ::std::option::Option::None;
        self.auto_lock_delay_ms = ::std::option::Option::None;
        self.display_rotation = ::std::option::Option::None;
        self.experimental_features = ::std::option::Option::None;
        self.busy = ::std::option::Option::None;
        self.homescreen_format = ::std::option::Option::None;
        self.hide_passphrase_from_host = ::std::option::Option::None;
        self.internal_model = ::std::option::Option::None;
        self.unit_color = ::std::option::Option::None;
        self.unit_btconly = ::std::option::Option::None;
        self.homescreen_width = ::std::option::Option::None;
        self.homescreen_height = ::std::option::Option::None;
        self.bootloader_locked = ::std::option::Option::None;
        self.language_version_matches = ::std::option::Option::None;
        self.unit_packaging = ::std::option::Option::None;
        self.haptic_feedback = ::std::option::Option::None;
        self.recovery_type = ::std::option::Option::None;
        self.optiga_sec = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Features {
        static instance: Features = Features {
            vendor: ::std::option::Option::None,
            major_version: ::std::option::Option::None,
            minor_version: ::std::option::Option::None,
            patch_version: ::std::option::Option::None,
            bootloader_mode: ::std::option::Option::None,
            device_id: ::std::option::Option::None,
            pin_protection: ::std::option::Option::None,
            passphrase_protection: ::std::option::Option::None,
            language: ::std::option::Option::None,
            label: ::std::option::Option::None,
            initialized: ::std::option::Option::None,
            revision: ::std::option::Option::None,
            bootloader_hash: ::std::option::Option::None,
            imported: ::std::option::Option::None,
            unlocked: ::std::option::Option::None,
            _passphrase_cached: ::std::option::Option::None,
            firmware_present: ::std::option::Option::None,
            backup_availability: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            model: ::std::option::Option::None,
            fw_major: ::std::option::Option::None,
            fw_minor: ::std::option::Option::None,
            fw_patch: ::std::option::Option::None,
            fw_vendor: ::std::option::Option::None,
            unfinished_backup: ::std::option::Option::None,
            no_backup: ::std::option::Option::None,
            recovery_status: ::std::option::Option::None,
            capabilities: ::std::vec::Vec::new(),
            backup_type: ::std::option::Option::None,
            sd_card_present: ::std::option::Option::None,
            sd_protection: ::std::option::Option::None,
            wipe_code_protection: ::std::option::Option::None,
            session_id: ::std::option::Option::None,
            passphrase_always_on_device: ::std::option::Option::None,
            safety_checks: ::std::option::Option::None,
            auto_lock_delay_ms: ::std::option::Option::None,
            display_rotation: ::std::option::Option::None,
            experimental_features: ::std::option::Option::None,
            busy: ::std::option::Option::None,
            homescreen_format: ::std::option::Option::None,
            hide_passphrase_from_host: ::std::option::Option::None,
            internal_model: ::std::option::Option::None,
            unit_color: ::std::option::Option::None,
            unit_btconly: ::std::option::Option::None,
            homescreen_width: ::std::option::Option::None,
            homescreen_height: ::std::option::Option::None,
            bootloader_locked: ::std::option::Option::None,
            language_version_matches: ::std::option::Option::None,
            unit_packaging: ::std::option::Option::None,
            haptic_feedback: ::std::option::Option::None,
            recovery_type: ::std::option::Option::None,
            optiga_sec: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Features {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Features").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Features {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Features {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Features`
pub mod features {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:hw.trezor.messages.management.Features.BackupAvailability)
    pub enum BackupAvailability {
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.BackupAvailability.NotAvailable)
        NotAvailable = 0,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.BackupAvailability.Required)
        Required = 1,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.BackupAvailability.Available)
        Available = 2,
    }

    impl ::protobuf::Enum for BackupAvailability {
        const NAME: &'static str = "BackupAvailability";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<BackupAvailability> {
            match value {
                0 => ::std::option::Option::Some(BackupAvailability::NotAvailable),
                1 => ::std::option::Option::Some(BackupAvailability::Required),
                2 => ::std::option::Option::Some(BackupAvailability::Available),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<BackupAvailability> {
            match str {
                "NotAvailable" => ::std::option::Option::Some(BackupAvailability::NotAvailable),
                "Required" => ::std::option::Option::Some(BackupAvailability::Required),
                "Available" => ::std::option::Option::Some(BackupAvailability::Available),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [BackupAvailability] = &[
            BackupAvailability::NotAvailable,
            BackupAvailability::Required,
            BackupAvailability::Available,
        ];
    }

    impl ::protobuf::EnumFull for BackupAvailability {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Features.BackupAvailability").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for BackupAvailability {
        fn default() -> Self {
            BackupAvailability::NotAvailable
        }
    }

    impl BackupAvailability {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BackupAvailability>("Features.BackupAvailability")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:hw.trezor.messages.management.Features.RecoveryStatus)
    pub enum RecoveryStatus {
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.RecoveryStatus.Nothing)
        Nothing = 0,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.RecoveryStatus.Recovery)
        Recovery = 1,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.RecoveryStatus.Backup)
        Backup = 2,
    }

    impl ::protobuf::Enum for RecoveryStatus {
        const NAME: &'static str = "RecoveryStatus";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<RecoveryStatus> {
            match value {
                0 => ::std::option::Option::Some(RecoveryStatus::Nothing),
                1 => ::std::option::Option::Some(RecoveryStatus::Recovery),
                2 => ::std::option::Option::Some(RecoveryStatus::Backup),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<RecoveryStatus> {
            match str {
                "Nothing" => ::std::option::Option::Some(RecoveryStatus::Nothing),
                "Recovery" => ::std::option::Option::Some(RecoveryStatus::Recovery),
                "Backup" => ::std::option::Option::Some(RecoveryStatus::Backup),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [RecoveryStatus] = &[
            RecoveryStatus::Nothing,
            RecoveryStatus::Recovery,
            RecoveryStatus::Backup,
        ];
    }

    impl ::protobuf::EnumFull for RecoveryStatus {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Features.RecoveryStatus").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for RecoveryStatus {
        fn default() -> Self {
            RecoveryStatus::Nothing
        }
    }

    impl RecoveryStatus {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<RecoveryStatus>("Features.RecoveryStatus")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:hw.trezor.messages.management.Features.Capability)
    pub enum Capability {
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.Capability.Capability_Bitcoin)
        Capability_Bitcoin = 1,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.Capability.Capability_Bitcoin_like)
        Capability_Bitcoin_like = 2,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.Capability.Capability_Binance)
        Capability_Binance = 3,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.Capability.Capability_Cardano)
        Capability_Cardano = 4,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.Capability.Capability_Crypto)
        Capability_Crypto = 5,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.Capability.Capability_EOS)
        Capability_EOS = 6,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.Capability.Capability_Ethereum)
        Capability_Ethereum = 7,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.Capability.Capability_Lisk)
        Capability_Lisk = 8,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.Capability.Capability_Monero)
        Capability_Monero = 9,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.Capability.Capability_NEM)
        Capability_NEM = 10,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.Capability.Capability_Ripple)
        Capability_Ripple = 11,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.Capability.Capability_Stellar)
        Capability_Stellar = 12,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.Capability.Capability_Tezos)
        Capability_Tezos = 13,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.Capability.Capability_U2F)
        Capability_U2F = 14,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.Capability.Capability_Shamir)
        Capability_Shamir = 15,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.Capability.Capability_ShamirGroups)
        Capability_ShamirGroups = 16,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.Capability.Capability_PassphraseEntry)
        Capability_PassphraseEntry = 17,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.Capability.Capability_Solana)
        Capability_Solana = 18,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.Capability.Capability_Translations)
        Capability_Translations = 19,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.Capability.Capability_Brightness)
        Capability_Brightness = 20,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.Features.Capability.Capability_Haptic)
        Capability_Haptic = 21,
    }

    impl ::protobuf::Enum for Capability {
        const NAME: &'static str = "Capability";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Capability> {
            match value {
                1 => ::std::option::Option::Some(Capability::Capability_Bitcoin),
                2 => ::std::option::Option::Some(Capability::Capability_Bitcoin_like),
                3 => ::std::option::Option::Some(Capability::Capability_Binance),
                4 => ::std::option::Option::Some(Capability::Capability_Cardano),
                5 => ::std::option::Option::Some(Capability::Capability_Crypto),
                6 => ::std::option::Option::Some(Capability::Capability_EOS),
                7 => ::std::option::Option::Some(Capability::Capability_Ethereum),
                8 => ::std::option::Option::Some(Capability::Capability_Lisk),
                9 => ::std::option::Option::Some(Capability::Capability_Monero),
                10 => ::std::option::Option::Some(Capability::Capability_NEM),
                11 => ::std::option::Option::Some(Capability::Capability_Ripple),
                12 => ::std::option::Option::Some(Capability::Capability_Stellar),
                13 => ::std::option::Option::Some(Capability::Capability_Tezos),
                14 => ::std::option::Option::Some(Capability::Capability_U2F),
                15 => ::std::option::Option::Some(Capability::Capability_Shamir),
                16 => ::std::option::Option::Some(Capability::Capability_ShamirGroups),
                17 => ::std::option::Option::Some(Capability::Capability_PassphraseEntry),
                18 => ::std::option::Option::Some(Capability::Capability_Solana),
                19 => ::std::option::Option::Some(Capability::Capability_Translations),
                20 => ::std::option::Option::Some(Capability::Capability_Brightness),
                21 => ::std::option::Option::Some(Capability::Capability_Haptic),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Capability> {
            match str {
                "Capability_Bitcoin" => ::std::option::Option::Some(Capability::Capability_Bitcoin),
                "Capability_Bitcoin_like" => ::std::option::Option::Some(Capability::Capability_Bitcoin_like),
                "Capability_Binance" => ::std::option::Option::Some(Capability::Capability_Binance),
                "Capability_Cardano" => ::std::option::Option::Some(Capability::Capability_Cardano),
                "Capability_Crypto" => ::std::option::Option::Some(Capability::Capability_Crypto),
                "Capability_EOS" => ::std::option::Option::Some(Capability::Capability_EOS),
                "Capability_Ethereum" => ::std::option::Option::Some(Capability::Capability_Ethereum),
                "Capability_Lisk" => ::std::option::Option::Some(Capability::Capability_Lisk),
                "Capability_Monero" => ::std::option::Option::Some(Capability::Capability_Monero),
                "Capability_NEM" => ::std::option::Option::Some(Capability::Capability_NEM),
                "Capability_Ripple" => ::std::option::Option::Some(Capability::Capability_Ripple),
                "Capability_Stellar" => ::std::option::Option::Some(Capability::Capability_Stellar),
                "Capability_Tezos" => ::std::option::Option::Some(Capability::Capability_Tezos),
                "Capability_U2F" => ::std::option::Option::Some(Capability::Capability_U2F),
                "Capability_Shamir" => ::std::option::Option::Some(Capability::Capability_Shamir),
                "Capability_ShamirGroups" => ::std::option::Option::Some(Capability::Capability_ShamirGroups),
                "Capability_PassphraseEntry" => ::std::option::Option::Some(Capability::Capability_PassphraseEntry),
                "Capability_Solana" => ::std::option::Option::Some(Capability::Capability_Solana),
                "Capability_Translations" => ::std::option::Option::Some(Capability::Capability_Translations),
                "Capability_Brightness" => ::std::option::Option::Some(Capability::Capability_Brightness),
                "Capability_Haptic" => ::std::option::Option::Some(Capability::Capability_Haptic),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Capability] = &[
            Capability::Capability_Bitcoin,
            Capability::Capability_Bitcoin_like,
            Capability::Capability_Binance,
            Capability::Capability_Cardano,
            Capability::Capability_Crypto,
            Capability::Capability_EOS,
            Capability::Capability_Ethereum,
            Capability::Capability_Lisk,
            Capability::Capability_Monero,
            Capability::Capability_NEM,
            Capability::Capability_Ripple,
            Capability::Capability_Stellar,
            Capability::Capability_Tezos,
            Capability::Capability_U2F,
            Capability::Capability_Shamir,
            Capability::Capability_ShamirGroups,
            Capability::Capability_PassphraseEntry,
            Capability::Capability_Solana,
            Capability::Capability_Translations,
            Capability::Capability_Brightness,
            Capability::Capability_Haptic,
        ];
    }

    impl ::protobuf::EnumFull for Capability {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Features.Capability").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Capability::Capability_Bitcoin => 0,
                Capability::Capability_Bitcoin_like => 1,
                Capability::Capability_Binance => 2,
                Capability::Capability_Cardano => 3,
                Capability::Capability_Crypto => 4,
                Capability::Capability_EOS => 5,
                Capability::Capability_Ethereum => 6,
                Capability::Capability_Lisk => 7,
                Capability::Capability_Monero => 8,
                Capability::Capability_NEM => 9,
                Capability::Capability_Ripple => 10,
                Capability::Capability_Stellar => 11,
                Capability::Capability_Tezos => 12,
                Capability::Capability_U2F => 13,
                Capability::Capability_Shamir => 14,
                Capability::Capability_ShamirGroups => 15,
                Capability::Capability_PassphraseEntry => 16,
                Capability::Capability_Solana => 17,
                Capability::Capability_Translations => 18,
                Capability::Capability_Brightness => 19,
                Capability::Capability_Haptic => 20,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Capability {
        fn default() -> Self {
            Capability::Capability_Bitcoin
        }
    }

    impl Capability {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Capability>("Features.Capability")
        }
    }
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.LockDevice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LockDevice {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.LockDevice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LockDevice {
    fn default() -> &'a LockDevice {
        <LockDevice as ::protobuf::Message>::default_instance()
    }
}

impl LockDevice {
    pub fn new() -> LockDevice {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LockDevice>(
            "LockDevice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LockDevice {
    const NAME: &'static str = "LockDevice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LockDevice {
        LockDevice::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LockDevice {
        static instance: LockDevice = LockDevice {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LockDevice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LockDevice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LockDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LockDevice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.SetBusy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetBusy {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.SetBusy.expiry_ms)
    pub expiry_ms: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.SetBusy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetBusy {
    fn default() -> &'a SetBusy {
        <SetBusy as ::protobuf::Message>::default_instance()
    }
}

impl SetBusy {
    pub fn new() -> SetBusy {
        ::std::default::Default::default()
    }

    // optional uint32 expiry_ms = 1;

    pub fn expiry_ms(&self) -> u32 {
        self.expiry_ms.unwrap_or(0)
    }

    pub fn clear_expiry_ms(&mut self) {
        self.expiry_ms = ::std::option::Option::None;
    }

    pub fn has_expiry_ms(&self) -> bool {
        self.expiry_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiry_ms(&mut self, v: u32) {
        self.expiry_ms = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiry_ms",
            |m: &SetBusy| { &m.expiry_ms },
            |m: &mut SetBusy| { &mut m.expiry_ms },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetBusy>(
            "SetBusy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetBusy {
    const NAME: &'static str = "SetBusy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.expiry_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.expiry_ms {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.expiry_ms {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetBusy {
        SetBusy::new()
    }

    fn clear(&mut self) {
        self.expiry_ms = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetBusy {
        static instance: SetBusy = SetBusy {
            expiry_ms: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetBusy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetBusy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetBusy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetBusy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.EndSession)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EndSession {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.EndSession.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EndSession {
    fn default() -> &'a EndSession {
        <EndSession as ::protobuf::Message>::default_instance()
    }
}

impl EndSession {
    pub fn new() -> EndSession {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EndSession>(
            "EndSession",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EndSession {
    const NAME: &'static str = "EndSession";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EndSession {
        EndSession::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EndSession {
        static instance: EndSession = EndSession {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EndSession {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EndSession").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EndSession {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EndSession {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.ApplySettings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ApplySettings {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ApplySettings.language)
    pub language: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ApplySettings.label)
    pub label: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ApplySettings.use_passphrase)
    pub use_passphrase: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ApplySettings.homescreen)
    pub homescreen: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ApplySettings._passphrase_source)
    pub _passphrase_source: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ApplySettings.auto_lock_delay_ms)
    pub auto_lock_delay_ms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ApplySettings.display_rotation)
    pub display_rotation: ::std::option::Option<::protobuf::EnumOrUnknown<DisplayRotation>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ApplySettings.passphrase_always_on_device)
    pub passphrase_always_on_device: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ApplySettings.safety_checks)
    pub safety_checks: ::std::option::Option<::protobuf::EnumOrUnknown<SafetyCheckLevel>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ApplySettings.experimental_features)
    pub experimental_features: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ApplySettings.hide_passphrase_from_host)
    pub hide_passphrase_from_host: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ApplySettings.haptic_feedback)
    pub haptic_feedback: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.ApplySettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ApplySettings {
    fn default() -> &'a ApplySettings {
        <ApplySettings as ::protobuf::Message>::default_instance()
    }
}

impl ApplySettings {
    pub fn new() -> ApplySettings {
        ::std::default::Default::default()
    }

    // optional string language = 1;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string label = 2;

    pub fn label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_label(&mut self) {
        self.label = ::std::option::Option::None;
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label = ::std::option::Option::Some(::std::string::String::new());
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool use_passphrase = 3;

    pub fn use_passphrase(&self) -> bool {
        self.use_passphrase.unwrap_or(false)
    }

    pub fn clear_use_passphrase(&mut self) {
        self.use_passphrase = ::std::option::Option::None;
    }

    pub fn has_use_passphrase(&self) -> bool {
        self.use_passphrase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_passphrase(&mut self, v: bool) {
        self.use_passphrase = ::std::option::Option::Some(v);
    }

    // optional bytes homescreen = 4;

    pub fn homescreen(&self) -> &[u8] {
        match self.homescreen.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_homescreen(&mut self) {
        self.homescreen = ::std::option::Option::None;
    }

    pub fn has_homescreen(&self) -> bool {
        self.homescreen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_homescreen(&mut self, v: ::std::vec::Vec<u8>) {
        self.homescreen = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_homescreen(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.homescreen.is_none() {
            self.homescreen = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.homescreen.as_mut().unwrap()
    }

    // Take field
    pub fn take_homescreen(&mut self) -> ::std::vec::Vec<u8> {
        self.homescreen.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 _passphrase_source = 5;

    pub fn _passphrase_source(&self) -> u32 {
        self._passphrase_source.unwrap_or(0)
    }

    pub fn clear__passphrase_source(&mut self) {
        self._passphrase_source = ::std::option::Option::None;
    }

    pub fn has__passphrase_source(&self) -> bool {
        self._passphrase_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set__passphrase_source(&mut self, v: u32) {
        self._passphrase_source = ::std::option::Option::Some(v);
    }

    // optional uint32 auto_lock_delay_ms = 6;

    pub fn auto_lock_delay_ms(&self) -> u32 {
        self.auto_lock_delay_ms.unwrap_or(0)
    }

    pub fn clear_auto_lock_delay_ms(&mut self) {
        self.auto_lock_delay_ms = ::std::option::Option::None;
    }

    pub fn has_auto_lock_delay_ms(&self) -> bool {
        self.auto_lock_delay_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auto_lock_delay_ms(&mut self, v: u32) {
        self.auto_lock_delay_ms = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.management.DisplayRotation display_rotation = 7;

    pub fn display_rotation(&self) -> DisplayRotation {
        match self.display_rotation {
            Some(e) => e.enum_value_or(DisplayRotation::North),
            None => DisplayRotation::North,
        }
    }

    pub fn clear_display_rotation(&mut self) {
        self.display_rotation = ::std::option::Option::None;
    }

    pub fn has_display_rotation(&self) -> bool {
        self.display_rotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_rotation(&mut self, v: DisplayRotation) {
        self.display_rotation = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool passphrase_always_on_device = 8;

    pub fn passphrase_always_on_device(&self) -> bool {
        self.passphrase_always_on_device.unwrap_or(false)
    }

    pub fn clear_passphrase_always_on_device(&mut self) {
        self.passphrase_always_on_device = ::std::option::Option::None;
    }

    pub fn has_passphrase_always_on_device(&self) -> bool {
        self.passphrase_always_on_device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passphrase_always_on_device(&mut self, v: bool) {
        self.passphrase_always_on_device = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.management.SafetyCheckLevel safety_checks = 9;

    pub fn safety_checks(&self) -> SafetyCheckLevel {
        match self.safety_checks {
            Some(e) => e.enum_value_or(SafetyCheckLevel::Strict),
            None => SafetyCheckLevel::Strict,
        }
    }

    pub fn clear_safety_checks(&mut self) {
        self.safety_checks = ::std::option::Option::None;
    }

    pub fn has_safety_checks(&self) -> bool {
        self.safety_checks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_safety_checks(&mut self, v: SafetyCheckLevel) {
        self.safety_checks = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool experimental_features = 10;

    pub fn experimental_features(&self) -> bool {
        self.experimental_features.unwrap_or(false)
    }

    pub fn clear_experimental_features(&mut self) {
        self.experimental_features = ::std::option::Option::None;
    }

    pub fn has_experimental_features(&self) -> bool {
        self.experimental_features.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experimental_features(&mut self, v: bool) {
        self.experimental_features = ::std::option::Option::Some(v);
    }

    // optional bool hide_passphrase_from_host = 11;

    pub fn hide_passphrase_from_host(&self) -> bool {
        self.hide_passphrase_from_host.unwrap_or(false)
    }

    pub fn clear_hide_passphrase_from_host(&mut self) {
        self.hide_passphrase_from_host = ::std::option::Option::None;
    }

    pub fn has_hide_passphrase_from_host(&self) -> bool {
        self.hide_passphrase_from_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hide_passphrase_from_host(&mut self, v: bool) {
        self.hide_passphrase_from_host = ::std::option::Option::Some(v);
    }

    // optional bool haptic_feedback = 13;

    pub fn haptic_feedback(&self) -> bool {
        self.haptic_feedback.unwrap_or(false)
    }

    pub fn clear_haptic_feedback(&mut self) {
        self.haptic_feedback = ::std::option::Option::None;
    }

    pub fn has_haptic_feedback(&self) -> bool {
        self.haptic_feedback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_haptic_feedback(&mut self, v: bool) {
        self.haptic_feedback = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &ApplySettings| { &m.language },
            |m: &mut ApplySettings| { &mut m.language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "label",
            |m: &ApplySettings| { &m.label },
            |m: &mut ApplySettings| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "use_passphrase",
            |m: &ApplySettings| { &m.use_passphrase },
            |m: &mut ApplySettings| { &mut m.use_passphrase },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "homescreen",
            |m: &ApplySettings| { &m.homescreen },
            |m: &mut ApplySettings| { &mut m.homescreen },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "_passphrase_source",
            |m: &ApplySettings| { &m._passphrase_source },
            |m: &mut ApplySettings| { &mut m._passphrase_source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "auto_lock_delay_ms",
            |m: &ApplySettings| { &m.auto_lock_delay_ms },
            |m: &mut ApplySettings| { &mut m.auto_lock_delay_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_rotation",
            |m: &ApplySettings| { &m.display_rotation },
            |m: &mut ApplySettings| { &mut m.display_rotation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "passphrase_always_on_device",
            |m: &ApplySettings| { &m.passphrase_always_on_device },
            |m: &mut ApplySettings| { &mut m.passphrase_always_on_device },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "safety_checks",
            |m: &ApplySettings| { &m.safety_checks },
            |m: &mut ApplySettings| { &mut m.safety_checks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "experimental_features",
            |m: &ApplySettings| { &m.experimental_features },
            |m: &mut ApplySettings| { &mut m.experimental_features },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hide_passphrase_from_host",
            |m: &ApplySettings| { &m.hide_passphrase_from_host },
            |m: &mut ApplySettings| { &mut m.hide_passphrase_from_host },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "haptic_feedback",
            |m: &ApplySettings| { &m.haptic_feedback },
            |m: &mut ApplySettings| { &mut m.haptic_feedback },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ApplySettings>(
            "ApplySettings",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ApplySettings {
    const NAME: &'static str = "ApplySettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.label = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.use_passphrase = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.homescreen = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self._passphrase_source = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.auto_lock_delay_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.display_rotation = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                64 => {
                    self.passphrase_always_on_device = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.safety_checks = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                80 => {
                    self.experimental_features = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.hide_passphrase_from_host = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.haptic_feedback = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.use_passphrase {
            my_size += 1 + 1;
        }
        if let Some(v) = self.homescreen.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self._passphrase_source {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.auto_lock_delay_ms {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.display_rotation {
            my_size += ::protobuf::rt::int32_size(7, v.value());
        }
        if let Some(v) = self.passphrase_always_on_device {
            my_size += 1 + 1;
        }
        if let Some(v) = self.safety_checks {
            my_size += ::protobuf::rt::int32_size(9, v.value());
        }
        if let Some(v) = self.experimental_features {
            my_size += 1 + 1;
        }
        if let Some(v) = self.hide_passphrase_from_host {
            my_size += 1 + 1;
        }
        if let Some(v) = self.haptic_feedback {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.language.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.label.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.use_passphrase {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.homescreen.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self._passphrase_source {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.auto_lock_delay_ms {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.display_rotation {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.passphrase_always_on_device {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.safety_checks {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.experimental_features {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.hide_passphrase_from_host {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.haptic_feedback {
            os.write_bool(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ApplySettings {
        ApplySettings::new()
    }

    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.label = ::std::option::Option::None;
        self.use_passphrase = ::std::option::Option::None;
        self.homescreen = ::std::option::Option::None;
        self._passphrase_source = ::std::option::Option::None;
        self.auto_lock_delay_ms = ::std::option::Option::None;
        self.display_rotation = ::std::option::Option::None;
        self.passphrase_always_on_device = ::std::option::Option::None;
        self.safety_checks = ::std::option::Option::None;
        self.experimental_features = ::std::option::Option::None;
        self.hide_passphrase_from_host = ::std::option::Option::None;
        self.haptic_feedback = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ApplySettings {
        static instance: ApplySettings = ApplySettings {
            language: ::std::option::Option::None,
            label: ::std::option::Option::None,
            use_passphrase: ::std::option::Option::None,
            homescreen: ::std::option::Option::None,
            _passphrase_source: ::std::option::Option::None,
            auto_lock_delay_ms: ::std::option::Option::None,
            display_rotation: ::std::option::Option::None,
            passphrase_always_on_device: ::std::option::Option::None,
            safety_checks: ::std::option::Option::None,
            experimental_features: ::std::option::Option::None,
            hide_passphrase_from_host: ::std::option::Option::None,
            haptic_feedback: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ApplySettings {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ApplySettings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ApplySettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApplySettings {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.ChangeLanguage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChangeLanguage {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ChangeLanguage.data_length)
    pub data_length: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ChangeLanguage.show_display)
    pub show_display: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.ChangeLanguage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChangeLanguage {
    fn default() -> &'a ChangeLanguage {
        <ChangeLanguage as ::protobuf::Message>::default_instance()
    }
}

impl ChangeLanguage {
    pub fn new() -> ChangeLanguage {
        ::std::default::Default::default()
    }

    // required uint32 data_length = 1;

    pub fn data_length(&self) -> u32 {
        self.data_length.unwrap_or(0)
    }

    pub fn clear_data_length(&mut self) {
        self.data_length = ::std::option::Option::None;
    }

    pub fn has_data_length(&self) -> bool {
        self.data_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_length(&mut self, v: u32) {
        self.data_length = ::std::option::Option::Some(v);
    }

    // optional bool show_display = 2;

    pub fn show_display(&self) -> bool {
        self.show_display.unwrap_or(false)
    }

    pub fn clear_show_display(&mut self) {
        self.show_display = ::std::option::Option::None;
    }

    pub fn has_show_display(&self) -> bool {
        self.show_display.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_display(&mut self, v: bool) {
        self.show_display = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data_length",
            |m: &ChangeLanguage| { &m.data_length },
            |m: &mut ChangeLanguage| { &mut m.data_length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_display",
            |m: &ChangeLanguage| { &m.show_display },
            |m: &mut ChangeLanguage| { &mut m.show_display },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChangeLanguage>(
            "ChangeLanguage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChangeLanguage {
    const NAME: &'static str = "ChangeLanguage";

    fn is_initialized(&self) -> bool {
        if self.data_length.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.data_length = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.show_display = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data_length {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.show_display {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data_length {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.show_display {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChangeLanguage {
        ChangeLanguage::new()
    }

    fn clear(&mut self) {
        self.data_length = ::std::option::Option::None;
        self.show_display = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChangeLanguage {
        static instance: ChangeLanguage = ChangeLanguage {
            data_length: ::std::option::Option::None,
            show_display: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChangeLanguage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChangeLanguage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChangeLanguage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeLanguage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.TranslationDataRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TranslationDataRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.TranslationDataRequest.data_length)
    pub data_length: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.TranslationDataRequest.data_offset)
    pub data_offset: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.TranslationDataRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TranslationDataRequest {
    fn default() -> &'a TranslationDataRequest {
        <TranslationDataRequest as ::protobuf::Message>::default_instance()
    }
}

impl TranslationDataRequest {
    pub fn new() -> TranslationDataRequest {
        ::std::default::Default::default()
    }

    // required uint32 data_length = 1;

    pub fn data_length(&self) -> u32 {
        self.data_length.unwrap_or(0)
    }

    pub fn clear_data_length(&mut self) {
        self.data_length = ::std::option::Option::None;
    }

    pub fn has_data_length(&self) -> bool {
        self.data_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_length(&mut self, v: u32) {
        self.data_length = ::std::option::Option::Some(v);
    }

    // required uint32 data_offset = 2;

    pub fn data_offset(&self) -> u32 {
        self.data_offset.unwrap_or(0)
    }

    pub fn clear_data_offset(&mut self) {
        self.data_offset = ::std::option::Option::None;
    }

    pub fn has_data_offset(&self) -> bool {
        self.data_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_offset(&mut self, v: u32) {
        self.data_offset = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data_length",
            |m: &TranslationDataRequest| { &m.data_length },
            |m: &mut TranslationDataRequest| { &mut m.data_length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data_offset",
            |m: &TranslationDataRequest| { &m.data_offset },
            |m: &mut TranslationDataRequest| { &mut m.data_offset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TranslationDataRequest>(
            "TranslationDataRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TranslationDataRequest {
    const NAME: &'static str = "TranslationDataRequest";

    fn is_initialized(&self) -> bool {
        if self.data_length.is_none() {
            return false;
        }
        if self.data_offset.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.data_length = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.data_offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data_length {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.data_offset {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data_length {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.data_offset {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TranslationDataRequest {
        TranslationDataRequest::new()
    }

    fn clear(&mut self) {
        self.data_length = ::std::option::Option::None;
        self.data_offset = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TranslationDataRequest {
        static instance: TranslationDataRequest = TranslationDataRequest {
            data_length: ::std::option::Option::None,
            data_offset: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TranslationDataRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TranslationDataRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TranslationDataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TranslationDataRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.TranslationDataAck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TranslationDataAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.TranslationDataAck.data_chunk)
    pub data_chunk: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.TranslationDataAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TranslationDataAck {
    fn default() -> &'a TranslationDataAck {
        <TranslationDataAck as ::protobuf::Message>::default_instance()
    }
}

impl TranslationDataAck {
    pub fn new() -> TranslationDataAck {
        ::std::default::Default::default()
    }

    // required bytes data_chunk = 1;

    pub fn data_chunk(&self) -> &[u8] {
        match self.data_chunk.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data_chunk(&mut self) {
        self.data_chunk = ::std::option::Option::None;
    }

    pub fn has_data_chunk(&self) -> bool {
        self.data_chunk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_chunk(&mut self, v: ::std::vec::Vec<u8>) {
        self.data_chunk = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data_chunk(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data_chunk.is_none() {
            self.data_chunk = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data_chunk.as_mut().unwrap()
    }

    // Take field
    pub fn take_data_chunk(&mut self) -> ::std::vec::Vec<u8> {
        self.data_chunk.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data_chunk",
            |m: &TranslationDataAck| { &m.data_chunk },
            |m: &mut TranslationDataAck| { &mut m.data_chunk },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TranslationDataAck>(
            "TranslationDataAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TranslationDataAck {
    const NAME: &'static str = "TranslationDataAck";

    fn is_initialized(&self) -> bool {
        if self.data_chunk.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data_chunk = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data_chunk.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data_chunk.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TranslationDataAck {
        TranslationDataAck::new()
    }

    fn clear(&mut self) {
        self.data_chunk = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TranslationDataAck {
        static instance: TranslationDataAck = TranslationDataAck {
            data_chunk: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TranslationDataAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TranslationDataAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TranslationDataAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TranslationDataAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.ApplyFlags)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ApplyFlags {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ApplyFlags.flags)
    pub flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.ApplyFlags.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ApplyFlags {
    fn default() -> &'a ApplyFlags {
        <ApplyFlags as ::protobuf::Message>::default_instance()
    }
}

impl ApplyFlags {
    pub fn new() -> ApplyFlags {
        ::std::default::Default::default()
    }

    // required uint32 flags = 1;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &ApplyFlags| { &m.flags },
            |m: &mut ApplyFlags| { &mut m.flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ApplyFlags>(
            "ApplyFlags",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ApplyFlags {
    const NAME: &'static str = "ApplyFlags";

    fn is_initialized(&self) -> bool {
        if self.flags.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.flags {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ApplyFlags {
        ApplyFlags::new()
    }

    fn clear(&mut self) {
        self.flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ApplyFlags {
        static instance: ApplyFlags = ApplyFlags {
            flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ApplyFlags {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ApplyFlags").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ApplyFlags {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApplyFlags {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.ChangePin)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChangePin {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ChangePin.remove)
    pub remove: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.ChangePin.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChangePin {
    fn default() -> &'a ChangePin {
        <ChangePin as ::protobuf::Message>::default_instance()
    }
}

impl ChangePin {
    pub fn new() -> ChangePin {
        ::std::default::Default::default()
    }

    // optional bool remove = 1;

    pub fn remove(&self) -> bool {
        self.remove.unwrap_or(false)
    }

    pub fn clear_remove(&mut self) {
        self.remove = ::std::option::Option::None;
    }

    pub fn has_remove(&self) -> bool {
        self.remove.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remove(&mut self, v: bool) {
        self.remove = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "remove",
            |m: &ChangePin| { &m.remove },
            |m: &mut ChangePin| { &mut m.remove },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChangePin>(
            "ChangePin",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChangePin {
    const NAME: &'static str = "ChangePin";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.remove = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.remove {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.remove {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChangePin {
        ChangePin::new()
    }

    fn clear(&mut self) {
        self.remove = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChangePin {
        static instance: ChangePin = ChangePin {
            remove: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChangePin {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChangePin").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChangePin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangePin {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.ChangeWipeCode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChangeWipeCode {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ChangeWipeCode.remove)
    pub remove: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.ChangeWipeCode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChangeWipeCode {
    fn default() -> &'a ChangeWipeCode {
        <ChangeWipeCode as ::protobuf::Message>::default_instance()
    }
}

impl ChangeWipeCode {
    pub fn new() -> ChangeWipeCode {
        ::std::default::Default::default()
    }

    // optional bool remove = 1;

    pub fn remove(&self) -> bool {
        self.remove.unwrap_or(false)
    }

    pub fn clear_remove(&mut self) {
        self.remove = ::std::option::Option::None;
    }

    pub fn has_remove(&self) -> bool {
        self.remove.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remove(&mut self, v: bool) {
        self.remove = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "remove",
            |m: &ChangeWipeCode| { &m.remove },
            |m: &mut ChangeWipeCode| { &mut m.remove },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChangeWipeCode>(
            "ChangeWipeCode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChangeWipeCode {
    const NAME: &'static str = "ChangeWipeCode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.remove = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.remove {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.remove {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChangeWipeCode {
        ChangeWipeCode::new()
    }

    fn clear(&mut self) {
        self.remove = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChangeWipeCode {
        static instance: ChangeWipeCode = ChangeWipeCode {
            remove: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChangeWipeCode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChangeWipeCode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChangeWipeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeWipeCode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.SdProtect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SdProtect {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.SdProtect.operation)
    pub operation: ::std::option::Option<::protobuf::EnumOrUnknown<sd_protect::SdProtectOperationType>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.SdProtect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SdProtect {
    fn default() -> &'a SdProtect {
        <SdProtect as ::protobuf::Message>::default_instance()
    }
}

impl SdProtect {
    pub fn new() -> SdProtect {
        ::std::default::Default::default()
    }

    // required .hw.trezor.messages.management.SdProtect.SdProtectOperationType operation = 1;

    pub fn operation(&self) -> sd_protect::SdProtectOperationType {
        match self.operation {
            Some(e) => e.enum_value_or(sd_protect::SdProtectOperationType::DISABLE),
            None => sd_protect::SdProtectOperationType::DISABLE,
        }
    }

    pub fn clear_operation(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: sd_protect::SdProtectOperationType) {
        self.operation = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "operation",
            |m: &SdProtect| { &m.operation },
            |m: &mut SdProtect| { &mut m.operation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SdProtect>(
            "SdProtect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SdProtect {
    const NAME: &'static str = "SdProtect";

    fn is_initialized(&self) -> bool {
        if self.operation.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.operation = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.operation {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.operation {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SdProtect {
        SdProtect::new()
    }

    fn clear(&mut self) {
        self.operation = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SdProtect {
        static instance: SdProtect = SdProtect {
            operation: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SdProtect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SdProtect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SdProtect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SdProtect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SdProtect`
pub mod sd_protect {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:hw.trezor.messages.management.SdProtect.SdProtectOperationType)
    pub enum SdProtectOperationType {
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.SdProtect.SdProtectOperationType.DISABLE)
        DISABLE = 0,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.SdProtect.SdProtectOperationType.ENABLE)
        ENABLE = 1,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.SdProtect.SdProtectOperationType.REFRESH)
        REFRESH = 2,
    }

    impl ::protobuf::Enum for SdProtectOperationType {
        const NAME: &'static str = "SdProtectOperationType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<SdProtectOperationType> {
            match value {
                0 => ::std::option::Option::Some(SdProtectOperationType::DISABLE),
                1 => ::std::option::Option::Some(SdProtectOperationType::ENABLE),
                2 => ::std::option::Option::Some(SdProtectOperationType::REFRESH),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<SdProtectOperationType> {
            match str {
                "DISABLE" => ::std::option::Option::Some(SdProtectOperationType::DISABLE),
                "ENABLE" => ::std::option::Option::Some(SdProtectOperationType::ENABLE),
                "REFRESH" => ::std::option::Option::Some(SdProtectOperationType::REFRESH),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [SdProtectOperationType] = &[
            SdProtectOperationType::DISABLE,
            SdProtectOperationType::ENABLE,
            SdProtectOperationType::REFRESH,
        ];
    }

    impl ::protobuf::EnumFull for SdProtectOperationType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("SdProtect.SdProtectOperationType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for SdProtectOperationType {
        fn default() -> Self {
            SdProtectOperationType::DISABLE
        }
    }

    impl SdProtectOperationType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SdProtectOperationType>("SdProtect.SdProtectOperationType")
        }
    }
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.Ping)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Ping {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Ping.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Ping.button_protection)
    pub button_protection: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.Ping.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Ping {
    fn default() -> &'a Ping {
        <Ping as ::protobuf::Message>::default_instance()
    }
}

impl Ping {
    pub fn new() -> Ping {
        ::std::default::Default::default()
    }

    // optional string message = 1;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool button_protection = 2;

    pub fn button_protection(&self) -> bool {
        self.button_protection.unwrap_or(false)
    }

    pub fn clear_button_protection(&mut self) {
        self.button_protection = ::std::option::Option::None;
    }

    pub fn has_button_protection(&self) -> bool {
        self.button_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_button_protection(&mut self, v: bool) {
        self.button_protection = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &Ping| { &m.message },
            |m: &mut Ping| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "button_protection",
            |m: &Ping| { &m.button_protection },
            |m: &mut Ping| { &mut m.button_protection },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Ping>(
            "Ping",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Ping {
    const NAME: &'static str = "Ping";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.button_protection = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.button_protection {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.button_protection {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Ping {
        Ping::new()
    }

    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.button_protection = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Ping {
        static instance: Ping = Ping {
            message: ::std::option::Option::None,
            button_protection: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Ping {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Ping").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Ping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ping {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.Cancel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Cancel {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.Cancel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Cancel {
    fn default() -> &'a Cancel {
        <Cancel as ::protobuf::Message>::default_instance()
    }
}

impl Cancel {
    pub fn new() -> Cancel {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Cancel>(
            "Cancel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Cancel {
    const NAME: &'static str = "Cancel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Cancel {
        Cancel::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Cancel {
        static instance: Cancel = Cancel {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Cancel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Cancel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Cancel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cancel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.GetEntropy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetEntropy {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.GetEntropy.size)
    pub size: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.GetEntropy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetEntropy {
    fn default() -> &'a GetEntropy {
        <GetEntropy as ::protobuf::Message>::default_instance()
    }
}

impl GetEntropy {
    pub fn new() -> GetEntropy {
        ::std::default::Default::default()
    }

    // required uint32 size = 1;

    pub fn size(&self) -> u32 {
        self.size.unwrap_or(0)
    }

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size",
            |m: &GetEntropy| { &m.size },
            |m: &mut GetEntropy| { &mut m.size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetEntropy>(
            "GetEntropy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetEntropy {
    const NAME: &'static str = "GetEntropy";

    fn is_initialized(&self) -> bool {
        if self.size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.size = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.size {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetEntropy {
        GetEntropy::new()
    }

    fn clear(&mut self) {
        self.size = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetEntropy {
        static instance: GetEntropy = GetEntropy {
            size: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetEntropy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetEntropy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetEntropy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEntropy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.Entropy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Entropy {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Entropy.entropy)
    pub entropy: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.Entropy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Entropy {
    fn default() -> &'a Entropy {
        <Entropy as ::protobuf::Message>::default_instance()
    }
}

impl Entropy {
    pub fn new() -> Entropy {
        ::std::default::Default::default()
    }

    // required bytes entropy = 1;

    pub fn entropy(&self) -> &[u8] {
        match self.entropy.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_entropy(&mut self) {
        self.entropy = ::std::option::Option::None;
    }

    pub fn has_entropy(&self) -> bool {
        self.entropy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entropy(&mut self, v: ::std::vec::Vec<u8>) {
        self.entropy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entropy(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.entropy.is_none() {
            self.entropy = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.entropy.as_mut().unwrap()
    }

    // Take field
    pub fn take_entropy(&mut self) -> ::std::vec::Vec<u8> {
        self.entropy.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entropy",
            |m: &Entropy| { &m.entropy },
            |m: &mut Entropy| { &mut m.entropy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Entropy>(
            "Entropy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Entropy {
    const NAME: &'static str = "Entropy";

    fn is_initialized(&self) -> bool {
        if self.entropy.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entropy = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entropy.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entropy.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Entropy {
        Entropy::new()
    }

    fn clear(&mut self) {
        self.entropy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Entropy {
        static instance: Entropy = Entropy {
            entropy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Entropy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Entropy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Entropy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Entropy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.GetFirmwareHash)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetFirmwareHash {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.GetFirmwareHash.challenge)
    pub challenge: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.GetFirmwareHash.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetFirmwareHash {
    fn default() -> &'a GetFirmwareHash {
        <GetFirmwareHash as ::protobuf::Message>::default_instance()
    }
}

impl GetFirmwareHash {
    pub fn new() -> GetFirmwareHash {
        ::std::default::Default::default()
    }

    // optional bytes challenge = 1;

    pub fn challenge(&self) -> &[u8] {
        match self.challenge.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: ::std::vec::Vec<u8>) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_challenge(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.challenge.is_none() {
            self.challenge = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.challenge.as_mut().unwrap()
    }

    // Take field
    pub fn take_challenge(&mut self) -> ::std::vec::Vec<u8> {
        self.challenge.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge",
            |m: &GetFirmwareHash| { &m.challenge },
            |m: &mut GetFirmwareHash| { &mut m.challenge },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetFirmwareHash>(
            "GetFirmwareHash",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetFirmwareHash {
    const NAME: &'static str = "GetFirmwareHash";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.challenge = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.challenge.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.challenge.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetFirmwareHash {
        GetFirmwareHash::new()
    }

    fn clear(&mut self) {
        self.challenge = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetFirmwareHash {
        static instance: GetFirmwareHash = GetFirmwareHash {
            challenge: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetFirmwareHash {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetFirmwareHash").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetFirmwareHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFirmwareHash {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.FirmwareHash)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FirmwareHash {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.FirmwareHash.hash)
    pub hash: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.FirmwareHash.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FirmwareHash {
    fn default() -> &'a FirmwareHash {
        <FirmwareHash as ::protobuf::Message>::default_instance()
    }
}

impl FirmwareHash {
    pub fn new() -> FirmwareHash {
        ::std::default::Default::default()
    }

    // required bytes hash = 1;

    pub fn hash(&self) -> &[u8] {
        match self.hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_hash(&mut self) {
        self.hash = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.hash.is_none() {
            self.hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hash",
            |m: &FirmwareHash| { &m.hash },
            |m: &mut FirmwareHash| { &mut m.hash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FirmwareHash>(
            "FirmwareHash",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FirmwareHash {
    const NAME: &'static str = "FirmwareHash";

    fn is_initialized(&self) -> bool {
        if self.hash.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hash.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FirmwareHash {
        FirmwareHash::new()
    }

    fn clear(&mut self) {
        self.hash = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FirmwareHash {
        static instance: FirmwareHash = FirmwareHash {
            hash: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FirmwareHash {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FirmwareHash").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FirmwareHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FirmwareHash {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.AuthenticateDevice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AuthenticateDevice {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.AuthenticateDevice.challenge)
    pub challenge: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.AuthenticateDevice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuthenticateDevice {
    fn default() -> &'a AuthenticateDevice {
        <AuthenticateDevice as ::protobuf::Message>::default_instance()
    }
}

impl AuthenticateDevice {
    pub fn new() -> AuthenticateDevice {
        ::std::default::Default::default()
    }

    // required bytes challenge = 1;

    pub fn challenge(&self) -> &[u8] {
        match self.challenge.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: ::std::vec::Vec<u8>) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_challenge(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.challenge.is_none() {
            self.challenge = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.challenge.as_mut().unwrap()
    }

    // Take field
    pub fn take_challenge(&mut self) -> ::std::vec::Vec<u8> {
        self.challenge.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge",
            |m: &AuthenticateDevice| { &m.challenge },
            |m: &mut AuthenticateDevice| { &mut m.challenge },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AuthenticateDevice>(
            "AuthenticateDevice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AuthenticateDevice {
    const NAME: &'static str = "AuthenticateDevice";

    fn is_initialized(&self) -> bool {
        if self.challenge.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.challenge = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.challenge.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.challenge.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuthenticateDevice {
        AuthenticateDevice::new()
    }

    fn clear(&mut self) {
        self.challenge = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuthenticateDevice {
        static instance: AuthenticateDevice = AuthenticateDevice {
            challenge: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AuthenticateDevice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AuthenticateDevice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AuthenticateDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticateDevice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.AuthenticityProof)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AuthenticityProof {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.AuthenticityProof.certificates)
    pub certificates: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.AuthenticityProof.signature)
    pub signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.AuthenticityProof.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuthenticityProof {
    fn default() -> &'a AuthenticityProof {
        <AuthenticityProof as ::protobuf::Message>::default_instance()
    }
}

impl AuthenticityProof {
    pub fn new() -> AuthenticityProof {
        ::std::default::Default::default()
    }

    // required bytes signature = 2;

    pub fn signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "certificates",
            |m: &AuthenticityProof| { &m.certificates },
            |m: &mut AuthenticityProof| { &mut m.certificates },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signature",
            |m: &AuthenticityProof| { &m.signature },
            |m: &mut AuthenticityProof| { &mut m.signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AuthenticityProof>(
            "AuthenticityProof",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AuthenticityProof {
    const NAME: &'static str = "AuthenticityProof";

    fn is_initialized(&self) -> bool {
        if self.signature.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.certificates.push(is.read_bytes()?);
                },
                18 => {
                    self.signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.certificates {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.certificates {
            os.write_bytes(1, &v)?;
        };
        if let Some(v) = self.signature.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuthenticityProof {
        AuthenticityProof::new()
    }

    fn clear(&mut self) {
        self.certificates.clear();
        self.signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuthenticityProof {
        static instance: AuthenticityProof = AuthenticityProof {
            certificates: ::std::vec::Vec::new(),
            signature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AuthenticityProof {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AuthenticityProof").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AuthenticityProof {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticityProof {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.WipeDevice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WipeDevice {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.WipeDevice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WipeDevice {
    fn default() -> &'a WipeDevice {
        <WipeDevice as ::protobuf::Message>::default_instance()
    }
}

impl WipeDevice {
    pub fn new() -> WipeDevice {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WipeDevice>(
            "WipeDevice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WipeDevice {
    const NAME: &'static str = "WipeDevice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WipeDevice {
        WipeDevice::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WipeDevice {
        static instance: WipeDevice = WipeDevice {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WipeDevice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WipeDevice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WipeDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WipeDevice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.LoadDevice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoadDevice {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.LoadDevice.mnemonics)
    pub mnemonics: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.LoadDevice.pin)
    pub pin: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.LoadDevice.passphrase_protection)
    pub passphrase_protection: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.LoadDevice.language)
    pub language: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.LoadDevice.label)
    pub label: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.LoadDevice.skip_checksum)
    pub skip_checksum: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.LoadDevice.u2f_counter)
    pub u2f_counter: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.LoadDevice.needs_backup)
    pub needs_backup: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.LoadDevice.no_backup)
    pub no_backup: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.LoadDevice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoadDevice {
    fn default() -> &'a LoadDevice {
        <LoadDevice as ::protobuf::Message>::default_instance()
    }
}

impl LoadDevice {
    pub fn new() -> LoadDevice {
        ::std::default::Default::default()
    }

    // optional string pin = 3;

    pub fn pin(&self) -> &str {
        match self.pin.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pin(&mut self) {
        self.pin = ::std::option::Option::None;
    }

    pub fn has_pin(&self) -> bool {
        self.pin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pin(&mut self, v: ::std::string::String) {
        self.pin = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pin(&mut self) -> &mut ::std::string::String {
        if self.pin.is_none() {
            self.pin = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pin.as_mut().unwrap()
    }

    // Take field
    pub fn take_pin(&mut self) -> ::std::string::String {
        self.pin.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool passphrase_protection = 4;

    pub fn passphrase_protection(&self) -> bool {
        self.passphrase_protection.unwrap_or(false)
    }

    pub fn clear_passphrase_protection(&mut self) {
        self.passphrase_protection = ::std::option::Option::None;
    }

    pub fn has_passphrase_protection(&self) -> bool {
        self.passphrase_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passphrase_protection(&mut self, v: bool) {
        self.passphrase_protection = ::std::option::Option::Some(v);
    }

    // optional string language = 5;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string label = 6;

    pub fn label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_label(&mut self) {
        self.label = ::std::option::Option::None;
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label = ::std::option::Option::Some(::std::string::String::new());
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool skip_checksum = 7;

    pub fn skip_checksum(&self) -> bool {
        self.skip_checksum.unwrap_or(false)
    }

    pub fn clear_skip_checksum(&mut self) {
        self.skip_checksum = ::std::option::Option::None;
    }

    pub fn has_skip_checksum(&self) -> bool {
        self.skip_checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skip_checksum(&mut self, v: bool) {
        self.skip_checksum = ::std::option::Option::Some(v);
    }

    // optional uint32 u2f_counter = 8;

    pub fn u2f_counter(&self) -> u32 {
        self.u2f_counter.unwrap_or(0)
    }

    pub fn clear_u2f_counter(&mut self) {
        self.u2f_counter = ::std::option::Option::None;
    }

    pub fn has_u2f_counter(&self) -> bool {
        self.u2f_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_u2f_counter(&mut self, v: u32) {
        self.u2f_counter = ::std::option::Option::Some(v);
    }

    // optional bool needs_backup = 9;

    pub fn needs_backup(&self) -> bool {
        self.needs_backup.unwrap_or(false)
    }

    pub fn clear_needs_backup(&mut self) {
        self.needs_backup = ::std::option::Option::None;
    }

    pub fn has_needs_backup(&self) -> bool {
        self.needs_backup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_backup(&mut self, v: bool) {
        self.needs_backup = ::std::option::Option::Some(v);
    }

    // optional bool no_backup = 10;

    pub fn no_backup(&self) -> bool {
        self.no_backup.unwrap_or(false)
    }

    pub fn clear_no_backup(&mut self) {
        self.no_backup = ::std::option::Option::None;
    }

    pub fn has_no_backup(&self) -> bool {
        self.no_backup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_no_backup(&mut self, v: bool) {
        self.no_backup = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mnemonics",
            |m: &LoadDevice| { &m.mnemonics },
            |m: &mut LoadDevice| { &mut m.mnemonics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pin",
            |m: &LoadDevice| { &m.pin },
            |m: &mut LoadDevice| { &mut m.pin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "passphrase_protection",
            |m: &LoadDevice| { &m.passphrase_protection },
            |m: &mut LoadDevice| { &mut m.passphrase_protection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &LoadDevice| { &m.language },
            |m: &mut LoadDevice| { &mut m.language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "label",
            |m: &LoadDevice| { &m.label },
            |m: &mut LoadDevice| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "skip_checksum",
            |m: &LoadDevice| { &m.skip_checksum },
            |m: &mut LoadDevice| { &mut m.skip_checksum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "u2f_counter",
            |m: &LoadDevice| { &m.u2f_counter },
            |m: &mut LoadDevice| { &mut m.u2f_counter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "needs_backup",
            |m: &LoadDevice| { &m.needs_backup },
            |m: &mut LoadDevice| { &mut m.needs_backup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "no_backup",
            |m: &LoadDevice| { &m.no_backup },
            |m: &mut LoadDevice| { &mut m.no_backup },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoadDevice>(
            "LoadDevice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoadDevice {
    const NAME: &'static str = "LoadDevice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.mnemonics.push(is.read_string()?);
                },
                26 => {
                    self.pin = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.passphrase_protection = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.label = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.skip_checksum = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.u2f_counter = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.needs_backup = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.no_backup = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.mnemonics {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.pin.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.passphrase_protection {
            my_size += 1 + 1;
        }
        if let Some(v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.skip_checksum {
            my_size += 1 + 1;
        }
        if let Some(v) = self.u2f_counter {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.needs_backup {
            my_size += 1 + 1;
        }
        if let Some(v) = self.no_backup {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.mnemonics {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.pin.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.passphrase_protection {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.language.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.label.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.skip_checksum {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.u2f_counter {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.needs_backup {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.no_backup {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoadDevice {
        LoadDevice::new()
    }

    fn clear(&mut self) {
        self.mnemonics.clear();
        self.pin = ::std::option::Option::None;
        self.passphrase_protection = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.label = ::std::option::Option::None;
        self.skip_checksum = ::std::option::Option::None;
        self.u2f_counter = ::std::option::Option::None;
        self.needs_backup = ::std::option::Option::None;
        self.no_backup = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoadDevice {
        static instance: LoadDevice = LoadDevice {
            mnemonics: ::std::vec::Vec::new(),
            pin: ::std::option::Option::None,
            passphrase_protection: ::std::option::Option::None,
            language: ::std::option::Option::None,
            label: ::std::option::Option::None,
            skip_checksum: ::std::option::Option::None,
            u2f_counter: ::std::option::Option::None,
            needs_backup: ::std::option::Option::None,
            no_backup: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoadDevice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoadDevice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoadDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadDevice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.ResetDevice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResetDevice {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ResetDevice.strength)
    pub strength: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ResetDevice.passphrase_protection)
    pub passphrase_protection: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ResetDevice.pin_protection)
    pub pin_protection: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ResetDevice.language)
    pub language: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ResetDevice.label)
    pub label: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ResetDevice.u2f_counter)
    pub u2f_counter: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ResetDevice.skip_backup)
    pub skip_backup: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ResetDevice.no_backup)
    pub no_backup: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ResetDevice.backup_type)
    pub backup_type: ::std::option::Option<::protobuf::EnumOrUnknown<BackupType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.ResetDevice.entropy_check)
    pub entropy_check: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.ResetDevice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResetDevice {
    fn default() -> &'a ResetDevice {
        <ResetDevice as ::protobuf::Message>::default_instance()
    }
}

impl ResetDevice {
    pub fn new() -> ResetDevice {
        ::std::default::Default::default()
    }

    // optional uint32 strength = 2;

    pub fn strength(&self) -> u32 {
        self.strength.unwrap_or(256u32)
    }

    pub fn clear_strength(&mut self) {
        self.strength = ::std::option::Option::None;
    }

    pub fn has_strength(&self) -> bool {
        self.strength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strength(&mut self, v: u32) {
        self.strength = ::std::option::Option::Some(v);
    }

    // optional bool passphrase_protection = 3;

    pub fn passphrase_protection(&self) -> bool {
        self.passphrase_protection.unwrap_or(false)
    }

    pub fn clear_passphrase_protection(&mut self) {
        self.passphrase_protection = ::std::option::Option::None;
    }

    pub fn has_passphrase_protection(&self) -> bool {
        self.passphrase_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passphrase_protection(&mut self, v: bool) {
        self.passphrase_protection = ::std::option::Option::Some(v);
    }

    // optional bool pin_protection = 4;

    pub fn pin_protection(&self) -> bool {
        self.pin_protection.unwrap_or(false)
    }

    pub fn clear_pin_protection(&mut self) {
        self.pin_protection = ::std::option::Option::None;
    }

    pub fn has_pin_protection(&self) -> bool {
        self.pin_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pin_protection(&mut self, v: bool) {
        self.pin_protection = ::std::option::Option::Some(v);
    }

    // optional string language = 5;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string label = 6;

    pub fn label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_label(&mut self) {
        self.label = ::std::option::Option::None;
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label = ::std::option::Option::Some(::std::string::String::new());
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 u2f_counter = 7;

    pub fn u2f_counter(&self) -> u32 {
        self.u2f_counter.unwrap_or(0)
    }

    pub fn clear_u2f_counter(&mut self) {
        self.u2f_counter = ::std::option::Option::None;
    }

    pub fn has_u2f_counter(&self) -> bool {
        self.u2f_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_u2f_counter(&mut self, v: u32) {
        self.u2f_counter = ::std::option::Option::Some(v);
    }

    // optional bool skip_backup = 8;

    pub fn skip_backup(&self) -> bool {
        self.skip_backup.unwrap_or(false)
    }

    pub fn clear_skip_backup(&mut self) {
        self.skip_backup = ::std::option::Option::None;
    }

    pub fn has_skip_backup(&self) -> bool {
        self.skip_backup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skip_backup(&mut self, v: bool) {
        self.skip_backup = ::std::option::Option::Some(v);
    }

    // optional bool no_backup = 9;

    pub fn no_backup(&self) -> bool {
        self.no_backup.unwrap_or(false)
    }

    pub fn clear_no_backup(&mut self) {
        self.no_backup = ::std::option::Option::None;
    }

    pub fn has_no_backup(&self) -> bool {
        self.no_backup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_no_backup(&mut self, v: bool) {
        self.no_backup = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.management.BackupType backup_type = 10;

    pub fn backup_type(&self) -> BackupType {
        match self.backup_type {
            Some(e) => e.enum_value_or(BackupType::Bip39),
            None => BackupType::Bip39,
        }
    }

    pub fn clear_backup_type(&mut self) {
        self.backup_type = ::std::option::Option::None;
    }

    pub fn has_backup_type(&self) -> bool {
        self.backup_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backup_type(&mut self, v: BackupType) {
        self.backup_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool entropy_check = 11;

    pub fn entropy_check(&self) -> bool {
        self.entropy_check.unwrap_or(false)
    }

    pub fn clear_entropy_check(&mut self) {
        self.entropy_check = ::std::option::Option::None;
    }

    pub fn has_entropy_check(&self) -> bool {
        self.entropy_check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entropy_check(&mut self, v: bool) {
        self.entropy_check = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "strength",
            |m: &ResetDevice| { &m.strength },
            |m: &mut ResetDevice| { &mut m.strength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "passphrase_protection",
            |m: &ResetDevice| { &m.passphrase_protection },
            |m: &mut ResetDevice| { &mut m.passphrase_protection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pin_protection",
            |m: &ResetDevice| { &m.pin_protection },
            |m: &mut ResetDevice| { &mut m.pin_protection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &ResetDevice| { &m.language },
            |m: &mut ResetDevice| { &mut m.language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "label",
            |m: &ResetDevice| { &m.label },
            |m: &mut ResetDevice| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "u2f_counter",
            |m: &ResetDevice| { &m.u2f_counter },
            |m: &mut ResetDevice| { &mut m.u2f_counter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "skip_backup",
            |m: &ResetDevice| { &m.skip_backup },
            |m: &mut ResetDevice| { &mut m.skip_backup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "no_backup",
            |m: &ResetDevice| { &m.no_backup },
            |m: &mut ResetDevice| { &mut m.no_backup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "backup_type",
            |m: &ResetDevice| { &m.backup_type },
            |m: &mut ResetDevice| { &mut m.backup_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entropy_check",
            |m: &ResetDevice| { &m.entropy_check },
            |m: &mut ResetDevice| { &mut m.entropy_check },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResetDevice>(
            "ResetDevice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResetDevice {
    const NAME: &'static str = "ResetDevice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.strength = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.passphrase_protection = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.pin_protection = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.label = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.u2f_counter = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.skip_backup = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.no_backup = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.backup_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                88 => {
                    self.entropy_check = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.strength {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.passphrase_protection {
            my_size += 1 + 1;
        }
        if let Some(v) = self.pin_protection {
            my_size += 1 + 1;
        }
        if let Some(v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.u2f_counter {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.skip_backup {
            my_size += 1 + 1;
        }
        if let Some(v) = self.no_backup {
            my_size += 1 + 1;
        }
        if let Some(v) = self.backup_type {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        if let Some(v) = self.entropy_check {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.strength {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.passphrase_protection {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.pin_protection {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.language.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.label.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.u2f_counter {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.skip_backup {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.no_backup {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.backup_type {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.entropy_check {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResetDevice {
        ResetDevice::new()
    }

    fn clear(&mut self) {
        self.strength = ::std::option::Option::None;
        self.passphrase_protection = ::std::option::Option::None;
        self.pin_protection = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.label = ::std::option::Option::None;
        self.u2f_counter = ::std::option::Option::None;
        self.skip_backup = ::std::option::Option::None;
        self.no_backup = ::std::option::Option::None;
        self.backup_type = ::std::option::Option::None;
        self.entropy_check = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResetDevice {
        static instance: ResetDevice = ResetDevice {
            strength: ::std::option::Option::None,
            passphrase_protection: ::std::option::Option::None,
            pin_protection: ::std::option::Option::None,
            language: ::std::option::Option::None,
            label: ::std::option::Option::None,
            u2f_counter: ::std::option::Option::None,
            skip_backup: ::std::option::Option::None,
            no_backup: ::std::option::Option::None,
            backup_type: ::std::option::Option::None,
            entropy_check: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResetDevice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResetDevice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResetDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResetDevice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.BackupDevice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BackupDevice {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.BackupDevice.group_threshold)
    pub group_threshold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.BackupDevice.groups)
    pub groups: ::std::vec::Vec<backup_device::Slip39Group>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.BackupDevice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BackupDevice {
    fn default() -> &'a BackupDevice {
        <BackupDevice as ::protobuf::Message>::default_instance()
    }
}

impl BackupDevice {
    pub fn new() -> BackupDevice {
        ::std::default::Default::default()
    }

    // optional uint32 group_threshold = 1;

    pub fn group_threshold(&self) -> u32 {
        self.group_threshold.unwrap_or(0)
    }

    pub fn clear_group_threshold(&mut self) {
        self.group_threshold = ::std::option::Option::None;
    }

    pub fn has_group_threshold(&self) -> bool {
        self.group_threshold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_threshold(&mut self, v: u32) {
        self.group_threshold = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "group_threshold",
            |m: &BackupDevice| { &m.group_threshold },
            |m: &mut BackupDevice| { &mut m.group_threshold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "groups",
            |m: &BackupDevice| { &m.groups },
            |m: &mut BackupDevice| { &mut m.groups },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BackupDevice>(
            "BackupDevice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BackupDevice {
    const NAME: &'static str = "BackupDevice";

    fn is_initialized(&self) -> bool {
        for v in &self.groups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.group_threshold = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.groups.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.group_threshold {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.group_threshold {
            os.write_uint32(1, v)?;
        }
        for v in &self.groups {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BackupDevice {
        BackupDevice::new()
    }

    fn clear(&mut self) {
        self.group_threshold = ::std::option::Option::None;
        self.groups.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BackupDevice {
        static instance: BackupDevice = BackupDevice {
            group_threshold: ::std::option::Option::None,
            groups: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BackupDevice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BackupDevice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BackupDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BackupDevice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BackupDevice`
pub mod backup_device {
    // @@protoc_insertion_point(message:hw.trezor.messages.management.BackupDevice.Slip39Group)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Slip39Group {
        // message fields
        // @@protoc_insertion_point(field:hw.trezor.messages.management.BackupDevice.Slip39Group.member_threshold)
        pub member_threshold: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:hw.trezor.messages.management.BackupDevice.Slip39Group.member_count)
        pub member_count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:hw.trezor.messages.management.BackupDevice.Slip39Group.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Slip39Group {
        fn default() -> &'a Slip39Group {
            <Slip39Group as ::protobuf::Message>::default_instance()
        }
    }

    impl Slip39Group {
        pub fn new() -> Slip39Group {
            ::std::default::Default::default()
        }

        // required uint32 member_threshold = 1;

        pub fn member_threshold(&self) -> u32 {
            self.member_threshold.unwrap_or(0)
        }

        pub fn clear_member_threshold(&mut self) {
            self.member_threshold = ::std::option::Option::None;
        }

        pub fn has_member_threshold(&self) -> bool {
            self.member_threshold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_member_threshold(&mut self, v: u32) {
            self.member_threshold = ::std::option::Option::Some(v);
        }

        // required uint32 member_count = 2;

        pub fn member_count(&self) -> u32 {
            self.member_count.unwrap_or(0)
        }

        pub fn clear_member_count(&mut self) {
            self.member_count = ::std::option::Option::None;
        }

        pub fn has_member_count(&self) -> bool {
            self.member_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_member_count(&mut self, v: u32) {
            self.member_count = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "member_threshold",
                |m: &Slip39Group| { &m.member_threshold },
                |m: &mut Slip39Group| { &mut m.member_threshold },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "member_count",
                |m: &Slip39Group| { &m.member_count },
                |m: &mut Slip39Group| { &mut m.member_count },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Slip39Group>(
                "BackupDevice.Slip39Group",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Slip39Group {
        const NAME: &'static str = "Slip39Group";

        fn is_initialized(&self) -> bool {
            if self.member_threshold.is_none() {
                return false;
            }
            if self.member_count.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.member_threshold = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.member_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.member_threshold {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.member_count {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.member_threshold {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.member_count {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Slip39Group {
            Slip39Group::new()
        }

        fn clear(&mut self) {
            self.member_threshold = ::std::option::Option::None;
            self.member_count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Slip39Group {
            static instance: Slip39Group = Slip39Group {
                member_threshold: ::std::option::Option::None,
                member_count: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Slip39Group {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BackupDevice.Slip39Group").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Slip39Group {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Slip39Group {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.EntropyRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EntropyRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.EntropyRequest.entropy_commitment)
    pub entropy_commitment: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.EntropyRequest.prev_entropy)
    pub prev_entropy: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.EntropyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EntropyRequest {
    fn default() -> &'a EntropyRequest {
        <EntropyRequest as ::protobuf::Message>::default_instance()
    }
}

impl EntropyRequest {
    pub fn new() -> EntropyRequest {
        ::std::default::Default::default()
    }

    // optional bytes entropy_commitment = 1;

    pub fn entropy_commitment(&self) -> &[u8] {
        match self.entropy_commitment.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_entropy_commitment(&mut self) {
        self.entropy_commitment = ::std::option::Option::None;
    }

    pub fn has_entropy_commitment(&self) -> bool {
        self.entropy_commitment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entropy_commitment(&mut self, v: ::std::vec::Vec<u8>) {
        self.entropy_commitment = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entropy_commitment(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.entropy_commitment.is_none() {
            self.entropy_commitment = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.entropy_commitment.as_mut().unwrap()
    }

    // Take field
    pub fn take_entropy_commitment(&mut self) -> ::std::vec::Vec<u8> {
        self.entropy_commitment.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes prev_entropy = 2;

    pub fn prev_entropy(&self) -> &[u8] {
        match self.prev_entropy.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_prev_entropy(&mut self) {
        self.prev_entropy = ::std::option::Option::None;
    }

    pub fn has_prev_entropy(&self) -> bool {
        self.prev_entropy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prev_entropy(&mut self, v: ::std::vec::Vec<u8>) {
        self.prev_entropy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prev_entropy(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.prev_entropy.is_none() {
            self.prev_entropy = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.prev_entropy.as_mut().unwrap()
    }

    // Take field
    pub fn take_prev_entropy(&mut self) -> ::std::vec::Vec<u8> {
        self.prev_entropy.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entropy_commitment",
            |m: &EntropyRequest| { &m.entropy_commitment },
            |m: &mut EntropyRequest| { &mut m.entropy_commitment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prev_entropy",
            |m: &EntropyRequest| { &m.prev_entropy },
            |m: &mut EntropyRequest| { &mut m.prev_entropy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EntropyRequest>(
            "EntropyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EntropyRequest {
    const NAME: &'static str = "EntropyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entropy_commitment = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.prev_entropy = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entropy_commitment.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.prev_entropy.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entropy_commitment.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.prev_entropy.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EntropyRequest {
        EntropyRequest::new()
    }

    fn clear(&mut self) {
        self.entropy_commitment = ::std::option::Option::None;
        self.prev_entropy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EntropyRequest {
        static instance: EntropyRequest = EntropyRequest {
            entropy_commitment: ::std::option::Option::None,
            prev_entropy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EntropyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EntropyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EntropyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntropyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.EntropyAck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EntropyAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.EntropyAck.entropy)
    pub entropy: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.EntropyAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EntropyAck {
    fn default() -> &'a EntropyAck {
        <EntropyAck as ::protobuf::Message>::default_instance()
    }
}

impl EntropyAck {
    pub fn new() -> EntropyAck {
        ::std::default::Default::default()
    }

    // required bytes entropy = 1;

    pub fn entropy(&self) -> &[u8] {
        match self.entropy.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_entropy(&mut self) {
        self.entropy = ::std::option::Option::None;
    }

    pub fn has_entropy(&self) -> bool {
        self.entropy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entropy(&mut self, v: ::std::vec::Vec<u8>) {
        self.entropy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entropy(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.entropy.is_none() {
            self.entropy = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.entropy.as_mut().unwrap()
    }

    // Take field
    pub fn take_entropy(&mut self) -> ::std::vec::Vec<u8> {
        self.entropy.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entropy",
            |m: &EntropyAck| { &m.entropy },
            |m: &mut EntropyAck| { &mut m.entropy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EntropyAck>(
            "EntropyAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EntropyAck {
    const NAME: &'static str = "EntropyAck";

    fn is_initialized(&self) -> bool {
        if self.entropy.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entropy = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entropy.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entropy.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EntropyAck {
        EntropyAck::new()
    }

    fn clear(&mut self) {
        self.entropy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EntropyAck {
        static instance: EntropyAck = EntropyAck {
            entropy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EntropyAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EntropyAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EntropyAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntropyAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.EntropyCheckReady)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EntropyCheckReady {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.EntropyCheckReady.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EntropyCheckReady {
    fn default() -> &'a EntropyCheckReady {
        <EntropyCheckReady as ::protobuf::Message>::default_instance()
    }
}

impl EntropyCheckReady {
    pub fn new() -> EntropyCheckReady {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EntropyCheckReady>(
            "EntropyCheckReady",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EntropyCheckReady {
    const NAME: &'static str = "EntropyCheckReady";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EntropyCheckReady {
        EntropyCheckReady::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EntropyCheckReady {
        static instance: EntropyCheckReady = EntropyCheckReady {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EntropyCheckReady {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EntropyCheckReady").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EntropyCheckReady {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntropyCheckReady {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.EntropyCheckContinue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EntropyCheckContinue {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.EntropyCheckContinue.finish)
    pub finish: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.EntropyCheckContinue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EntropyCheckContinue {
    fn default() -> &'a EntropyCheckContinue {
        <EntropyCheckContinue as ::protobuf::Message>::default_instance()
    }
}

impl EntropyCheckContinue {
    pub fn new() -> EntropyCheckContinue {
        ::std::default::Default::default()
    }

    // optional bool finish = 1;

    pub fn finish(&self) -> bool {
        self.finish.unwrap_or(false)
    }

    pub fn clear_finish(&mut self) {
        self.finish = ::std::option::Option::None;
    }

    pub fn has_finish(&self) -> bool {
        self.finish.is_some()
    }

    // Param is passed by value, moved
    pub fn set_finish(&mut self, v: bool) {
        self.finish = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "finish",
            |m: &EntropyCheckContinue| { &m.finish },
            |m: &mut EntropyCheckContinue| { &mut m.finish },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EntropyCheckContinue>(
            "EntropyCheckContinue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EntropyCheckContinue {
    const NAME: &'static str = "EntropyCheckContinue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.finish = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.finish {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.finish {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EntropyCheckContinue {
        EntropyCheckContinue::new()
    }

    fn clear(&mut self) {
        self.finish = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EntropyCheckContinue {
        static instance: EntropyCheckContinue = EntropyCheckContinue {
            finish: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EntropyCheckContinue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EntropyCheckContinue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EntropyCheckContinue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntropyCheckContinue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.RecoveryDevice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RecoveryDevice {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.RecoveryDevice.word_count)
    pub word_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.RecoveryDevice.passphrase_protection)
    pub passphrase_protection: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.RecoveryDevice.pin_protection)
    pub pin_protection: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.RecoveryDevice.language)
    pub language: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.RecoveryDevice.label)
    pub label: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.RecoveryDevice.enforce_wordlist)
    pub enforce_wordlist: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.RecoveryDevice.input_method)
    pub input_method: ::std::option::Option<::protobuf::EnumOrUnknown<recovery_device::RecoveryDeviceInputMethod>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.RecoveryDevice.u2f_counter)
    pub u2f_counter: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.RecoveryDevice.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<RecoveryType>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.RecoveryDevice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RecoveryDevice {
    fn default() -> &'a RecoveryDevice {
        <RecoveryDevice as ::protobuf::Message>::default_instance()
    }
}

impl RecoveryDevice {
    pub fn new() -> RecoveryDevice {
        ::std::default::Default::default()
    }

    // optional uint32 word_count = 1;

    pub fn word_count(&self) -> u32 {
        self.word_count.unwrap_or(0)
    }

    pub fn clear_word_count(&mut self) {
        self.word_count = ::std::option::Option::None;
    }

    pub fn has_word_count(&self) -> bool {
        self.word_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_word_count(&mut self, v: u32) {
        self.word_count = ::std::option::Option::Some(v);
    }

    // optional bool passphrase_protection = 2;

    pub fn passphrase_protection(&self) -> bool {
        self.passphrase_protection.unwrap_or(false)
    }

    pub fn clear_passphrase_protection(&mut self) {
        self.passphrase_protection = ::std::option::Option::None;
    }

    pub fn has_passphrase_protection(&self) -> bool {
        self.passphrase_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passphrase_protection(&mut self, v: bool) {
        self.passphrase_protection = ::std::option::Option::Some(v);
    }

    // optional bool pin_protection = 3;

    pub fn pin_protection(&self) -> bool {
        self.pin_protection.unwrap_or(false)
    }

    pub fn clear_pin_protection(&mut self) {
        self.pin_protection = ::std::option::Option::None;
    }

    pub fn has_pin_protection(&self) -> bool {
        self.pin_protection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pin_protection(&mut self, v: bool) {
        self.pin_protection = ::std::option::Option::Some(v);
    }

    // optional string language = 4;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string label = 5;

    pub fn label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_label(&mut self) {
        self.label = ::std::option::Option::None;
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label = ::std::option::Option::Some(::std::string::String::new());
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool enforce_wordlist = 6;

    pub fn enforce_wordlist(&self) -> bool {
        self.enforce_wordlist.unwrap_or(false)
    }

    pub fn clear_enforce_wordlist(&mut self) {
        self.enforce_wordlist = ::std::option::Option::None;
    }

    pub fn has_enforce_wordlist(&self) -> bool {
        self.enforce_wordlist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enforce_wordlist(&mut self, v: bool) {
        self.enforce_wordlist = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.management.RecoveryDevice.RecoveryDeviceInputMethod input_method = 8;

    pub fn input_method(&self) -> recovery_device::RecoveryDeviceInputMethod {
        match self.input_method {
            Some(e) => e.enum_value_or(recovery_device::RecoveryDeviceInputMethod::ScrambledWords),
            None => recovery_device::RecoveryDeviceInputMethod::ScrambledWords,
        }
    }

    pub fn clear_input_method(&mut self) {
        self.input_method = ::std::option::Option::None;
    }

    pub fn has_input_method(&self) -> bool {
        self.input_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_method(&mut self, v: recovery_device::RecoveryDeviceInputMethod) {
        self.input_method = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 u2f_counter = 9;

    pub fn u2f_counter(&self) -> u32 {
        self.u2f_counter.unwrap_or(0)
    }

    pub fn clear_u2f_counter(&mut self) {
        self.u2f_counter = ::std::option::Option::None;
    }

    pub fn has_u2f_counter(&self) -> bool {
        self.u2f_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_u2f_counter(&mut self, v: u32) {
        self.u2f_counter = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.management.RecoveryType type = 10;

    pub fn type_(&self) -> RecoveryType {
        match self.type_ {
            Some(e) => e.enum_value_or(RecoveryType::NormalRecovery),
            None => RecoveryType::NormalRecovery,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: RecoveryType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "word_count",
            |m: &RecoveryDevice| { &m.word_count },
            |m: &mut RecoveryDevice| { &mut m.word_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "passphrase_protection",
            |m: &RecoveryDevice| { &m.passphrase_protection },
            |m: &mut RecoveryDevice| { &mut m.passphrase_protection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pin_protection",
            |m: &RecoveryDevice| { &m.pin_protection },
            |m: &mut RecoveryDevice| { &mut m.pin_protection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &RecoveryDevice| { &m.language },
            |m: &mut RecoveryDevice| { &mut m.language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "label",
            |m: &RecoveryDevice| { &m.label },
            |m: &mut RecoveryDevice| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enforce_wordlist",
            |m: &RecoveryDevice| { &m.enforce_wordlist },
            |m: &mut RecoveryDevice| { &mut m.enforce_wordlist },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "input_method",
            |m: &RecoveryDevice| { &m.input_method },
            |m: &mut RecoveryDevice| { &mut m.input_method },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "u2f_counter",
            |m: &RecoveryDevice| { &m.u2f_counter },
            |m: &mut RecoveryDevice| { &mut m.u2f_counter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &RecoveryDevice| { &m.type_ },
            |m: &mut RecoveryDevice| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RecoveryDevice>(
            "RecoveryDevice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RecoveryDevice {
    const NAME: &'static str = "RecoveryDevice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.word_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.passphrase_protection = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.pin_protection = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.label = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.enforce_wordlist = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.input_method = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                72 => {
                    self.u2f_counter = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.word_count {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.passphrase_protection {
            my_size += 1 + 1;
        }
        if let Some(v) = self.pin_protection {
            my_size += 1 + 1;
        }
        if let Some(v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.enforce_wordlist {
            my_size += 1 + 1;
        }
        if let Some(v) = self.input_method {
            my_size += ::protobuf::rt::int32_size(8, v.value());
        }
        if let Some(v) = self.u2f_counter {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.word_count {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.passphrase_protection {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.pin_protection {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.language.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.label.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.enforce_wordlist {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.input_method {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.u2f_counter {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RecoveryDevice {
        RecoveryDevice::new()
    }

    fn clear(&mut self) {
        self.word_count = ::std::option::Option::None;
        self.passphrase_protection = ::std::option::Option::None;
        self.pin_protection = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.label = ::std::option::Option::None;
        self.enforce_wordlist = ::std::option::Option::None;
        self.input_method = ::std::option::Option::None;
        self.u2f_counter = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RecoveryDevice {
        static instance: RecoveryDevice = RecoveryDevice {
            word_count: ::std::option::Option::None,
            passphrase_protection: ::std::option::Option::None,
            pin_protection: ::std::option::Option::None,
            language: ::std::option::Option::None,
            label: ::std::option::Option::None,
            enforce_wordlist: ::std::option::Option::None,
            input_method: ::std::option::Option::None,
            u2f_counter: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RecoveryDevice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RecoveryDevice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RecoveryDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecoveryDevice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RecoveryDevice`
pub mod recovery_device {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:hw.trezor.messages.management.RecoveryDevice.RecoveryDeviceInputMethod)
    pub enum RecoveryDeviceInputMethod {
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.RecoveryDevice.RecoveryDeviceInputMethod.ScrambledWords)
        ScrambledWords = 0,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.RecoveryDevice.RecoveryDeviceInputMethod.Matrix)
        Matrix = 1,
    }

    impl ::protobuf::Enum for RecoveryDeviceInputMethod {
        const NAME: &'static str = "RecoveryDeviceInputMethod";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<RecoveryDeviceInputMethod> {
            match value {
                0 => ::std::option::Option::Some(RecoveryDeviceInputMethod::ScrambledWords),
                1 => ::std::option::Option::Some(RecoveryDeviceInputMethod::Matrix),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<RecoveryDeviceInputMethod> {
            match str {
                "ScrambledWords" => ::std::option::Option::Some(RecoveryDeviceInputMethod::ScrambledWords),
                "Matrix" => ::std::option::Option::Some(RecoveryDeviceInputMethod::Matrix),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [RecoveryDeviceInputMethod] = &[
            RecoveryDeviceInputMethod::ScrambledWords,
            RecoveryDeviceInputMethod::Matrix,
        ];
    }

    impl ::protobuf::EnumFull for RecoveryDeviceInputMethod {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("RecoveryDevice.RecoveryDeviceInputMethod").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for RecoveryDeviceInputMethod {
        fn default() -> Self {
            RecoveryDeviceInputMethod::ScrambledWords
        }
    }

    impl RecoveryDeviceInputMethod {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<RecoveryDeviceInputMethod>("RecoveryDevice.RecoveryDeviceInputMethod")
        }
    }
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.WordRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WordRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.WordRequest.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<word_request::WordRequestType>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.WordRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WordRequest {
    fn default() -> &'a WordRequest {
        <WordRequest as ::protobuf::Message>::default_instance()
    }
}

impl WordRequest {
    pub fn new() -> WordRequest {
        ::std::default::Default::default()
    }

    // required .hw.trezor.messages.management.WordRequest.WordRequestType type = 1;

    pub fn type_(&self) -> word_request::WordRequestType {
        match self.type_ {
            Some(e) => e.enum_value_or(word_request::WordRequestType::WordRequestType_Plain),
            None => word_request::WordRequestType::WordRequestType_Plain,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: word_request::WordRequestType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &WordRequest| { &m.type_ },
            |m: &mut WordRequest| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WordRequest>(
            "WordRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WordRequest {
    const NAME: &'static str = "WordRequest";

    fn is_initialized(&self) -> bool {
        if self.type_.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WordRequest {
        WordRequest::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WordRequest {
        static instance: WordRequest = WordRequest {
            type_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WordRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WordRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WordRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WordRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WordRequest`
pub mod word_request {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:hw.trezor.messages.management.WordRequest.WordRequestType)
    pub enum WordRequestType {
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.WordRequest.WordRequestType.WordRequestType_Plain)
        WordRequestType_Plain = 0,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.WordRequest.WordRequestType.WordRequestType_Matrix9)
        WordRequestType_Matrix9 = 1,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.WordRequest.WordRequestType.WordRequestType_Matrix6)
        WordRequestType_Matrix6 = 2,
    }

    impl ::protobuf::Enum for WordRequestType {
        const NAME: &'static str = "WordRequestType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<WordRequestType> {
            match value {
                0 => ::std::option::Option::Some(WordRequestType::WordRequestType_Plain),
                1 => ::std::option::Option::Some(WordRequestType::WordRequestType_Matrix9),
                2 => ::std::option::Option::Some(WordRequestType::WordRequestType_Matrix6),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<WordRequestType> {
            match str {
                "WordRequestType_Plain" => ::std::option::Option::Some(WordRequestType::WordRequestType_Plain),
                "WordRequestType_Matrix9" => ::std::option::Option::Some(WordRequestType::WordRequestType_Matrix9),
                "WordRequestType_Matrix6" => ::std::option::Option::Some(WordRequestType::WordRequestType_Matrix6),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [WordRequestType] = &[
            WordRequestType::WordRequestType_Plain,
            WordRequestType::WordRequestType_Matrix9,
            WordRequestType::WordRequestType_Matrix6,
        ];
    }

    impl ::protobuf::EnumFull for WordRequestType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("WordRequest.WordRequestType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for WordRequestType {
        fn default() -> Self {
            WordRequestType::WordRequestType_Plain
        }
    }

    impl WordRequestType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<WordRequestType>("WordRequest.WordRequestType")
        }
    }
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.WordAck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WordAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.WordAck.word)
    pub word: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.WordAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WordAck {
    fn default() -> &'a WordAck {
        <WordAck as ::protobuf::Message>::default_instance()
    }
}

impl WordAck {
    pub fn new() -> WordAck {
        ::std::default::Default::default()
    }

    // required string word = 1;

    pub fn word(&self) -> &str {
        match self.word.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_word(&mut self) {
        self.word = ::std::option::Option::None;
    }

    pub fn has_word(&self) -> bool {
        self.word.is_some()
    }

    // Param is passed by value, moved
    pub fn set_word(&mut self, v: ::std::string::String) {
        self.word = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_word(&mut self) -> &mut ::std::string::String {
        if self.word.is_none() {
            self.word = ::std::option::Option::Some(::std::string::String::new());
        }
        self.word.as_mut().unwrap()
    }

    // Take field
    pub fn take_word(&mut self) -> ::std::string::String {
        self.word.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "word",
            |m: &WordAck| { &m.word },
            |m: &mut WordAck| { &mut m.word },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WordAck>(
            "WordAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WordAck {
    const NAME: &'static str = "WordAck";

    fn is_initialized(&self) -> bool {
        if self.word.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.word = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.word.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.word.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WordAck {
        WordAck::new()
    }

    fn clear(&mut self) {
        self.word = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WordAck {
        static instance: WordAck = WordAck {
            word: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WordAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WordAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WordAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WordAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.SetU2FCounter)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetU2FCounter {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.SetU2FCounter.u2f_counter)
    pub u2f_counter: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.SetU2FCounter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetU2FCounter {
    fn default() -> &'a SetU2FCounter {
        <SetU2FCounter as ::protobuf::Message>::default_instance()
    }
}

impl SetU2FCounter {
    pub fn new() -> SetU2FCounter {
        ::std::default::Default::default()
    }

    // required uint32 u2f_counter = 1;

    pub fn u2f_counter(&self) -> u32 {
        self.u2f_counter.unwrap_or(0)
    }

    pub fn clear_u2f_counter(&mut self) {
        self.u2f_counter = ::std::option::Option::None;
    }

    pub fn has_u2f_counter(&self) -> bool {
        self.u2f_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_u2f_counter(&mut self, v: u32) {
        self.u2f_counter = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "u2f_counter",
            |m: &SetU2FCounter| { &m.u2f_counter },
            |m: &mut SetU2FCounter| { &mut m.u2f_counter },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetU2FCounter>(
            "SetU2FCounter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetU2FCounter {
    const NAME: &'static str = "SetU2FCounter";

    fn is_initialized(&self) -> bool {
        if self.u2f_counter.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.u2f_counter = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.u2f_counter {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.u2f_counter {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetU2FCounter {
        SetU2FCounter::new()
    }

    fn clear(&mut self) {
        self.u2f_counter = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetU2FCounter {
        static instance: SetU2FCounter = SetU2FCounter {
            u2f_counter: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetU2FCounter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetU2FCounter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetU2FCounter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetU2FCounter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.GetNextU2FCounter)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetNextU2FCounter {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.GetNextU2FCounter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetNextU2FCounter {
    fn default() -> &'a GetNextU2FCounter {
        <GetNextU2FCounter as ::protobuf::Message>::default_instance()
    }
}

impl GetNextU2FCounter {
    pub fn new() -> GetNextU2FCounter {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetNextU2FCounter>(
            "GetNextU2FCounter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetNextU2FCounter {
    const NAME: &'static str = "GetNextU2FCounter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetNextU2FCounter {
        GetNextU2FCounter::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetNextU2FCounter {
        static instance: GetNextU2FCounter = GetNextU2FCounter {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetNextU2FCounter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetNextU2FCounter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetNextU2FCounter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetNextU2FCounter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.NextU2FCounter)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NextU2FCounter {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.NextU2FCounter.u2f_counter)
    pub u2f_counter: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.NextU2FCounter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NextU2FCounter {
    fn default() -> &'a NextU2FCounter {
        <NextU2FCounter as ::protobuf::Message>::default_instance()
    }
}

impl NextU2FCounter {
    pub fn new() -> NextU2FCounter {
        ::std::default::Default::default()
    }

    // required uint32 u2f_counter = 1;

    pub fn u2f_counter(&self) -> u32 {
        self.u2f_counter.unwrap_or(0)
    }

    pub fn clear_u2f_counter(&mut self) {
        self.u2f_counter = ::std::option::Option::None;
    }

    pub fn has_u2f_counter(&self) -> bool {
        self.u2f_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_u2f_counter(&mut self, v: u32) {
        self.u2f_counter = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "u2f_counter",
            |m: &NextU2FCounter| { &m.u2f_counter },
            |m: &mut NextU2FCounter| { &mut m.u2f_counter },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NextU2FCounter>(
            "NextU2FCounter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NextU2FCounter {
    const NAME: &'static str = "NextU2FCounter";

    fn is_initialized(&self) -> bool {
        if self.u2f_counter.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.u2f_counter = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.u2f_counter {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.u2f_counter {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NextU2FCounter {
        NextU2FCounter::new()
    }

    fn clear(&mut self) {
        self.u2f_counter = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NextU2FCounter {
        static instance: NextU2FCounter = NextU2FCounter {
            u2f_counter: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NextU2FCounter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NextU2FCounter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NextU2FCounter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NextU2FCounter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.DoPreauthorized)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DoPreauthorized {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.DoPreauthorized.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DoPreauthorized {
    fn default() -> &'a DoPreauthorized {
        <DoPreauthorized as ::protobuf::Message>::default_instance()
    }
}

impl DoPreauthorized {
    pub fn new() -> DoPreauthorized {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DoPreauthorized>(
            "DoPreauthorized",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DoPreauthorized {
    const NAME: &'static str = "DoPreauthorized";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DoPreauthorized {
        DoPreauthorized::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DoPreauthorized {
        static instance: DoPreauthorized = DoPreauthorized {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DoPreauthorized {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DoPreauthorized").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DoPreauthorized {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DoPreauthorized {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.PreauthorizedRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PreauthorizedRequest {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.PreauthorizedRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PreauthorizedRequest {
    fn default() -> &'a PreauthorizedRequest {
        <PreauthorizedRequest as ::protobuf::Message>::default_instance()
    }
}

impl PreauthorizedRequest {
    pub fn new() -> PreauthorizedRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PreauthorizedRequest>(
            "PreauthorizedRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PreauthorizedRequest {
    const NAME: &'static str = "PreauthorizedRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PreauthorizedRequest {
        PreauthorizedRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PreauthorizedRequest {
        static instance: PreauthorizedRequest = PreauthorizedRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PreauthorizedRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PreauthorizedRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PreauthorizedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreauthorizedRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.CancelAuthorization)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CancelAuthorization {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.CancelAuthorization.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CancelAuthorization {
    fn default() -> &'a CancelAuthorization {
        <CancelAuthorization as ::protobuf::Message>::default_instance()
    }
}

impl CancelAuthorization {
    pub fn new() -> CancelAuthorization {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CancelAuthorization>(
            "CancelAuthorization",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CancelAuthorization {
    const NAME: &'static str = "CancelAuthorization";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CancelAuthorization {
        CancelAuthorization::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CancelAuthorization {
        static instance: CancelAuthorization = CancelAuthorization {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CancelAuthorization {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CancelAuthorization").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CancelAuthorization {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelAuthorization {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.RebootToBootloader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RebootToBootloader {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.RebootToBootloader.boot_command)
    pub boot_command: ::std::option::Option<::protobuf::EnumOrUnknown<reboot_to_bootloader::BootCommand>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.RebootToBootloader.firmware_header)
    pub firmware_header: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.RebootToBootloader.language_data_length)
    pub language_data_length: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.RebootToBootloader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RebootToBootloader {
    fn default() -> &'a RebootToBootloader {
        <RebootToBootloader as ::protobuf::Message>::default_instance()
    }
}

impl RebootToBootloader {
    pub fn new() -> RebootToBootloader {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.management.RebootToBootloader.BootCommand boot_command = 1;

    pub fn boot_command(&self) -> reboot_to_bootloader::BootCommand {
        match self.boot_command {
            Some(e) => e.enum_value_or(reboot_to_bootloader::BootCommand::STOP_AND_WAIT),
            None => reboot_to_bootloader::BootCommand::STOP_AND_WAIT,
        }
    }

    pub fn clear_boot_command(&mut self) {
        self.boot_command = ::std::option::Option::None;
    }

    pub fn has_boot_command(&self) -> bool {
        self.boot_command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_boot_command(&mut self, v: reboot_to_bootloader::BootCommand) {
        self.boot_command = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bytes firmware_header = 2;

    pub fn firmware_header(&self) -> &[u8] {
        match self.firmware_header.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_firmware_header(&mut self) {
        self.firmware_header = ::std::option::Option::None;
    }

    pub fn has_firmware_header(&self) -> bool {
        self.firmware_header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firmware_header(&mut self, v: ::std::vec::Vec<u8>) {
        self.firmware_header = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_firmware_header(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.firmware_header.is_none() {
            self.firmware_header = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.firmware_header.as_mut().unwrap()
    }

    // Take field
    pub fn take_firmware_header(&mut self) -> ::std::vec::Vec<u8> {
        self.firmware_header.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 language_data_length = 3;

    pub fn language_data_length(&self) -> u32 {
        self.language_data_length.unwrap_or(0u32)
    }

    pub fn clear_language_data_length(&mut self) {
        self.language_data_length = ::std::option::Option::None;
    }

    pub fn has_language_data_length(&self) -> bool {
        self.language_data_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language_data_length(&mut self, v: u32) {
        self.language_data_length = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "boot_command",
            |m: &RebootToBootloader| { &m.boot_command },
            |m: &mut RebootToBootloader| { &mut m.boot_command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "firmware_header",
            |m: &RebootToBootloader| { &m.firmware_header },
            |m: &mut RebootToBootloader| { &mut m.firmware_header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language_data_length",
            |m: &RebootToBootloader| { &m.language_data_length },
            |m: &mut RebootToBootloader| { &mut m.language_data_length },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RebootToBootloader>(
            "RebootToBootloader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RebootToBootloader {
    const NAME: &'static str = "RebootToBootloader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.boot_command = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.firmware_header = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.language_data_length = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.boot_command {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.firmware_header.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.language_data_length {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.boot_command {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.firmware_header.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.language_data_length {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RebootToBootloader {
        RebootToBootloader::new()
    }

    fn clear(&mut self) {
        self.boot_command = ::std::option::Option::None;
        self.firmware_header = ::std::option::Option::None;
        self.language_data_length = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RebootToBootloader {
        static instance: RebootToBootloader = RebootToBootloader {
            boot_command: ::std::option::Option::None,
            firmware_header: ::std::option::Option::None,
            language_data_length: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RebootToBootloader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RebootToBootloader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RebootToBootloader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RebootToBootloader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RebootToBootloader`
pub mod reboot_to_bootloader {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:hw.trezor.messages.management.RebootToBootloader.BootCommand)
    pub enum BootCommand {
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.RebootToBootloader.BootCommand.STOP_AND_WAIT)
        STOP_AND_WAIT = 0,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.RebootToBootloader.BootCommand.INSTALL_UPGRADE)
        INSTALL_UPGRADE = 1,
    }

    impl ::protobuf::Enum for BootCommand {
        const NAME: &'static str = "BootCommand";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<BootCommand> {
            match value {
                0 => ::std::option::Option::Some(BootCommand::STOP_AND_WAIT),
                1 => ::std::option::Option::Some(BootCommand::INSTALL_UPGRADE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<BootCommand> {
            match str {
                "STOP_AND_WAIT" => ::std::option::Option::Some(BootCommand::STOP_AND_WAIT),
                "INSTALL_UPGRADE" => ::std::option::Option::Some(BootCommand::INSTALL_UPGRADE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [BootCommand] = &[
            BootCommand::STOP_AND_WAIT,
            BootCommand::INSTALL_UPGRADE,
        ];
    }

    impl ::protobuf::EnumFull for BootCommand {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("RebootToBootloader.BootCommand").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for BootCommand {
        fn default() -> Self {
            BootCommand::STOP_AND_WAIT
        }
    }

    impl BootCommand {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BootCommand>("RebootToBootloader.BootCommand")
        }
    }
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.GetNonce)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetNonce {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.GetNonce.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetNonce {
    fn default() -> &'a GetNonce {
        <GetNonce as ::protobuf::Message>::default_instance()
    }
}

impl GetNonce {
    pub fn new() -> GetNonce {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetNonce>(
            "GetNonce",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetNonce {
    const NAME: &'static str = "GetNonce";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetNonce {
        GetNonce::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetNonce {
        static instance: GetNonce = GetNonce {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetNonce {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetNonce").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetNonce {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetNonce {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.Nonce)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Nonce {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.Nonce.nonce)
    pub nonce: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.Nonce.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Nonce {
    fn default() -> &'a Nonce {
        <Nonce as ::protobuf::Message>::default_instance()
    }
}

impl Nonce {
    pub fn new() -> Nonce {
        ::std::default::Default::default()
    }

    // required bytes nonce = 1;

    pub fn nonce(&self) -> &[u8] {
        match self.nonce.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_nonce(&mut self) {
        self.nonce = ::std::option::Option::None;
    }

    pub fn has_nonce(&self) -> bool {
        self.nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.nonce = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.nonce.is_none() {
            self.nonce = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.nonce.as_mut().unwrap()
    }

    // Take field
    pub fn take_nonce(&mut self) -> ::std::vec::Vec<u8> {
        self.nonce.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nonce",
            |m: &Nonce| { &m.nonce },
            |m: &mut Nonce| { &mut m.nonce },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Nonce>(
            "Nonce",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Nonce {
    const NAME: &'static str = "Nonce";

    fn is_initialized(&self) -> bool {
        if self.nonce.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.nonce = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.nonce.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.nonce.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Nonce {
        Nonce::new()
    }

    fn clear(&mut self) {
        self.nonce = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Nonce {
        static instance: Nonce = Nonce {
            nonce: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Nonce {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Nonce").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Nonce {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Nonce {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.UnlockPath)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UnlockPath {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.UnlockPath.address_n)
    pub address_n: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.management.UnlockPath.mac)
    pub mac: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.UnlockPath.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnlockPath {
    fn default() -> &'a UnlockPath {
        <UnlockPath as ::protobuf::Message>::default_instance()
    }
}

impl UnlockPath {
    pub fn new() -> UnlockPath {
        ::std::default::Default::default()
    }

    // optional bytes mac = 2;

    pub fn mac(&self) -> &[u8] {
        match self.mac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mac(&mut self) {
        self.mac = ::std::option::Option::None;
    }

    pub fn has_mac(&self) -> bool {
        self.mac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mac(&mut self, v: ::std::vec::Vec<u8>) {
        self.mac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mac.is_none() {
            self.mac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mac.as_mut().unwrap()
    }

    // Take field
    pub fn take_mac(&mut self) -> ::std::vec::Vec<u8> {
        self.mac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "address_n",
            |m: &UnlockPath| { &m.address_n },
            |m: &mut UnlockPath| { &mut m.address_n },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mac",
            |m: &UnlockPath| { &m.mac },
            |m: &mut UnlockPath| { &mut m.mac },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnlockPath>(
            "UnlockPath",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnlockPath {
    const NAME: &'static str = "UnlockPath";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.address_n)?;
                },
                8 => {
                    self.address_n.push(is.read_uint32()?);
                },
                18 => {
                    self.mac = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        if let Some(v) = self.mac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.mac.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnlockPath {
        UnlockPath::new()
    }

    fn clear(&mut self) {
        self.address_n.clear();
        self.mac = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnlockPath {
        static instance: UnlockPath = UnlockPath {
            address_n: ::std::vec::Vec::new(),
            mac: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnlockPath {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnlockPath").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnlockPath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnlockPath {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.UnlockedPathRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UnlockedPathRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.UnlockedPathRequest.mac)
    pub mac: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.UnlockedPathRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnlockedPathRequest {
    fn default() -> &'a UnlockedPathRequest {
        <UnlockedPathRequest as ::protobuf::Message>::default_instance()
    }
}

impl UnlockedPathRequest {
    pub fn new() -> UnlockedPathRequest {
        ::std::default::Default::default()
    }

    // optional bytes mac = 1;

    pub fn mac(&self) -> &[u8] {
        match self.mac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mac(&mut self) {
        self.mac = ::std::option::Option::None;
    }

    pub fn has_mac(&self) -> bool {
        self.mac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mac(&mut self, v: ::std::vec::Vec<u8>) {
        self.mac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mac.is_none() {
            self.mac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mac.as_mut().unwrap()
    }

    // Take field
    pub fn take_mac(&mut self) -> ::std::vec::Vec<u8> {
        self.mac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mac",
            |m: &UnlockedPathRequest| { &m.mac },
            |m: &mut UnlockedPathRequest| { &mut m.mac },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnlockedPathRequest>(
            "UnlockedPathRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnlockedPathRequest {
    const NAME: &'static str = "UnlockedPathRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.mac = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mac.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnlockedPathRequest {
        UnlockedPathRequest::new()
    }

    fn clear(&mut self) {
        self.mac = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnlockedPathRequest {
        static instance: UnlockedPathRequest = UnlockedPathRequest {
            mac: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnlockedPathRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnlockedPathRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnlockedPathRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnlockedPathRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.ShowDeviceTutorial)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ShowDeviceTutorial {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.ShowDeviceTutorial.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ShowDeviceTutorial {
    fn default() -> &'a ShowDeviceTutorial {
        <ShowDeviceTutorial as ::protobuf::Message>::default_instance()
    }
}

impl ShowDeviceTutorial {
    pub fn new() -> ShowDeviceTutorial {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShowDeviceTutorial>(
            "ShowDeviceTutorial",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ShowDeviceTutorial {
    const NAME: &'static str = "ShowDeviceTutorial";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ShowDeviceTutorial {
        ShowDeviceTutorial::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ShowDeviceTutorial {
        static instance: ShowDeviceTutorial = ShowDeviceTutorial {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ShowDeviceTutorial {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ShowDeviceTutorial").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ShowDeviceTutorial {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShowDeviceTutorial {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.UnlockBootloader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UnlockBootloader {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.UnlockBootloader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnlockBootloader {
    fn default() -> &'a UnlockBootloader {
        <UnlockBootloader as ::protobuf::Message>::default_instance()
    }
}

impl UnlockBootloader {
    pub fn new() -> UnlockBootloader {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnlockBootloader>(
            "UnlockBootloader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnlockBootloader {
    const NAME: &'static str = "UnlockBootloader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnlockBootloader {
        UnlockBootloader::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnlockBootloader {
        static instance: UnlockBootloader = UnlockBootloader {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnlockBootloader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnlockBootloader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnlockBootloader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnlockBootloader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.management.SetBrightness)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetBrightness {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.management.SetBrightness.value)
    pub value: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.management.SetBrightness.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetBrightness {
    fn default() -> &'a SetBrightness {
        <SetBrightness as ::protobuf::Message>::default_instance()
    }
}

impl SetBrightness {
    pub fn new() -> SetBrightness {
        ::std::default::Default::default()
    }

    // optional uint32 value = 1;

    pub fn value(&self) -> u32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &SetBrightness| { &m.value },
            |m: &mut SetBrightness| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetBrightness>(
            "SetBrightness",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetBrightness {
    const NAME: &'static str = "SetBrightness";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.value = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.value {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetBrightness {
        SetBrightness::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetBrightness {
        static instance: SetBrightness = SetBrightness {
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetBrightness {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetBrightness").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetBrightness {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetBrightness {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:hw.trezor.messages.management.BackupType)
pub enum BackupType {
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.BackupType.Bip39)
    Bip39 = 0,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.BackupType.Slip39_Basic)
    Slip39_Basic = 1,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.BackupType.Slip39_Advanced)
    Slip39_Advanced = 2,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.BackupType.Slip39_Single_Extendable)
    Slip39_Single_Extendable = 3,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.BackupType.Slip39_Basic_Extendable)
    Slip39_Basic_Extendable = 4,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.BackupType.Slip39_Advanced_Extendable)
    Slip39_Advanced_Extendable = 5,
}

impl ::protobuf::Enum for BackupType {
    const NAME: &'static str = "BackupType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BackupType> {
        match value {
            0 => ::std::option::Option::Some(BackupType::Bip39),
            1 => ::std::option::Option::Some(BackupType::Slip39_Basic),
            2 => ::std::option::Option::Some(BackupType::Slip39_Advanced),
            3 => ::std::option::Option::Some(BackupType::Slip39_Single_Extendable),
            4 => ::std::option::Option::Some(BackupType::Slip39_Basic_Extendable),
            5 => ::std::option::Option::Some(BackupType::Slip39_Advanced_Extendable),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<BackupType> {
        match str {
            "Bip39" => ::std::option::Option::Some(BackupType::Bip39),
            "Slip39_Basic" => ::std::option::Option::Some(BackupType::Slip39_Basic),
            "Slip39_Advanced" => ::std::option::Option::Some(BackupType::Slip39_Advanced),
            "Slip39_Single_Extendable" => ::std::option::Option::Some(BackupType::Slip39_Single_Extendable),
            "Slip39_Basic_Extendable" => ::std::option::Option::Some(BackupType::Slip39_Basic_Extendable),
            "Slip39_Advanced_Extendable" => ::std::option::Option::Some(BackupType::Slip39_Advanced_Extendable),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [BackupType] = &[
        BackupType::Bip39,
        BackupType::Slip39_Basic,
        BackupType::Slip39_Advanced,
        BackupType::Slip39_Single_Extendable,
        BackupType::Slip39_Basic_Extendable,
        BackupType::Slip39_Advanced_Extendable,
    ];
}

impl ::protobuf::EnumFull for BackupType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("BackupType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for BackupType {
    fn default() -> Self {
        BackupType::Bip39
    }
}

impl BackupType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BackupType>("BackupType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:hw.trezor.messages.management.SafetyCheckLevel)
pub enum SafetyCheckLevel {
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.SafetyCheckLevel.Strict)
    Strict = 0,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.SafetyCheckLevel.PromptAlways)
    PromptAlways = 1,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.SafetyCheckLevel.PromptTemporarily)
    PromptTemporarily = 2,
}

impl ::protobuf::Enum for SafetyCheckLevel {
    const NAME: &'static str = "SafetyCheckLevel";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SafetyCheckLevel> {
        match value {
            0 => ::std::option::Option::Some(SafetyCheckLevel::Strict),
            1 => ::std::option::Option::Some(SafetyCheckLevel::PromptAlways),
            2 => ::std::option::Option::Some(SafetyCheckLevel::PromptTemporarily),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SafetyCheckLevel> {
        match str {
            "Strict" => ::std::option::Option::Some(SafetyCheckLevel::Strict),
            "PromptAlways" => ::std::option::Option::Some(SafetyCheckLevel::PromptAlways),
            "PromptTemporarily" => ::std::option::Option::Some(SafetyCheckLevel::PromptTemporarily),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SafetyCheckLevel] = &[
        SafetyCheckLevel::Strict,
        SafetyCheckLevel::PromptAlways,
        SafetyCheckLevel::PromptTemporarily,
    ];
}

impl ::protobuf::EnumFull for SafetyCheckLevel {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SafetyCheckLevel").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SafetyCheckLevel {
    fn default() -> Self {
        SafetyCheckLevel::Strict
    }
}

impl SafetyCheckLevel {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SafetyCheckLevel>("SafetyCheckLevel")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:hw.trezor.messages.management.DisplayRotation)
pub enum DisplayRotation {
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.DisplayRotation.North)
    North = 0,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.DisplayRotation.East)
    East = 90,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.DisplayRotation.South)
    South = 180,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.DisplayRotation.West)
    West = 270,
}

impl ::protobuf::Enum for DisplayRotation {
    const NAME: &'static str = "DisplayRotation";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DisplayRotation> {
        match value {
            0 => ::std::option::Option::Some(DisplayRotation::North),
            90 => ::std::option::Option::Some(DisplayRotation::East),
            180 => ::std::option::Option::Some(DisplayRotation::South),
            270 => ::std::option::Option::Some(DisplayRotation::West),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DisplayRotation> {
        match str {
            "North" => ::std::option::Option::Some(DisplayRotation::North),
            "East" => ::std::option::Option::Some(DisplayRotation::East),
            "South" => ::std::option::Option::Some(DisplayRotation::South),
            "West" => ::std::option::Option::Some(DisplayRotation::West),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DisplayRotation] = &[
        DisplayRotation::North,
        DisplayRotation::East,
        DisplayRotation::South,
        DisplayRotation::West,
    ];
}

impl ::protobuf::EnumFull for DisplayRotation {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DisplayRotation").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            DisplayRotation::North => 0,
            DisplayRotation::East => 1,
            DisplayRotation::South => 2,
            DisplayRotation::West => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DisplayRotation {
    fn default() -> Self {
        DisplayRotation::North
    }
}

impl DisplayRotation {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DisplayRotation>("DisplayRotation")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:hw.trezor.messages.management.HomescreenFormat)
pub enum HomescreenFormat {
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.HomescreenFormat.Toif)
    Toif = 1,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.HomescreenFormat.Jpeg)
    Jpeg = 2,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.HomescreenFormat.ToiG)
    ToiG = 3,
}

impl ::protobuf::Enum for HomescreenFormat {
    const NAME: &'static str = "HomescreenFormat";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HomescreenFormat> {
        match value {
            1 => ::std::option::Option::Some(HomescreenFormat::Toif),
            2 => ::std::option::Option::Some(HomescreenFormat::Jpeg),
            3 => ::std::option::Option::Some(HomescreenFormat::ToiG),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<HomescreenFormat> {
        match str {
            "Toif" => ::std::option::Option::Some(HomescreenFormat::Toif),
            "Jpeg" => ::std::option::Option::Some(HomescreenFormat::Jpeg),
            "ToiG" => ::std::option::Option::Some(HomescreenFormat::ToiG),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [HomescreenFormat] = &[
        HomescreenFormat::Toif,
        HomescreenFormat::Jpeg,
        HomescreenFormat::ToiG,
    ];
}

impl ::protobuf::EnumFull for HomescreenFormat {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("HomescreenFormat").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            HomescreenFormat::Toif => 0,
            HomescreenFormat::Jpeg => 1,
            HomescreenFormat::ToiG => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for HomescreenFormat {
    fn default() -> Self {
        HomescreenFormat::Toif
    }
}

impl HomescreenFormat {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<HomescreenFormat>("HomescreenFormat")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:hw.trezor.messages.management.RecoveryType)
pub enum RecoveryType {
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.RecoveryType.NormalRecovery)
    NormalRecovery = 0,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.RecoveryType.DryRun)
    DryRun = 1,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.management.RecoveryType.UnlockRepeatedBackup)
    UnlockRepeatedBackup = 2,
}

impl ::protobuf::Enum for RecoveryType {
    const NAME: &'static str = "RecoveryType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RecoveryType> {
        match value {
            0 => ::std::option::Option::Some(RecoveryType::NormalRecovery),
            1 => ::std::option::Option::Some(RecoveryType::DryRun),
            2 => ::std::option::Option::Some(RecoveryType::UnlockRepeatedBackup),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<RecoveryType> {
        match str {
            "NormalRecovery" => ::std::option::Option::Some(RecoveryType::NormalRecovery),
            "DryRun" => ::std::option::Option::Some(RecoveryType::DryRun),
            "UnlockRepeatedBackup" => ::std::option::Option::Some(RecoveryType::UnlockRepeatedBackup),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [RecoveryType] = &[
        RecoveryType::NormalRecovery,
        RecoveryType::DryRun,
        RecoveryType::UnlockRepeatedBackup,
    ];
}

impl ::protobuf::EnumFull for RecoveryType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("RecoveryType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for RecoveryType {
    fn default() -> Self {
        RecoveryType::NormalRecovery
    }
}

impl RecoveryType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<RecoveryType>("RecoveryType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x19messages-management.proto\x12\x1dhw.trezor.messages.management\x1a\
    \roptions.proto\"\x80\x01\n\nInitialize\x12\x1d\n\nsession_id\x18\x01\
    \x20\x01(\x0cR\tsessionId\x12,\n\x10_skip_passphrase\x18\x02\x20\x01(\
    \x08R\x0eSkipPassphraseB\x02\x18\x01\x12%\n\x0ederive_cardano\x18\x03\
    \x20\x01(\x08R\rderiveCardano\"\r\n\x0bGetFeatures\"\x86\x18\n\x08Featur\
    es\x12\x16\n\x06vendor\x18\x01\x20\x01(\tR\x06vendor\x12#\n\rmajor_versi\
    on\x18\x02\x20\x02(\rR\x0cmajorVersion\x12#\n\rminor_version\x18\x03\x20\
    \x02(\rR\x0cminorVersion\x12#\n\rpatch_version\x18\x04\x20\x02(\rR\x0cpa\
    tchVersion\x12'\n\x0fbootloader_mode\x18\x05\x20\x01(\x08R\x0ebootloader\
    Mode\x12\x1b\n\tdevice_id\x18\x06\x20\x01(\tR\x08deviceId\x12%\n\x0epin_\
    protection\x18\x07\x20\x01(\x08R\rpinProtection\x123\n\x15passphrase_pro\
    tection\x18\x08\x20\x01(\x08R\x14passphraseProtection\x12\x1a\n\x08langu\
    age\x18\t\x20\x01(\tR\x08language\x12\x14\n\x05label\x18\n\x20\x01(\tR\
    \x05label\x12\x20\n\x0binitialized\x18\x0c\x20\x01(\x08R\x0binitialized\
    \x12\x1a\n\x08revision\x18\r\x20\x01(\x0cR\x08revision\x12'\n\x0fbootloa\
    der_hash\x18\x0e\x20\x01(\x0cR\x0ebootloaderHash\x12\x1a\n\x08imported\
    \x18\x0f\x20\x01(\x08R\x08imported\x12\x1a\n\x08unlocked\x18\x10\x20\x01\
    (\x08R\x08unlocked\x120\n\x12_passphrase_cached\x18\x11\x20\x01(\x08R\
    \x10PassphraseCachedB\x02\x18\x01\x12)\n\x10firmware_present\x18\x12\x20\
    \x01(\x08R\x0ffirmwarePresent\x12k\n\x13backup_availability\x18\x13\x20\
    \x01(\x0e2:.hw.trezor.messages.management.Features.BackupAvailabilityR\
    \x12backupAvailability\x12\x14\n\x05flags\x18\x14\x20\x01(\rR\x05flags\
    \x12\x14\n\x05model\x18\x15\x20\x01(\tR\x05model\x12\x19\n\x08fw_major\
    \x18\x16\x20\x01(\rR\x07fwMajor\x12\x19\n\x08fw_minor\x18\x17\x20\x01(\r\
    R\x07fwMinor\x12\x19\n\x08fw_patch\x18\x18\x20\x01(\rR\x07fwPatch\x12\
    \x1b\n\tfw_vendor\x18\x19\x20\x01(\tR\x08fwVendor\x12+\n\x11unfinished_b\
    ackup\x18\x1b\x20\x01(\x08R\x10unfinishedBackup\x12\x1b\n\tno_backup\x18\
    \x1c\x20\x01(\x08R\x08noBackup\x12_\n\x0frecovery_status\x18\x1d\x20\x01\
    (\x0e26.hw.trezor.messages.management.Features.RecoveryStatusR\x0erecove\
    ryStatus\x12V\n\x0ccapabilities\x18\x1e\x20\x03(\x0e22.hw.trezor.message\
    s.management.Features.CapabilityR\x0ccapabilities\x12J\n\x0bbackup_type\
    \x18\x1f\x20\x01(\x0e2).hw.trezor.messages.management.BackupTypeR\nbacku\
    pType\x12&\n\x0fsd_card_present\x18\x20\x20\x01(\x08R\rsdCardPresent\x12\
    #\n\rsd_protection\x18!\x20\x01(\x08R\x0csdProtection\x120\n\x14wipe_cod\
    e_protection\x18\"\x20\x01(\x08R\x12wipeCodeProtection\x12\x1d\n\nsessio\
    n_id\x18#\x20\x01(\x0cR\tsessionId\x12=\n\x1bpassphrase_always_on_device\
    \x18$\x20\x01(\x08R\x18passphraseAlwaysOnDevice\x12T\n\rsafety_checks\
    \x18%\x20\x01(\x0e2/.hw.trezor.messages.management.SafetyCheckLevelR\x0c\
    safetyChecks\x12+\n\x12auto_lock_delay_ms\x18&\x20\x01(\rR\x0fautoLockDe\
    layMs\x12Y\n\x10display_rotation\x18'\x20\x01(\x0e2..hw.trezor.messages.\
    management.DisplayRotationR\x0fdisplayRotation\x123\n\x15experimental_fe\
    atures\x18(\x20\x01(\x08R\x14experimentalFeatures\x12\x12\n\x04busy\x18)\
    \x20\x01(\x08R\x04busy\x12\\\n\x11homescreen_format\x18*\x20\x01(\x0e2/.\
    hw.trezor.messages.management.HomescreenFormatR\x10homescreenFormat\x129\
    \n\x19hide_passphrase_from_host\x18+\x20\x01(\x08R\x16hidePassphraseFrom\
    Host\x12%\n\x0einternal_model\x18,\x20\x01(\tR\rinternalModel\x12\x1d\n\
    \nunit_color\x18-\x20\x01(\rR\tunitColor\x12!\n\x0cunit_btconly\x18.\x20\
    \x01(\x08R\x0bunitBtconly\x12)\n\x10homescreen_width\x18/\x20\x01(\rR\
    \x0fhomescreenWidth\x12+\n\x11homescreen_height\x180\x20\x01(\rR\x10home\
    screenHeight\x12+\n\x11bootloader_locked\x181\x20\x01(\x08R\x10bootloade\
    rLocked\x12>\n\x18language_version_matches\x182\x20\x01(\x08:\x04trueR\
    \x16languageVersionMatches\x12%\n\x0eunit_packaging\x183\x20\x01(\rR\run\
    itPackaging\x12'\n\x0fhaptic_feedback\x184\x20\x01(\x08R\x0ehapticFeedba\
    ck\x12P\n\rrecovery_type\x185\x20\x01(\x0e2+.hw.trezor.messages.manageme\
    nt.RecoveryTypeR\x0crecoveryType\x12\x1d\n\noptiga_sec\x186\x20\x01(\rR\
    \toptigaSec\"C\n\x12BackupAvailability\x12\x10\n\x0cNotAvailable\x10\0\
    \x12\x0c\n\x08Required\x10\x01\x12\r\n\tAvailable\x10\x02\"7\n\x0eRecove\
    ryStatus\x12\x0b\n\x07Nothing\x10\0\x12\x0c\n\x08Recovery\x10\x01\x12\n\
    \n\x06Backup\x10\x02\"\xc2\x04\n\nCapability\x12\x1c\n\x12Capability_Bit\
    coin\x10\x01\x1a\x04\x80\xa6\x1d\x01\x12\x1b\n\x17Capability_Bitcoin_lik\
    e\x10\x02\x12\x16\n\x12Capability_Binance\x10\x03\x12\x16\n\x12Capabilit\
    y_Cardano\x10\x04\x12\x1b\n\x11Capability_Crypto\x10\x05\x1a\x04\x80\xa6\
    \x1d\x01\x12\x12\n\x0eCapability_EOS\x10\x06\x12\x17\n\x13Capability_Eth\
    ereum\x10\x07\x12\x17\n\x0fCapability_Lisk\x10\x08\x1a\x02\x08\x01\x12\
    \x15\n\x11Capability_Monero\x10\t\x12\x12\n\x0eCapability_NEM\x10\n\x12\
    \x15\n\x11Capability_Ripple\x10\x0b\x12\x16\n\x12Capability_Stellar\x10\
    \x0c\x12\x14\n\x10Capability_Tezos\x10\r\x12\x12\n\x0eCapability_U2F\x10\
    \x0e\x12\x1b\n\x11Capability_Shamir\x10\x0f\x1a\x04\x80\xa6\x1d\x01\x12!\
    \n\x17Capability_ShamirGroups\x10\x10\x1a\x04\x80\xa6\x1d\x01\x12$\n\x1a\
    Capability_PassphraseEntry\x10\x11\x1a\x04\x80\xa6\x1d\x01\x12\x15\n\x11\
    Capability_Solana\x10\x12\x12!\n\x17Capability_Translations\x10\x13\x1a\
    \x04\x80\xa6\x1d\x01\x12\x1f\n\x15Capability_Brightness\x10\x14\x1a\x04\
    \x80\xa6\x1d\x01\x12\x1b\n\x11Capability_Haptic\x10\x15\x1a\x04\x80\xa6\
    \x1d\x01\x1a\x04\xc8\xf3\x18\x01\"\x0c\n\nLockDevice\"&\n\x07SetBusy\x12\
    \x1b\n\texpiry_ms\x18\x01\x20\x01(\rR\x08expiryMs\"\x0c\n\nEndSession\"\
    \xf4\x04\n\rApplySettings\x12\x1e\n\x08language\x18\x01\x20\x01(\tR\x08l\
    anguageB\x02\x18\x01\x12\x14\n\x05label\x18\x02\x20\x01(\tR\x05label\x12\
    %\n\x0euse_passphrase\x18\x03\x20\x01(\x08R\rusePassphrase\x12\x1e\n\nho\
    mescreen\x18\x04\x20\x01(\x0cR\nhomescreen\x120\n\x12_passphrase_source\
    \x18\x05\x20\x01(\rR\x10PassphraseSourceB\x02\x18\x01\x12+\n\x12auto_loc\
    k_delay_ms\x18\x06\x20\x01(\rR\x0fautoLockDelayMs\x12Y\n\x10display_rota\
    tion\x18\x07\x20\x01(\x0e2..hw.trezor.messages.management.DisplayRotatio\
    nR\x0fdisplayRotation\x12=\n\x1bpassphrase_always_on_device\x18\x08\x20\
    \x01(\x08R\x18passphraseAlwaysOnDevice\x12T\n\rsafety_checks\x18\t\x20\
    \x01(\x0e2/.hw.trezor.messages.management.SafetyCheckLevelR\x0csafetyChe\
    cks\x123\n\x15experimental_features\x18\n\x20\x01(\x08R\x14experimentalF\
    eatures\x129\n\x19hide_passphrase_from_host\x18\x0b\x20\x01(\x08R\x16hid\
    ePassphraseFromHost\x12'\n\x0fhaptic_feedback\x18\r\x20\x01(\x08R\x0ehap\
    ticFeedback\"T\n\x0eChangeLanguage\x12\x1f\n\x0bdata_length\x18\x01\x20\
    \x02(\rR\ndataLength\x12!\n\x0cshow_display\x18\x02\x20\x01(\x08R\x0bsho\
    wDisplay\"Z\n\x16TranslationDataRequest\x12\x1f\n\x0bdata_length\x18\x01\
    \x20\x02(\rR\ndataLength\x12\x1f\n\x0bdata_offset\x18\x02\x20\x02(\rR\nd\
    ataOffset\"3\n\x12TranslationDataAck\x12\x1d\n\ndata_chunk\x18\x01\x20\
    \x02(\x0cR\tdataChunk\"\"\n\nApplyFlags\x12\x14\n\x05flags\x18\x01\x20\
    \x02(\rR\x05flags\"#\n\tChangePin\x12\x16\n\x06remove\x18\x01\x20\x01(\
    \x08R\x06remove\"(\n\x0eChangeWipeCode\x12\x16\n\x06remove\x18\x01\x20\
    \x01(\x08R\x06remove\"\xaa\x01\n\tSdProtect\x12]\n\toperation\x18\x01\
    \x20\x02(\x0e2?.hw.trezor.messages.management.SdProtect.SdProtectOperati\
    onTypeR\toperation\">\n\x16SdProtectOperationType\x12\x0b\n\x07DISABLE\
    \x10\0\x12\n\n\x06ENABLE\x10\x01\x12\x0b\n\x07REFRESH\x10\x02\"O\n\x04Pi\
    ng\x12\x1a\n\x07message\x18\x01\x20\x01(\t:\0R\x07message\x12+\n\x11butt\
    on_protection\x18\x02\x20\x01(\x08R\x10buttonProtection\"\x08\n\x06Cance\
    l\"\x20\n\nGetEntropy\x12\x12\n\x04size\x18\x01\x20\x02(\rR\x04size\"#\n\
    \x07Entropy\x12\x18\n\x07entropy\x18\x01\x20\x02(\x0cR\x07entropy\"/\n\
    \x0fGetFirmwareHash\x12\x1c\n\tchallenge\x18\x01\x20\x01(\x0cR\tchalleng\
    e\"\"\n\x0cFirmwareHash\x12\x12\n\x04hash\x18\x01\x20\x02(\x0cR\x04hash\
    \"2\n\x12AuthenticateDevice\x12\x1c\n\tchallenge\x18\x01\x20\x02(\x0cR\t\
    challenge\"U\n\x11AuthenticityProof\x12\"\n\x0ccertificates\x18\x01\x20\
    \x03(\x0cR\x0ccertificates\x12\x1c\n\tsignature\x18\x02\x20\x02(\x0cR\ts\
    ignature\"\x0c\n\nWipeDevice\"\xad\x02\n\nLoadDevice\x12\x1c\n\tmnemonic\
    s\x18\x01\x20\x03(\tR\tmnemonics\x12\x10\n\x03pin\x18\x03\x20\x01(\tR\
    \x03pin\x123\n\x15passphrase_protection\x18\x04\x20\x01(\x08R\x14passphr\
    aseProtection\x12\x1e\n\x08language\x18\x05\x20\x01(\tR\x08languageB\x02\
    \x18\x01\x12\x14\n\x05label\x18\x06\x20\x01(\tR\x05label\x12#\n\rskip_ch\
    ecksum\x18\x07\x20\x01(\x08R\x0cskipChecksum\x12\x1f\n\x0bu2f_counter\
    \x18\x08\x20\x01(\rR\nu2fCounter\x12!\n\x0cneeds_backup\x18\t\x20\x01(\
    \x08R\x0bneedsBackup\x12\x1b\n\tno_backup\x18\n\x20\x01(\x08R\x08noBacku\
    p\"\x9d\x03\n\x0bResetDevice\x12\x1f\n\x08strength\x18\x02\x20\x01(\r:\
    \x03256R\x08strength\x123\n\x15passphrase_protection\x18\x03\x20\x01(\
    \x08R\x14passphraseProtection\x12%\n\x0epin_protection\x18\x04\x20\x01(\
    \x08R\rpinProtection\x12\x1e\n\x08language\x18\x05\x20\x01(\tR\x08langua\
    geB\x02\x18\x01\x12\x14\n\x05label\x18\x06\x20\x01(\tR\x05label\x12\x1f\
    \n\x0bu2f_counter\x18\x07\x20\x01(\rR\nu2fCounter\x12\x1f\n\x0bskip_back\
    up\x18\x08\x20\x01(\x08R\nskipBackup\x12\x1b\n\tno_backup\x18\t\x20\x01(\
    \x08R\x08noBackup\x12Q\n\x0bbackup_type\x18\n\x20\x01(\x0e2).hw.trezor.m\
    essages.management.BackupType:\x05Bip39R\nbackupType\x12#\n\rentropy_che\
    ck\x18\x0b\x20\x01(\x08R\x0centropyCheckJ\x04\x08\x01\x10\x02\"\xe5\x01\
    \n\x0cBackupDevice\x12'\n\x0fgroup_threshold\x18\x01\x20\x01(\rR\x0egrou\
    pThreshold\x12O\n\x06groups\x18\x02\x20\x03(\x0b27.hw.trezor.messages.ma\
    nagement.BackupDevice.Slip39GroupR\x06groups\x1a[\n\x0bSlip39Group\x12)\
    \n\x10member_threshold\x18\x01\x20\x02(\rR\x0fmemberThreshold\x12!\n\x0c\
    member_count\x18\x02\x20\x02(\rR\x0bmemberCount\"b\n\x0eEntropyRequest\
    \x12-\n\x12entropy_commitment\x18\x01\x20\x01(\x0cR\x11entropyCommitment\
    \x12!\n\x0cprev_entropy\x18\x02\x20\x01(\x0cR\x0bprevEntropy\"&\n\nEntro\
    pyAck\x12\x18\n\x07entropy\x18\x01\x20\x02(\x0cR\x07entropy\"\x13\n\x11E\
    ntropyCheckReady\"5\n\x14EntropyCheckContinue\x12\x1d\n\x06finish\x18\
    \x01\x20\x01(\x08:\x05falseR\x06finish\"\x8d\x04\n\x0eRecoveryDevice\x12\
    \x1d\n\nword_count\x18\x01\x20\x01(\rR\twordCount\x123\n\x15passphrase_p\
    rotection\x18\x02\x20\x01(\x08R\x14passphraseProtection\x12%\n\x0epin_pr\
    otection\x18\x03\x20\x01(\x08R\rpinProtection\x12\x1e\n\x08language\x18\
    \x04\x20\x01(\tR\x08languageB\x02\x18\x01\x12\x14\n\x05label\x18\x05\x20\
    \x01(\tR\x05label\x12)\n\x10enforce_wordlist\x18\x06\x20\x01(\x08R\x0fen\
    forceWordlist\x12j\n\x0cinput_method\x18\x08\x20\x01(\x0e2G.hw.trezor.me\
    ssages.management.RecoveryDevice.RecoveryDeviceInputMethodR\x0binputMeth\
    od\x12\x1f\n\x0bu2f_counter\x18\t\x20\x01(\rR\nu2fCounter\x12O\n\x04type\
    \x18\n\x20\x01(\x0e2+.hw.trezor.messages.management.RecoveryType:\x0eNor\
    malRecoveryR\x04type\";\n\x19RecoveryDeviceInputMethod\x12\x12\n\x0eScra\
    mbledWords\x10\0\x12\n\n\x06Matrix\x10\x01J\x04\x08\x07\x10\x08\"\xc5\
    \x01\n\x0bWordRequest\x12N\n\x04type\x18\x01\x20\x02(\x0e2:.hw.trezor.me\
    ssages.management.WordRequest.WordRequestTypeR\x04type\"f\n\x0fWordReque\
    stType\x12\x19\n\x15WordRequestType_Plain\x10\0\x12\x1b\n\x17WordRequest\
    Type_Matrix9\x10\x01\x12\x1b\n\x17WordRequestType_Matrix6\x10\x02\"\x1d\
    \n\x07WordAck\x12\x12\n\x04word\x18\x01\x20\x02(\tR\x04word\"0\n\rSetU2F\
    Counter\x12\x1f\n\x0bu2f_counter\x18\x01\x20\x02(\rR\nu2fCounter\"\x13\n\
    \x11GetNextU2FCounter\"1\n\x0eNextU2FCounter\x12\x1f\n\x0bu2f_counter\
    \x18\x01\x20\x02(\rR\nu2fCounter\"\x11\n\x0fDoPreauthorized\"\x16\n\x14P\
    reauthorizedRequest\"\x15\n\x13CancelAuthorization\"\x9a\x02\n\x12Reboot\
    ToBootloader\x12o\n\x0cboot_command\x18\x01\x20\x01(\x0e2=.hw.trezor.mes\
    sages.management.RebootToBootloader.BootCommand:\rSTOP_AND_WAITR\x0bboot\
    Command\x12'\n\x0ffirmware_header\x18\x02\x20\x01(\x0cR\x0efirmwareHeade\
    r\x123\n\x14language_data_length\x18\x03\x20\x01(\r:\x010R\x12languageDa\
    taLength\"5\n\x0bBootCommand\x12\x11\n\rSTOP_AND_WAIT\x10\0\x12\x13\n\
    \x0fINSTALL_UPGRADE\x10\x01\"\x10\n\x08GetNonce:\x04\x88\xb2\x19\x01\"#\
    \n\x05Nonce\x12\x14\n\x05nonce\x18\x01\x20\x02(\x0cR\x05nonce:\x04\x88\
    \xb2\x19\x01\";\n\nUnlockPath\x12\x1b\n\taddress_n\x18\x01\x20\x03(\rR\
    \x08addressN\x12\x10\n\x03mac\x18\x02\x20\x01(\x0cR\x03mac\"'\n\x13Unloc\
    kedPathRequest\x12\x10\n\x03mac\x18\x01\x20\x01(\x0cR\x03mac\"\x14\n\x12\
    ShowDeviceTutorial\"\x12\n\x10UnlockBootloader\"%\n\rSetBrightness\x12\
    \x14\n\x05value\x18\x01\x20\x01(\rR\x05value*\x99\x01\n\nBackupType\x12\
    \t\n\x05Bip39\x10\0\x12\x10\n\x0cSlip39_Basic\x10\x01\x12\x13\n\x0fSlip3\
    9_Advanced\x10\x02\x12\x1c\n\x18Slip39_Single_Extendable\x10\x03\x12\x1b\
    \n\x17Slip39_Basic_Extendable\x10\x04\x12\x1e\n\x1aSlip39_Advanced_Exten\
    dable\x10\x05*G\n\x10SafetyCheckLevel\x12\n\n\x06Strict\x10\0\x12\x10\n\
    \x0cPromptAlways\x10\x01\x12\x15\n\x11PromptTemporarily\x10\x02*=\n\x0fD\
    isplayRotation\x12\t\n\x05North\x10\0\x12\x08\n\x04East\x10Z\x12\n\n\x05\
    South\x10\xb4\x01\x12\t\n\x04West\x10\x8e\x02*0\n\x10HomescreenFormat\
    \x12\x08\n\x04Toif\x10\x01\x12\x08\n\x04Jpeg\x10\x02\x12\x08\n\x04ToiG\
    \x10\x03*H\n\x0cRecoveryType\x12\x12\n\x0eNormalRecovery\x10\0\x12\n\n\
    \x06DryRun\x10\x01\x12\x18\n\x14UnlockRepeatedBackup\x10\x02BB\n#com.sat\
    oshilabs.trezor.lib.protobufB\x17TrezorMessageManagement\x80\xa6\x1d\x01\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::options::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(48);
            messages.push(Initialize::generated_message_descriptor_data());
            messages.push(GetFeatures::generated_message_descriptor_data());
            messages.push(Features::generated_message_descriptor_data());
            messages.push(LockDevice::generated_message_descriptor_data());
            messages.push(SetBusy::generated_message_descriptor_data());
            messages.push(EndSession::generated_message_descriptor_data());
            messages.push(ApplySettings::generated_message_descriptor_data());
            messages.push(ChangeLanguage::generated_message_descriptor_data());
            messages.push(TranslationDataRequest::generated_message_descriptor_data());
            messages.push(TranslationDataAck::generated_message_descriptor_data());
            messages.push(ApplyFlags::generated_message_descriptor_data());
            messages.push(ChangePin::generated_message_descriptor_data());
            messages.push(ChangeWipeCode::generated_message_descriptor_data());
            messages.push(SdProtect::generated_message_descriptor_data());
            messages.push(Ping::generated_message_descriptor_data());
            messages.push(Cancel::generated_message_descriptor_data());
            messages.push(GetEntropy::generated_message_descriptor_data());
            messages.push(Entropy::generated_message_descriptor_data());
            messages.push(GetFirmwareHash::generated_message_descriptor_data());
            messages.push(FirmwareHash::generated_message_descriptor_data());
            messages.push(AuthenticateDevice::generated_message_descriptor_data());
            messages.push(AuthenticityProof::generated_message_descriptor_data());
            messages.push(WipeDevice::generated_message_descriptor_data());
            messages.push(LoadDevice::generated_message_descriptor_data());
            messages.push(ResetDevice::generated_message_descriptor_data());
            messages.push(BackupDevice::generated_message_descriptor_data());
            messages.push(EntropyRequest::generated_message_descriptor_data());
            messages.push(EntropyAck::generated_message_descriptor_data());
            messages.push(EntropyCheckReady::generated_message_descriptor_data());
            messages.push(EntropyCheckContinue::generated_message_descriptor_data());
            messages.push(RecoveryDevice::generated_message_descriptor_data());
            messages.push(WordRequest::generated_message_descriptor_data());
            messages.push(WordAck::generated_message_descriptor_data());
            messages.push(SetU2FCounter::generated_message_descriptor_data());
            messages.push(GetNextU2FCounter::generated_message_descriptor_data());
            messages.push(NextU2FCounter::generated_message_descriptor_data());
            messages.push(DoPreauthorized::generated_message_descriptor_data());
            messages.push(PreauthorizedRequest::generated_message_descriptor_data());
            messages.push(CancelAuthorization::generated_message_descriptor_data());
            messages.push(RebootToBootloader::generated_message_descriptor_data());
            messages.push(GetNonce::generated_message_descriptor_data());
            messages.push(Nonce::generated_message_descriptor_data());
            messages.push(UnlockPath::generated_message_descriptor_data());
            messages.push(UnlockedPathRequest::generated_message_descriptor_data());
            messages.push(ShowDeviceTutorial::generated_message_descriptor_data());
            messages.push(UnlockBootloader::generated_message_descriptor_data());
            messages.push(SetBrightness::generated_message_descriptor_data());
            messages.push(backup_device::Slip39Group::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(12);
            enums.push(BackupType::generated_enum_descriptor_data());
            enums.push(SafetyCheckLevel::generated_enum_descriptor_data());
            enums.push(DisplayRotation::generated_enum_descriptor_data());
            enums.push(HomescreenFormat::generated_enum_descriptor_data());
            enums.push(RecoveryType::generated_enum_descriptor_data());
            enums.push(features::BackupAvailability::generated_enum_descriptor_data());
            enums.push(features::RecoveryStatus::generated_enum_descriptor_data());
            enums.push(features::Capability::generated_enum_descriptor_data());
            enums.push(sd_protect::SdProtectOperationType::generated_enum_descriptor_data());
            enums.push(recovery_device::RecoveryDeviceInputMethod::generated_enum_descriptor_data());
            enums.push(word_request::WordRequestType::generated_enum_descriptor_data());
            enums.push(reboot_to_bootloader::BootCommand::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
