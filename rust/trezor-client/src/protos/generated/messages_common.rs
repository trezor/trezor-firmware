// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.6
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `messages-common.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:hw.trezor.messages.common.Success)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Success {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.common.Success.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.common.Success.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Success {
    fn default() -> &'a Success {
        <Success as ::protobuf::Message>::default_instance()
    }
}

impl Success {
    pub fn new() -> Success {
        ::std::default::Default::default()
    }

    // optional string message = 1;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &Success| { &m.message },
            |m: &mut Success| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Success>(
            "Success",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Success {
    const NAME: &'static str = "Success";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Success {
        Success::new()
    }

    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Success {
        static instance: Success = Success {
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Success {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Success").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Success {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Success {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.common.Failure)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Failure {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.common.Failure.code)
    pub code: ::std::option::Option<::protobuf::EnumOrUnknown<failure::FailureType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.common.Failure.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.common.Failure.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Failure {
    fn default() -> &'a Failure {
        <Failure as ::protobuf::Message>::default_instance()
    }
}

impl Failure {
    pub fn new() -> Failure {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.common.Failure.FailureType code = 1;

    pub fn code(&self) -> failure::FailureType {
        match self.code {
            Some(e) => e.enum_value_or(failure::FailureType::Failure_UnexpectedMessage),
            None => failure::FailureType::Failure_UnexpectedMessage,
        }
    }

    pub fn clear_code(&mut self) {
        self.code = ::std::option::Option::None;
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: failure::FailureType) {
        self.code = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "code",
            |m: &Failure| { &m.code },
            |m: &mut Failure| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &Failure| { &m.message },
            |m: &mut Failure| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Failure>(
            "Failure",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Failure {
    const NAME: &'static str = "Failure";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.code {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.code {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Failure {
        Failure::new()
    }

    fn clear(&mut self) {
        self.code = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Failure {
        static instance: Failure = Failure {
            code: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Failure {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Failure").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Failure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Failure {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Failure`
pub mod failure {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:hw.trezor.messages.common.Failure.FailureType)
    pub enum FailureType {
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.Failure.FailureType.Failure_UnexpectedMessage)
        Failure_UnexpectedMessage = 1,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.Failure.FailureType.Failure_ButtonExpected)
        Failure_ButtonExpected = 2,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.Failure.FailureType.Failure_DataError)
        Failure_DataError = 3,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.Failure.FailureType.Failure_ActionCancelled)
        Failure_ActionCancelled = 4,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.Failure.FailureType.Failure_PinExpected)
        Failure_PinExpected = 5,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.Failure.FailureType.Failure_PinCancelled)
        Failure_PinCancelled = 6,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.Failure.FailureType.Failure_PinInvalid)
        Failure_PinInvalid = 7,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.Failure.FailureType.Failure_InvalidSignature)
        Failure_InvalidSignature = 8,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.Failure.FailureType.Failure_ProcessError)
        Failure_ProcessError = 9,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.Failure.FailureType.Failure_NotEnoughFunds)
        Failure_NotEnoughFunds = 10,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.Failure.FailureType.Failure_NotInitialized)
        Failure_NotInitialized = 11,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.Failure.FailureType.Failure_PinMismatch)
        Failure_PinMismatch = 12,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.Failure.FailureType.Failure_WipeCodeMismatch)
        Failure_WipeCodeMismatch = 13,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.Failure.FailureType.Failure_InvalidSession)
        Failure_InvalidSession = 14,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.Failure.FailureType.Failure_FirmwareError)
        Failure_FirmwareError = 99,
    }

    impl ::protobuf::Enum for FailureType {
        const NAME: &'static str = "FailureType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<FailureType> {
            match value {
                1 => ::std::option::Option::Some(FailureType::Failure_UnexpectedMessage),
                2 => ::std::option::Option::Some(FailureType::Failure_ButtonExpected),
                3 => ::std::option::Option::Some(FailureType::Failure_DataError),
                4 => ::std::option::Option::Some(FailureType::Failure_ActionCancelled),
                5 => ::std::option::Option::Some(FailureType::Failure_PinExpected),
                6 => ::std::option::Option::Some(FailureType::Failure_PinCancelled),
                7 => ::std::option::Option::Some(FailureType::Failure_PinInvalid),
                8 => ::std::option::Option::Some(FailureType::Failure_InvalidSignature),
                9 => ::std::option::Option::Some(FailureType::Failure_ProcessError),
                10 => ::std::option::Option::Some(FailureType::Failure_NotEnoughFunds),
                11 => ::std::option::Option::Some(FailureType::Failure_NotInitialized),
                12 => ::std::option::Option::Some(FailureType::Failure_PinMismatch),
                13 => ::std::option::Option::Some(FailureType::Failure_WipeCodeMismatch),
                14 => ::std::option::Option::Some(FailureType::Failure_InvalidSession),
                99 => ::std::option::Option::Some(FailureType::Failure_FirmwareError),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<FailureType> {
            match str {
                "Failure_UnexpectedMessage" => ::std::option::Option::Some(FailureType::Failure_UnexpectedMessage),
                "Failure_ButtonExpected" => ::std::option::Option::Some(FailureType::Failure_ButtonExpected),
                "Failure_DataError" => ::std::option::Option::Some(FailureType::Failure_DataError),
                "Failure_ActionCancelled" => ::std::option::Option::Some(FailureType::Failure_ActionCancelled),
                "Failure_PinExpected" => ::std::option::Option::Some(FailureType::Failure_PinExpected),
                "Failure_PinCancelled" => ::std::option::Option::Some(FailureType::Failure_PinCancelled),
                "Failure_PinInvalid" => ::std::option::Option::Some(FailureType::Failure_PinInvalid),
                "Failure_InvalidSignature" => ::std::option::Option::Some(FailureType::Failure_InvalidSignature),
                "Failure_ProcessError" => ::std::option::Option::Some(FailureType::Failure_ProcessError),
                "Failure_NotEnoughFunds" => ::std::option::Option::Some(FailureType::Failure_NotEnoughFunds),
                "Failure_NotInitialized" => ::std::option::Option::Some(FailureType::Failure_NotInitialized),
                "Failure_PinMismatch" => ::std::option::Option::Some(FailureType::Failure_PinMismatch),
                "Failure_WipeCodeMismatch" => ::std::option::Option::Some(FailureType::Failure_WipeCodeMismatch),
                "Failure_InvalidSession" => ::std::option::Option::Some(FailureType::Failure_InvalidSession),
                "Failure_FirmwareError" => ::std::option::Option::Some(FailureType::Failure_FirmwareError),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [FailureType] = &[
            FailureType::Failure_UnexpectedMessage,
            FailureType::Failure_ButtonExpected,
            FailureType::Failure_DataError,
            FailureType::Failure_ActionCancelled,
            FailureType::Failure_PinExpected,
            FailureType::Failure_PinCancelled,
            FailureType::Failure_PinInvalid,
            FailureType::Failure_InvalidSignature,
            FailureType::Failure_ProcessError,
            FailureType::Failure_NotEnoughFunds,
            FailureType::Failure_NotInitialized,
            FailureType::Failure_PinMismatch,
            FailureType::Failure_WipeCodeMismatch,
            FailureType::Failure_InvalidSession,
            FailureType::Failure_FirmwareError,
        ];
    }

    impl ::protobuf::EnumFull for FailureType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Failure.FailureType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                FailureType::Failure_UnexpectedMessage => 0,
                FailureType::Failure_ButtonExpected => 1,
                FailureType::Failure_DataError => 2,
                FailureType::Failure_ActionCancelled => 3,
                FailureType::Failure_PinExpected => 4,
                FailureType::Failure_PinCancelled => 5,
                FailureType::Failure_PinInvalid => 6,
                FailureType::Failure_InvalidSignature => 7,
                FailureType::Failure_ProcessError => 8,
                FailureType::Failure_NotEnoughFunds => 9,
                FailureType::Failure_NotInitialized => 10,
                FailureType::Failure_PinMismatch => 11,
                FailureType::Failure_WipeCodeMismatch => 12,
                FailureType::Failure_InvalidSession => 13,
                FailureType::Failure_FirmwareError => 14,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for FailureType {
        fn default() -> Self {
            FailureType::Failure_UnexpectedMessage
        }
    }

    impl FailureType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FailureType>("Failure.FailureType")
        }
    }
}

// @@protoc_insertion_point(message:hw.trezor.messages.common.ButtonRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ButtonRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.common.ButtonRequest.code)
    pub code: ::std::option::Option<::protobuf::EnumOrUnknown<button_request::ButtonRequestType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.common.ButtonRequest.pages)
    pub pages: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.common.ButtonRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ButtonRequest {
    fn default() -> &'a ButtonRequest {
        <ButtonRequest as ::protobuf::Message>::default_instance()
    }
}

impl ButtonRequest {
    pub fn new() -> ButtonRequest {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.common.ButtonRequest.ButtonRequestType code = 1;

    pub fn code(&self) -> button_request::ButtonRequestType {
        match self.code {
            Some(e) => e.enum_value_or(button_request::ButtonRequestType::ButtonRequest_Other),
            None => button_request::ButtonRequestType::ButtonRequest_Other,
        }
    }

    pub fn clear_code(&mut self) {
        self.code = ::std::option::Option::None;
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: button_request::ButtonRequestType) {
        self.code = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 pages = 2;

    pub fn pages(&self) -> u32 {
        self.pages.unwrap_or(0)
    }

    pub fn clear_pages(&mut self) {
        self.pages = ::std::option::Option::None;
    }

    pub fn has_pages(&self) -> bool {
        self.pages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pages(&mut self, v: u32) {
        self.pages = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "code",
            |m: &ButtonRequest| { &m.code },
            |m: &mut ButtonRequest| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pages",
            |m: &ButtonRequest| { &m.pages },
            |m: &mut ButtonRequest| { &mut m.pages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ButtonRequest>(
            "ButtonRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ButtonRequest {
    const NAME: &'static str = "ButtonRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.pages = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.code {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.pages {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.code {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.pages {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ButtonRequest {
        ButtonRequest::new()
    }

    fn clear(&mut self) {
        self.code = ::std::option::Option::None;
        self.pages = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ButtonRequest {
        static instance: ButtonRequest = ButtonRequest {
            code: ::std::option::Option::None,
            pages: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ButtonRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ButtonRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ButtonRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ButtonRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ButtonRequest`
pub mod button_request {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:hw.trezor.messages.common.ButtonRequest.ButtonRequestType)
    pub enum ButtonRequestType {
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.ButtonRequest.ButtonRequestType.ButtonRequest_Other)
        ButtonRequest_Other = 1,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.ButtonRequest.ButtonRequestType.ButtonRequest_FeeOverThreshold)
        ButtonRequest_FeeOverThreshold = 2,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.ButtonRequest.ButtonRequestType.ButtonRequest_ConfirmOutput)
        ButtonRequest_ConfirmOutput = 3,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.ButtonRequest.ButtonRequestType.ButtonRequest_ResetDevice)
        ButtonRequest_ResetDevice = 4,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.ButtonRequest.ButtonRequestType.ButtonRequest_ConfirmWord)
        ButtonRequest_ConfirmWord = 5,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.ButtonRequest.ButtonRequestType.ButtonRequest_WipeDevice)
        ButtonRequest_WipeDevice = 6,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.ButtonRequest.ButtonRequestType.ButtonRequest_ProtectCall)
        ButtonRequest_ProtectCall = 7,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.ButtonRequest.ButtonRequestType.ButtonRequest_SignTx)
        ButtonRequest_SignTx = 8,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.ButtonRequest.ButtonRequestType.ButtonRequest_FirmwareCheck)
        ButtonRequest_FirmwareCheck = 9,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.ButtonRequest.ButtonRequestType.ButtonRequest_Address)
        ButtonRequest_Address = 10,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.ButtonRequest.ButtonRequestType.ButtonRequest_PublicKey)
        ButtonRequest_PublicKey = 11,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.ButtonRequest.ButtonRequestType.ButtonRequest_MnemonicWordCount)
        ButtonRequest_MnemonicWordCount = 12,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.ButtonRequest.ButtonRequestType.ButtonRequest_MnemonicInput)
        ButtonRequest_MnemonicInput = 13,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.ButtonRequest.ButtonRequestType._Deprecated_ButtonRequest_PassphraseType)
        _Deprecated_ButtonRequest_PassphraseType = 14,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.ButtonRequest.ButtonRequestType.ButtonRequest_UnknownDerivationPath)
        ButtonRequest_UnknownDerivationPath = 15,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.ButtonRequest.ButtonRequestType.ButtonRequest_RecoveryHomepage)
        ButtonRequest_RecoveryHomepage = 16,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.ButtonRequest.ButtonRequestType.ButtonRequest_Success)
        ButtonRequest_Success = 17,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.ButtonRequest.ButtonRequestType.ButtonRequest_Warning)
        ButtonRequest_Warning = 18,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.ButtonRequest.ButtonRequestType.ButtonRequest_PassphraseEntry)
        ButtonRequest_PassphraseEntry = 19,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.ButtonRequest.ButtonRequestType.ButtonRequest_PinEntry)
        ButtonRequest_PinEntry = 20,
    }

    impl ::protobuf::Enum for ButtonRequestType {
        const NAME: &'static str = "ButtonRequestType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ButtonRequestType> {
            match value {
                1 => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_Other),
                2 => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_FeeOverThreshold),
                3 => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_ConfirmOutput),
                4 => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_ResetDevice),
                5 => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_ConfirmWord),
                6 => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_WipeDevice),
                7 => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_ProtectCall),
                8 => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_SignTx),
                9 => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_FirmwareCheck),
                10 => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_Address),
                11 => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_PublicKey),
                12 => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_MnemonicWordCount),
                13 => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_MnemonicInput),
                14 => ::std::option::Option::Some(ButtonRequestType::_Deprecated_ButtonRequest_PassphraseType),
                15 => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_UnknownDerivationPath),
                16 => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_RecoveryHomepage),
                17 => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_Success),
                18 => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_Warning),
                19 => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_PassphraseEntry),
                20 => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_PinEntry),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ButtonRequestType> {
            match str {
                "ButtonRequest_Other" => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_Other),
                "ButtonRequest_FeeOverThreshold" => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_FeeOverThreshold),
                "ButtonRequest_ConfirmOutput" => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_ConfirmOutput),
                "ButtonRequest_ResetDevice" => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_ResetDevice),
                "ButtonRequest_ConfirmWord" => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_ConfirmWord),
                "ButtonRequest_WipeDevice" => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_WipeDevice),
                "ButtonRequest_ProtectCall" => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_ProtectCall),
                "ButtonRequest_SignTx" => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_SignTx),
                "ButtonRequest_FirmwareCheck" => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_FirmwareCheck),
                "ButtonRequest_Address" => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_Address),
                "ButtonRequest_PublicKey" => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_PublicKey),
                "ButtonRequest_MnemonicWordCount" => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_MnemonicWordCount),
                "ButtonRequest_MnemonicInput" => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_MnemonicInput),
                "_Deprecated_ButtonRequest_PassphraseType" => ::std::option::Option::Some(ButtonRequestType::_Deprecated_ButtonRequest_PassphraseType),
                "ButtonRequest_UnknownDerivationPath" => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_UnknownDerivationPath),
                "ButtonRequest_RecoveryHomepage" => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_RecoveryHomepage),
                "ButtonRequest_Success" => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_Success),
                "ButtonRequest_Warning" => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_Warning),
                "ButtonRequest_PassphraseEntry" => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_PassphraseEntry),
                "ButtonRequest_PinEntry" => ::std::option::Option::Some(ButtonRequestType::ButtonRequest_PinEntry),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ButtonRequestType] = &[
            ButtonRequestType::ButtonRequest_Other,
            ButtonRequestType::ButtonRequest_FeeOverThreshold,
            ButtonRequestType::ButtonRequest_ConfirmOutput,
            ButtonRequestType::ButtonRequest_ResetDevice,
            ButtonRequestType::ButtonRequest_ConfirmWord,
            ButtonRequestType::ButtonRequest_WipeDevice,
            ButtonRequestType::ButtonRequest_ProtectCall,
            ButtonRequestType::ButtonRequest_SignTx,
            ButtonRequestType::ButtonRequest_FirmwareCheck,
            ButtonRequestType::ButtonRequest_Address,
            ButtonRequestType::ButtonRequest_PublicKey,
            ButtonRequestType::ButtonRequest_MnemonicWordCount,
            ButtonRequestType::ButtonRequest_MnemonicInput,
            ButtonRequestType::_Deprecated_ButtonRequest_PassphraseType,
            ButtonRequestType::ButtonRequest_UnknownDerivationPath,
            ButtonRequestType::ButtonRequest_RecoveryHomepage,
            ButtonRequestType::ButtonRequest_Success,
            ButtonRequestType::ButtonRequest_Warning,
            ButtonRequestType::ButtonRequest_PassphraseEntry,
            ButtonRequestType::ButtonRequest_PinEntry,
        ];
    }

    impl ::protobuf::EnumFull for ButtonRequestType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ButtonRequest.ButtonRequestType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                ButtonRequestType::ButtonRequest_Other => 0,
                ButtonRequestType::ButtonRequest_FeeOverThreshold => 1,
                ButtonRequestType::ButtonRequest_ConfirmOutput => 2,
                ButtonRequestType::ButtonRequest_ResetDevice => 3,
                ButtonRequestType::ButtonRequest_ConfirmWord => 4,
                ButtonRequestType::ButtonRequest_WipeDevice => 5,
                ButtonRequestType::ButtonRequest_ProtectCall => 6,
                ButtonRequestType::ButtonRequest_SignTx => 7,
                ButtonRequestType::ButtonRequest_FirmwareCheck => 8,
                ButtonRequestType::ButtonRequest_Address => 9,
                ButtonRequestType::ButtonRequest_PublicKey => 10,
                ButtonRequestType::ButtonRequest_MnemonicWordCount => 11,
                ButtonRequestType::ButtonRequest_MnemonicInput => 12,
                ButtonRequestType::_Deprecated_ButtonRequest_PassphraseType => 13,
                ButtonRequestType::ButtonRequest_UnknownDerivationPath => 14,
                ButtonRequestType::ButtonRequest_RecoveryHomepage => 15,
                ButtonRequestType::ButtonRequest_Success => 16,
                ButtonRequestType::ButtonRequest_Warning => 17,
                ButtonRequestType::ButtonRequest_PassphraseEntry => 18,
                ButtonRequestType::ButtonRequest_PinEntry => 19,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for ButtonRequestType {
        fn default() -> Self {
            ButtonRequestType::ButtonRequest_Other
        }
    }

    impl ButtonRequestType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ButtonRequestType>("ButtonRequest.ButtonRequestType")
        }
    }
}

// @@protoc_insertion_point(message:hw.trezor.messages.common.ButtonAck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ButtonAck {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.common.ButtonAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ButtonAck {
    fn default() -> &'a ButtonAck {
        <ButtonAck as ::protobuf::Message>::default_instance()
    }
}

impl ButtonAck {
    pub fn new() -> ButtonAck {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ButtonAck>(
            "ButtonAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ButtonAck {
    const NAME: &'static str = "ButtonAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ButtonAck {
        ButtonAck::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ButtonAck {
        static instance: ButtonAck = ButtonAck {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ButtonAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ButtonAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ButtonAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ButtonAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.common.PinMatrixRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PinMatrixRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.common.PinMatrixRequest.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<pin_matrix_request::PinMatrixRequestType>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.common.PinMatrixRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PinMatrixRequest {
    fn default() -> &'a PinMatrixRequest {
        <PinMatrixRequest as ::protobuf::Message>::default_instance()
    }
}

impl PinMatrixRequest {
    pub fn new() -> PinMatrixRequest {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.common.PinMatrixRequest.PinMatrixRequestType type = 1;

    pub fn type_(&self) -> pin_matrix_request::PinMatrixRequestType {
        match self.type_ {
            Some(e) => e.enum_value_or(pin_matrix_request::PinMatrixRequestType::PinMatrixRequestType_Current),
            None => pin_matrix_request::PinMatrixRequestType::PinMatrixRequestType_Current,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: pin_matrix_request::PinMatrixRequestType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &PinMatrixRequest| { &m.type_ },
            |m: &mut PinMatrixRequest| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PinMatrixRequest>(
            "PinMatrixRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PinMatrixRequest {
    const NAME: &'static str = "PinMatrixRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PinMatrixRequest {
        PinMatrixRequest::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PinMatrixRequest {
        static instance: PinMatrixRequest = PinMatrixRequest {
            type_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PinMatrixRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PinMatrixRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PinMatrixRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PinMatrixRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PinMatrixRequest`
pub mod pin_matrix_request {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:hw.trezor.messages.common.PinMatrixRequest.PinMatrixRequestType)
    pub enum PinMatrixRequestType {
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.PinMatrixRequest.PinMatrixRequestType.PinMatrixRequestType_Current)
        PinMatrixRequestType_Current = 1,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.PinMatrixRequest.PinMatrixRequestType.PinMatrixRequestType_NewFirst)
        PinMatrixRequestType_NewFirst = 2,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.PinMatrixRequest.PinMatrixRequestType.PinMatrixRequestType_NewSecond)
        PinMatrixRequestType_NewSecond = 3,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.PinMatrixRequest.PinMatrixRequestType.PinMatrixRequestType_WipeCodeFirst)
        PinMatrixRequestType_WipeCodeFirst = 4,
        // @@protoc_insertion_point(enum_value:hw.trezor.messages.common.PinMatrixRequest.PinMatrixRequestType.PinMatrixRequestType_WipeCodeSecond)
        PinMatrixRequestType_WipeCodeSecond = 5,
    }

    impl ::protobuf::Enum for PinMatrixRequestType {
        const NAME: &'static str = "PinMatrixRequestType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<PinMatrixRequestType> {
            match value {
                1 => ::std::option::Option::Some(PinMatrixRequestType::PinMatrixRequestType_Current),
                2 => ::std::option::Option::Some(PinMatrixRequestType::PinMatrixRequestType_NewFirst),
                3 => ::std::option::Option::Some(PinMatrixRequestType::PinMatrixRequestType_NewSecond),
                4 => ::std::option::Option::Some(PinMatrixRequestType::PinMatrixRequestType_WipeCodeFirst),
                5 => ::std::option::Option::Some(PinMatrixRequestType::PinMatrixRequestType_WipeCodeSecond),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<PinMatrixRequestType> {
            match str {
                "PinMatrixRequestType_Current" => ::std::option::Option::Some(PinMatrixRequestType::PinMatrixRequestType_Current),
                "PinMatrixRequestType_NewFirst" => ::std::option::Option::Some(PinMatrixRequestType::PinMatrixRequestType_NewFirst),
                "PinMatrixRequestType_NewSecond" => ::std::option::Option::Some(PinMatrixRequestType::PinMatrixRequestType_NewSecond),
                "PinMatrixRequestType_WipeCodeFirst" => ::std::option::Option::Some(PinMatrixRequestType::PinMatrixRequestType_WipeCodeFirst),
                "PinMatrixRequestType_WipeCodeSecond" => ::std::option::Option::Some(PinMatrixRequestType::PinMatrixRequestType_WipeCodeSecond),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [PinMatrixRequestType] = &[
            PinMatrixRequestType::PinMatrixRequestType_Current,
            PinMatrixRequestType::PinMatrixRequestType_NewFirst,
            PinMatrixRequestType::PinMatrixRequestType_NewSecond,
            PinMatrixRequestType::PinMatrixRequestType_WipeCodeFirst,
            PinMatrixRequestType::PinMatrixRequestType_WipeCodeSecond,
        ];
    }

    impl ::protobuf::EnumFull for PinMatrixRequestType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("PinMatrixRequest.PinMatrixRequestType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                PinMatrixRequestType::PinMatrixRequestType_Current => 0,
                PinMatrixRequestType::PinMatrixRequestType_NewFirst => 1,
                PinMatrixRequestType::PinMatrixRequestType_NewSecond => 2,
                PinMatrixRequestType::PinMatrixRequestType_WipeCodeFirst => 3,
                PinMatrixRequestType::PinMatrixRequestType_WipeCodeSecond => 4,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for PinMatrixRequestType {
        fn default() -> Self {
            PinMatrixRequestType::PinMatrixRequestType_Current
        }
    }

    impl PinMatrixRequestType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PinMatrixRequestType>("PinMatrixRequest.PinMatrixRequestType")
        }
    }
}

// @@protoc_insertion_point(message:hw.trezor.messages.common.PinMatrixAck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PinMatrixAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.common.PinMatrixAck.pin)
    pub pin: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.common.PinMatrixAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PinMatrixAck {
    fn default() -> &'a PinMatrixAck {
        <PinMatrixAck as ::protobuf::Message>::default_instance()
    }
}

impl PinMatrixAck {
    pub fn new() -> PinMatrixAck {
        ::std::default::Default::default()
    }

    // required string pin = 1;

    pub fn pin(&self) -> &str {
        match self.pin.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pin(&mut self) {
        self.pin = ::std::option::Option::None;
    }

    pub fn has_pin(&self) -> bool {
        self.pin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pin(&mut self, v: ::std::string::String) {
        self.pin = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pin(&mut self) -> &mut ::std::string::String {
        if self.pin.is_none() {
            self.pin = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pin.as_mut().unwrap()
    }

    // Take field
    pub fn take_pin(&mut self) -> ::std::string::String {
        self.pin.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pin",
            |m: &PinMatrixAck| { &m.pin },
            |m: &mut PinMatrixAck| { &mut m.pin },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PinMatrixAck>(
            "PinMatrixAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PinMatrixAck {
    const NAME: &'static str = "PinMatrixAck";

    fn is_initialized(&self) -> bool {
        if self.pin.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pin = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pin.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pin.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PinMatrixAck {
        PinMatrixAck::new()
    }

    fn clear(&mut self) {
        self.pin = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PinMatrixAck {
        static instance: PinMatrixAck = PinMatrixAck {
            pin: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PinMatrixAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PinMatrixAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PinMatrixAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PinMatrixAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.common.PassphraseRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PassphraseRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.common.PassphraseRequest._on_device)
    pub _on_device: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.common.PassphraseRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PassphraseRequest {
    fn default() -> &'a PassphraseRequest {
        <PassphraseRequest as ::protobuf::Message>::default_instance()
    }
}

impl PassphraseRequest {
    pub fn new() -> PassphraseRequest {
        ::std::default::Default::default()
    }

    // optional bool _on_device = 1;

    pub fn _on_device(&self) -> bool {
        self._on_device.unwrap_or(false)
    }

    pub fn clear__on_device(&mut self) {
        self._on_device = ::std::option::Option::None;
    }

    pub fn has__on_device(&self) -> bool {
        self._on_device.is_some()
    }

    // Param is passed by value, moved
    pub fn set__on_device(&mut self, v: bool) {
        self._on_device = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "_on_device",
            |m: &PassphraseRequest| { &m._on_device },
            |m: &mut PassphraseRequest| { &mut m._on_device },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PassphraseRequest>(
            "PassphraseRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PassphraseRequest {
    const NAME: &'static str = "PassphraseRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self._on_device = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self._on_device {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self._on_device {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PassphraseRequest {
        PassphraseRequest::new()
    }

    fn clear(&mut self) {
        self._on_device = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PassphraseRequest {
        static instance: PassphraseRequest = PassphraseRequest {
            _on_device: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PassphraseRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PassphraseRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PassphraseRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PassphraseRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.common.PassphraseAck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PassphraseAck {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.common.PassphraseAck.passphrase)
    pub passphrase: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:hw.trezor.messages.common.PassphraseAck._state)
    pub _state: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.common.PassphraseAck.on_device)
    pub on_device: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.common.PassphraseAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PassphraseAck {
    fn default() -> &'a PassphraseAck {
        <PassphraseAck as ::protobuf::Message>::default_instance()
    }
}

impl PassphraseAck {
    pub fn new() -> PassphraseAck {
        ::std::default::Default::default()
    }

    // optional string passphrase = 1;

    pub fn passphrase(&self) -> &str {
        match self.passphrase.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_passphrase(&mut self) {
        self.passphrase = ::std::option::Option::None;
    }

    pub fn has_passphrase(&self) -> bool {
        self.passphrase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passphrase(&mut self, v: ::std::string::String) {
        self.passphrase = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_passphrase(&mut self) -> &mut ::std::string::String {
        if self.passphrase.is_none() {
            self.passphrase = ::std::option::Option::Some(::std::string::String::new());
        }
        self.passphrase.as_mut().unwrap()
    }

    // Take field
    pub fn take_passphrase(&mut self) -> ::std::string::String {
        self.passphrase.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes _state = 2;

    pub fn _state(&self) -> &[u8] {
        match self._state.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear__state(&mut self) {
        self._state = ::std::option::Option::None;
    }

    pub fn has__state(&self) -> bool {
        self._state.is_some()
    }

    // Param is passed by value, moved
    pub fn set__state(&mut self, v: ::std::vec::Vec<u8>) {
        self._state = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut__state(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self._state.is_none() {
            self._state = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self._state.as_mut().unwrap()
    }

    // Take field
    pub fn take__state(&mut self) -> ::std::vec::Vec<u8> {
        self._state.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool on_device = 3;

    pub fn on_device(&self) -> bool {
        self.on_device.unwrap_or(false)
    }

    pub fn clear_on_device(&mut self) {
        self.on_device = ::std::option::Option::None;
    }

    pub fn has_on_device(&self) -> bool {
        self.on_device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_on_device(&mut self, v: bool) {
        self.on_device = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "passphrase",
            |m: &PassphraseAck| { &m.passphrase },
            |m: &mut PassphraseAck| { &mut m.passphrase },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "_state",
            |m: &PassphraseAck| { &m._state },
            |m: &mut PassphraseAck| { &mut m._state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "on_device",
            |m: &PassphraseAck| { &m.on_device },
            |m: &mut PassphraseAck| { &mut m.on_device },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PassphraseAck>(
            "PassphraseAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PassphraseAck {
    const NAME: &'static str = "PassphraseAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.passphrase = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self._state = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.on_device = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.passphrase.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self._state.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.on_device {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.passphrase.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self._state.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.on_device {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PassphraseAck {
        PassphraseAck::new()
    }

    fn clear(&mut self) {
        self.passphrase = ::std::option::Option::None;
        self._state = ::std::option::Option::None;
        self.on_device = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PassphraseAck {
        static instance: PassphraseAck = PassphraseAck {
            passphrase: ::std::option::Option::None,
            _state: ::std::option::Option::None,
            on_device: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PassphraseAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PassphraseAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PassphraseAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PassphraseAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.common.Deprecated_PassphraseStateRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Deprecated_PassphraseStateRequest {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.common.Deprecated_PassphraseStateRequest.state)
    pub state: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.common.Deprecated_PassphraseStateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Deprecated_PassphraseStateRequest {
    fn default() -> &'a Deprecated_PassphraseStateRequest {
        <Deprecated_PassphraseStateRequest as ::protobuf::Message>::default_instance()
    }
}

impl Deprecated_PassphraseStateRequest {
    pub fn new() -> Deprecated_PassphraseStateRequest {
        ::std::default::Default::default()
    }

    // optional bytes state = 1;

    pub fn state(&self) -> &[u8] {
        match self.state.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::vec::Vec<u8>) {
        self.state = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.state.is_none() {
            self.state = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::vec::Vec<u8> {
        self.state.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "state",
            |m: &Deprecated_PassphraseStateRequest| { &m.state },
            |m: &mut Deprecated_PassphraseStateRequest| { &mut m.state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Deprecated_PassphraseStateRequest>(
            "Deprecated_PassphraseStateRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Deprecated_PassphraseStateRequest {
    const NAME: &'static str = "Deprecated_PassphraseStateRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.state = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.state.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.state.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Deprecated_PassphraseStateRequest {
        Deprecated_PassphraseStateRequest::new()
    }

    fn clear(&mut self) {
        self.state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Deprecated_PassphraseStateRequest {
        static instance: Deprecated_PassphraseStateRequest = Deprecated_PassphraseStateRequest {
            state: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Deprecated_PassphraseStateRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Deprecated_PassphraseStateRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Deprecated_PassphraseStateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Deprecated_PassphraseStateRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.common.Deprecated_PassphraseStateAck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Deprecated_PassphraseStateAck {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.common.Deprecated_PassphraseStateAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Deprecated_PassphraseStateAck {
    fn default() -> &'a Deprecated_PassphraseStateAck {
        <Deprecated_PassphraseStateAck as ::protobuf::Message>::default_instance()
    }
}

impl Deprecated_PassphraseStateAck {
    pub fn new() -> Deprecated_PassphraseStateAck {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Deprecated_PassphraseStateAck>(
            "Deprecated_PassphraseStateAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Deprecated_PassphraseStateAck {
    const NAME: &'static str = "Deprecated_PassphraseStateAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Deprecated_PassphraseStateAck {
        Deprecated_PassphraseStateAck::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Deprecated_PassphraseStateAck {
        static instance: Deprecated_PassphraseStateAck = Deprecated_PassphraseStateAck {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Deprecated_PassphraseStateAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Deprecated_PassphraseStateAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Deprecated_PassphraseStateAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Deprecated_PassphraseStateAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:hw.trezor.messages.common.HDNodeType)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HDNodeType {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.common.HDNodeType.depth)
    pub depth: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.common.HDNodeType.fingerprint)
    pub fingerprint: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.common.HDNodeType.child_num)
    pub child_num: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.common.HDNodeType.chain_code)
    pub chain_code: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.common.HDNodeType.private_key)
    pub private_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.common.HDNodeType.public_key)
    pub public_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.common.HDNodeType.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HDNodeType {
    fn default() -> &'a HDNodeType {
        <HDNodeType as ::protobuf::Message>::default_instance()
    }
}

impl HDNodeType {
    pub fn new() -> HDNodeType {
        ::std::default::Default::default()
    }

    // required uint32 depth = 1;

    pub fn depth(&self) -> u32 {
        self.depth.unwrap_or(0)
    }

    pub fn clear_depth(&mut self) {
        self.depth = ::std::option::Option::None;
    }

    pub fn has_depth(&self) -> bool {
        self.depth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depth(&mut self, v: u32) {
        self.depth = ::std::option::Option::Some(v);
    }

    // required uint32 fingerprint = 2;

    pub fn fingerprint(&self) -> u32 {
        self.fingerprint.unwrap_or(0)
    }

    pub fn clear_fingerprint(&mut self) {
        self.fingerprint = ::std::option::Option::None;
    }

    pub fn has_fingerprint(&self) -> bool {
        self.fingerprint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fingerprint(&mut self, v: u32) {
        self.fingerprint = ::std::option::Option::Some(v);
    }

    // required uint32 child_num = 3;

    pub fn child_num(&self) -> u32 {
        self.child_num.unwrap_or(0)
    }

    pub fn clear_child_num(&mut self) {
        self.child_num = ::std::option::Option::None;
    }

    pub fn has_child_num(&self) -> bool {
        self.child_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_child_num(&mut self, v: u32) {
        self.child_num = ::std::option::Option::Some(v);
    }

    // required bytes chain_code = 4;

    pub fn chain_code(&self) -> &[u8] {
        match self.chain_code.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_chain_code(&mut self) {
        self.chain_code = ::std::option::Option::None;
    }

    pub fn has_chain_code(&self) -> bool {
        self.chain_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chain_code(&mut self, v: ::std::vec::Vec<u8>) {
        self.chain_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chain_code(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.chain_code.is_none() {
            self.chain_code = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.chain_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_chain_code(&mut self) -> ::std::vec::Vec<u8> {
        self.chain_code.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes private_key = 5;

    pub fn private_key(&self) -> &[u8] {
        match self.private_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_private_key(&mut self) {
        self.private_key = ::std::option::Option::None;
    }

    pub fn has_private_key(&self) -> bool {
        self.private_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_private_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.private_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_private_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.private_key.is_none() {
            self.private_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.private_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_private_key(&mut self) -> ::std::vec::Vec<u8> {
        self.private_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes public_key = 6;

    pub fn public_key(&self) -> &[u8] {
        match self.public_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_public_key(&mut self) {
        self.public_key = ::std::option::Option::None;
    }

    pub fn has_public_key(&self) -> bool {
        self.public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.public_key.is_none() {
            self.public_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "depth",
            |m: &HDNodeType| { &m.depth },
            |m: &mut HDNodeType| { &mut m.depth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fingerprint",
            |m: &HDNodeType| { &m.fingerprint },
            |m: &mut HDNodeType| { &mut m.fingerprint },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "child_num",
            |m: &HDNodeType| { &m.child_num },
            |m: &mut HDNodeType| { &mut m.child_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chain_code",
            |m: &HDNodeType| { &m.chain_code },
            |m: &mut HDNodeType| { &mut m.chain_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "private_key",
            |m: &HDNodeType| { &m.private_key },
            |m: &mut HDNodeType| { &mut m.private_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "public_key",
            |m: &HDNodeType| { &m.public_key },
            |m: &mut HDNodeType| { &mut m.public_key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HDNodeType>(
            "HDNodeType",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HDNodeType {
    const NAME: &'static str = "HDNodeType";

    fn is_initialized(&self) -> bool {
        if self.depth.is_none() {
            return false;
        }
        if self.fingerprint.is_none() {
            return false;
        }
        if self.child_num.is_none() {
            return false;
        }
        if self.chain_code.is_none() {
            return false;
        }
        if self.public_key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.depth = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.fingerprint = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.child_num = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.chain_code = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.private_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                50 => {
                    self.public_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.depth {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.fingerprint {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.child_num {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.chain_code.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.private_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.depth {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.fingerprint {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.child_num {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.chain_code.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.private_key.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.public_key.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HDNodeType {
        HDNodeType::new()
    }

    fn clear(&mut self) {
        self.depth = ::std::option::Option::None;
        self.fingerprint = ::std::option::Option::None;
        self.child_num = ::std::option::Option::None;
        self.chain_code = ::std::option::Option::None;
        self.private_key = ::std::option::Option::None;
        self.public_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HDNodeType {
        static instance: HDNodeType = HDNodeType {
            depth: ::std::option::Option::None,
            fingerprint: ::std::option::Option::None,
            child_num: ::std::option::Option::None,
            chain_code: ::std::option::Option::None,
            private_key: ::std::option::Option::None,
            public_key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HDNodeType {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HDNodeType").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HDNodeType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HDNodeType {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15messages-common.proto\x12\x19hw.trezor.messages.common\x1a\x0emess\
    ages.proto\"%\n\x07Success\x12\x1a\n\x07message\x18\x01\x20\x01(\t:\0R\
    \x07message\"\x8f\x04\n\x07Failure\x12B\n\x04code\x18\x01\x20\x01(\x0e2.\
    .hw.trezor.messages.common.Failure.FailureTypeR\x04code\x12\x18\n\x07mes\
    sage\x18\x02\x20\x01(\tR\x07message\"\xa5\x03\n\x0bFailureType\x12\x1d\n\
    \x19Failure_UnexpectedMessage\x10\x01\x12\x1a\n\x16Failure_ButtonExpecte\
    d\x10\x02\x12\x15\n\x11Failure_DataError\x10\x03\x12\x1b\n\x17Failure_Ac\
    tionCancelled\x10\x04\x12\x17\n\x13Failure_PinExpected\x10\x05\x12\x18\n\
    \x14Failure_PinCancelled\x10\x06\x12\x16\n\x12Failure_PinInvalid\x10\x07\
    \x12\x1c\n\x18Failure_InvalidSignature\x10\x08\x12\x18\n\x14Failure_Proc\
    essError\x10\t\x12\x1a\n\x16Failure_NotEnoughFunds\x10\n\x12\x1a\n\x16Fa\
    ilure_NotInitialized\x10\x0b\x12\x17\n\x13Failure_PinMismatch\x10\x0c\
    \x12\x1c\n\x18Failure_WipeCodeMismatch\x10\r\x12\x1a\n\x16Failure_Invali\
    dSession\x10\x0e\x12\x19\n\x15Failure_FirmwareError\x10c\"\x91\x06\n\rBu\
    ttonRequest\x12N\n\x04code\x18\x01\x20\x01(\x0e2:.hw.trezor.messages.com\
    mon.ButtonRequest.ButtonRequestTypeR\x04code\x12\x14\n\x05pages\x18\x02\
    \x20\x01(\rR\x05pages\"\x99\x05\n\x11ButtonRequestType\x12\x17\n\x13Butt\
    onRequest_Other\x10\x01\x12\"\n\x1eButtonRequest_FeeOverThreshold\x10\
    \x02\x12\x1f\n\x1bButtonRequest_ConfirmOutput\x10\x03\x12\x1d\n\x19Butto\
    nRequest_ResetDevice\x10\x04\x12\x1d\n\x19ButtonRequest_ConfirmWord\x10\
    \x05\x12\x1c\n\x18ButtonRequest_WipeDevice\x10\x06\x12\x1d\n\x19ButtonRe\
    quest_ProtectCall\x10\x07\x12\x18\n\x14ButtonRequest_SignTx\x10\x08\x12\
    \x1f\n\x1bButtonRequest_FirmwareCheck\x10\t\x12\x19\n\x15ButtonRequest_A\
    ddress\x10\n\x12\x1b\n\x17ButtonRequest_PublicKey\x10\x0b\x12#\n\x1fButt\
    onRequest_MnemonicWordCount\x10\x0c\x12\x1f\n\x1bButtonRequest_MnemonicI\
    nput\x10\r\x120\n(_Deprecated_ButtonRequest_PassphraseType\x10\x0e\x1a\
    \x02\x08\x01\x12'\n#ButtonRequest_UnknownDerivationPath\x10\x0f\x12\"\n\
    \x1eButtonRequest_RecoveryHomepage\x10\x10\x12\x19\n\x15ButtonRequest_Su\
    ccess\x10\x11\x12\x19\n\x15ButtonRequest_Warning\x10\x12\x12!\n\x1dButto\
    nRequest_PassphraseEntry\x10\x13\x12\x1a\n\x16ButtonRequest_PinEntry\x10\
    \x14\"\x0b\n\tButtonAck\"\xbb\x02\n\x10PinMatrixRequest\x12T\n\x04type\
    \x18\x01\x20\x01(\x0e2@.hw.trezor.messages.common.PinMatrixRequest.PinMa\
    trixRequestTypeR\x04type\"\xd0\x01\n\x14PinMatrixRequestType\x12\x20\n\
    \x1cPinMatrixRequestType_Current\x10\x01\x12!\n\x1dPinMatrixRequestType_\
    NewFirst\x10\x02\x12\"\n\x1ePinMatrixRequestType_NewSecond\x10\x03\x12&\
    \n\"PinMatrixRequestType_WipeCodeFirst\x10\x04\x12'\n#PinMatrixRequestTy\
    pe_WipeCodeSecond\x10\x05\"\x20\n\x0cPinMatrixAck\x12\x10\n\x03pin\x18\
    \x01\x20\x02(\tR\x03pin\"5\n\x11PassphraseRequest\x12\x20\n\n_on_device\
    \x18\x01\x20\x01(\x08R\x08OnDeviceB\x02\x18\x01\"g\n\rPassphraseAck\x12\
    \x1e\n\npassphrase\x18\x01\x20\x01(\tR\npassphrase\x12\x19\n\x06_state\
    \x18\x02\x20\x01(\x0cR\x05StateB\x02\x18\x01\x12\x1b\n\ton_device\x18\
    \x03\x20\x01(\x08R\x08onDevice\"=\n!Deprecated_PassphraseStateRequest\
    \x12\x14\n\x05state\x18\x01\x20\x01(\x0cR\x05state:\x02\x18\x01\"#\n\x1d\
    Deprecated_PassphraseStateAck:\x02\x18\x01\"\xc0\x01\n\nHDNodeType\x12\
    \x14\n\x05depth\x18\x01\x20\x02(\rR\x05depth\x12\x20\n\x0bfingerprint\
    \x18\x02\x20\x02(\rR\x0bfingerprint\x12\x1b\n\tchild_num\x18\x03\x20\x02\
    (\rR\x08childNum\x12\x1d\n\nchain_code\x18\x04\x20\x02(\x0cR\tchainCode\
    \x12\x1f\n\x0bprivate_key\x18\x05\x20\x01(\x0cR\nprivateKey\x12\x1d\n\np\
    ublic_key\x18\x06\x20\x02(\x0cR\tpublicKeyB>\n#com.satoshilabs.trezor.li\
    b.protobufB\x13TrezorMessageCommon\x80\xa6\x1d\x01\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::messages::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(11);
            messages.push(Success::generated_message_descriptor_data());
            messages.push(Failure::generated_message_descriptor_data());
            messages.push(ButtonRequest::generated_message_descriptor_data());
            messages.push(ButtonAck::generated_message_descriptor_data());
            messages.push(PinMatrixRequest::generated_message_descriptor_data());
            messages.push(PinMatrixAck::generated_message_descriptor_data());
            messages.push(PassphraseRequest::generated_message_descriptor_data());
            messages.push(PassphraseAck::generated_message_descriptor_data());
            messages.push(Deprecated_PassphraseStateRequest::generated_message_descriptor_data());
            messages.push(Deprecated_PassphraseStateAck::generated_message_descriptor_data());
            messages.push(HDNodeType::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(failure::FailureType::generated_enum_descriptor_data());
            enums.push(button_request::ButtonRequestType::generated_enum_descriptor_data());
            enums.push(pin_matrix_request::PinMatrixRequestType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
