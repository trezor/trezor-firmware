{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Trezorlib","text":"<p>Python library and command-line client for communicating with Trezor Hardware Wallet.</p> <p>See https://trezor.io for more information.</p>"},{"location":"#install","title":"Install","text":"<p>Python Trezor tools require Python 3.6 or higher, and libusb 1.0. The easiest way to install it is with <code>pip</code>. The rest of this guide assumes you have a working <code>pip</code>; if not, you can refer to this guide.</p> <p>On a typical system, you already have all you need. Install <code>trezor</code> with:</p> <pre><code>pip3 install trezor\n</code></pre> <p>On Windows, you also need to either install Trezor Bridge, or libusb and the appropriate drivers.</p>"},{"location":"#firmware-version-requirements","title":"Firmware version requirements","text":"<p>Current trezorlib version supports Trezor One version 1.8.0 and up, and Trezor T version 2.1.0 and up.</p> <p>For firmware versions below 1.8.0 and 2.1.0 respectively, the only supported operation is \"upgrade firmware\".</p> <p>Trezor One with firmware older than 1.7.0 and bootloader older than 1.6.0 (including pre-2021 fresh-out-of-the-box units) will not be recognized, unless you install HIDAPI support (see below).</p>"},{"location":"#installation-options","title":"Installation options","text":"<ul> <li>Ethereum: To support Ethereum signing from command line, additional packages are   needed. Install with:</li> </ul> <pre><code>pip3 install trezor[ethereum]\n</code></pre> <ul> <li>Stellar: To support Stellar signing from command line, additional packages are   needed. Install with:</li> </ul> <pre><code>pip3 install trezor[stellar]\n</code></pre> <ul> <li>Firmware-less Trezor One: If you are setting up a brand new Trezor One   manufactured before 2021 (with pre-installed bootloader older than 1.6.0), you will   need HIDAPI support. On Linux, you will need the following packages (or their   equivalents) as prerequisites: <code>python3-dev</code>, <code>cython3</code>, <code>libusb-1.0-0-dev</code>,   <code>libudev-dev</code>.</li> </ul> <p>Install with:</p> <pre><code>pip3 install trezor[hidapi]\n</code></pre> <p>To install all three, use <code>pip3 install trezor[hidapi,ethereum,stellar]</code>.</p>"},{"location":"#distro-packages","title":"Distro packages","text":"<p>Check out Repology to see if your operating system has an up-to-date python-trezor package.</p>"},{"location":"#installing-latest-version-from-github","title":"Installing latest version from GitHub","text":"<pre><code>pip3 install \"git+https://github.com/trezor/trezor-firmware#egg=trezor&amp;subdirectory=python\"\n</code></pre>"},{"location":"#running-from-source","title":"Running from source","text":"<p>Install the Poetry tool, checkout <code>trezor-firmware</code> from git, and enter the poetry shell:</p> <pre><code>pip3 install poetry\ngit clone https://github.com/trezor/trezor-firmware\ncd trezor-firmware\npoetry install\npoetry shell\n</code></pre> <p>In this environment, trezorlib and the <code>trezorctl</code> tool is running from the live sources, so your changes are immediately effective.</p>"},{"location":"#command-line-client-trezorctl","title":"Command line client (trezorctl)","text":"<p>The included <code>trezorctl</code> python script can perform various tasks such as changing setting in the Trezor, signing transactions, retrieving account info and addresses. See the python/docs/ sub folder for detailed examples and options.</p> <p>NOTE: An older version of the <code>trezorctl</code> command is available for Debian Stretch (and comes pre-installed on Tails OS).</p>"},{"location":"#python-library","title":"Python Library","text":"<p>You can use this python library to interact with a Trezor and use its capabilities in your application. See examples here in the tools/ sub folder.</p>"},{"location":"#pin-entering","title":"PIN Entering","text":"<p>When you are asked for PIN, you have to enter scrambled PIN. Follow the numbers shown on Trezor display and enter the their positions using the numeric keyboard mapping:</p> 7 8 9 4 5 6 1 2 3 <p>Example: your PIN is 1234 and Trezor is displaying the following:</p> 2 8 3 5 4 6 7 9 1 <p>You have to enter: 3795</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to change protobuf or coin definitions, you will need to regenerate definitions in the <code>python/</code> subdirectory.</p> <p>First, make sure your submodules are up-to-date with:</p> <pre><code>git submodule update --init --recursive\n</code></pre> <p>Then, rebuild the protobuf messages by running, from the <code>trezor-firmware</code> top-level directory:</p> <pre><code>make gen\n</code></pre> <p>To get support for BTC-like coins, these steps are enough and no further changes to the library are necessary.</p>"},{"location":"EXAMPLES/","title":"Examples demonstrating how to use trezorctl","text":"<p>Show all available options:</p> <pre><code>$ trezorctl --help\n</code></pre> <p>Retrieve features, settings and coin types supported by your device:</p> <pre><code>$ trezorctl get-features\n</code></pre>"},{"location":"EXAMPLES/#bitcoin-examples","title":"Bitcoin examples","text":"<p>Get first receiving address of first account for Bitcoin (Legacy / non-SegWit):</p> <pre><code>$ trezorctl btc get-address --script-type address --address m/44h/0h/0h/0/0\n</code></pre> <p>Get first receiving address of first account for Bitcoin (SegWit-in-P2SH):</p> <pre><code>$ trezorctl btc get-address --script-type p2shsegwit --address m/49h/0h/0h/0/0\n</code></pre> <p>Get first receiving address of first account for Bitcoin (Bech32 native SegWit P2WPKH):</p> <pre><code>trezorctl btc get-address --script-type segwit --address m/84h/0h/0h/0/0\n</code></pre> <p>Get Legacy Bitcoin <code>xpub</code> (can be used to create a watch-only wallet):</p> <pre><code>trezorctl btc get-public-node --address m/44h/0h/0h\n</code></pre>"},{"location":"EXAMPLES/#transaction-signing","title":"Transaction signing","text":"<p><code>trezorctl</code> supports offline signing of transactions in a custom JSON format. If you have transaction data in file <code>tx.json</code>, use the following call to get the signature:</p> <pre><code>$ trezorctl btc sign-tx tx.json\nPlease confirm action on your Trezor device\n\nSigned transaction:\n02000000025a6bdf3ac73e3e7047380d484e2f7d58ea633a509b9a63fe95fab84d64(...)\n</code></pre> <p>A provided script can be used to sign transactions interactively. You will need the following pieces of info:</p> <p>1)  Transaction ID containing the Output we want to spend (aka     <code>prevhash</code> or <code>a5ea715a...d201e64e</code> in example below). 2)  Index number of the Output being spent from the above tx (aka     <code>previndex</code> or <code>0</code> in example below). 3)  BIP32 path to the Node which can spend the above UTXO (eg     <code>Bitcoin/0h/0/0</code> for the first). 4)  Destination address where you want to send funds (eg     <code>3M8XGFBKwkf7miBzpkU3x2DoWwAVrD1mhk</code> below). 5)  Amount to send in satoshis - <code>91305</code> in the example below (multiply     BTC amount 0.00091305 by 100,000,000). 6)  Expected fee (<code>0.00019695</code> BTC in example below). Note: the miner     receives all satoshis left unspent from a transaction. If you want     to receive some change, you need to send it to an address you own     (otherwise it will go to miner). Fee is not needed below, we just     want it as a sanity check.</p> <p>There are many ways to retrieve the info above: from a watch-only wallet in Bitcoin Core, https://coinb.in (screenshot) etc. The easiest way is using the Trezor Suite: https://suite.trezor.io</p> <p>After authenticating, open the \\\"Send\\\" tab, fill-out all details, then open the \\\"Show transaction details\\\" menu to see the info needed above (screenshot). Once you have the required details, you can then perform the transaction signing using <code>trezorctl</code> as shown in the example below:</p> <pre><code>$ python3 tools/build_tx.py | trezorctl btc sign-tx -\n\nCoin name [Bitcoin]: Bitcoin\n\nPrevious output to spend (txid:vout) []: a5ea715aa99ca30516f3af6f622dfe7399d883d49ad74b1fe33fdf73d201e64e:0\nBIP-32 path to derive the key: Bitcoin/0h/0/0\nPrefilling input amount: 111000\nSequence Number to use (RBF opt-in enabled by default) [4294967293]: 4294967293\nInput type (address, segwit, p2shsegwit) [address]:\n\nPrevious output to spend (txid:vout) []:\n\nOutput address (for non-change output) []: 3M8XGFBKwkf7miBzpkU3x2DoWwAVrD1mhk\nAmount to spend (satoshis): 91305\n\nOutput address (for non-change output) []:\nBIP-32 path (for change output) []:\nTransaction version [2]:\nTransaction locktime [0]:\nPlease confirm action on your Trezor device\n\nSigned Transaction:\n02000000014ee601d273df3fe31f4bd79ad483d89973fe2d626faff316(...)\n</code></pre> <p>The signed transaction text can then be inspected in Electrum (screenshot), coinb.in or another tool. If all info is correct, you can then broadcast the tx to the Bitcoin network via the URL provided by <code>trezorctl</code> or Electrum (Tools \u2192 Load transaction \u2192 From text. Here is a screenshot). TIP: Electrum will only show the transaction fee if you previously imported the spending address (eg <code>16ijWp48xn8hj6deD5ZHSJcgNjtYbpiki8</code> from example tx above). Also, the final tx size (and therefore satoshis / byte) might be slightly different than the estimate shown on suite.trezor.io</p> <p>The final broadcast and mined transaction can be seen here: https://blockchain.info/tx/270684c14be85efec9adafa50339fd120658381ed2300b9207d0a0df2a5f0bf9</p>"},{"location":"EXAMPLES/#litecoin-examples","title":"Litecoin examples","text":"<p>Get first receiving address of first account for Litecoin (SegWit-in-P2SH):</p> <pre><code>$ trezorctl ltc get-address --script-type p2shsegwit --address m/49h/2h/0h/0/0\n</code></pre> <p>Get first receiving address of first account for Litecoin (Bech32 native SegWit P2WPKH):</p> <pre><code>$ trezorctl ltc get-address --script-type segwit --address m/84h/2h/0h/0/0\n</code></pre>"},{"location":"EXAMPLES/#notes","title":"Notes","text":"<ol> <li>Bech32 native SegWit encoded addresses require Trezor Firmware     v1.6.0 or later.</li> </ol>"},{"location":"OPTIONS/","title":"Command-line options for trezorctl","text":"<p>See EXAMPLES.md for examples on how to use.</p> <p><code>trezorctl</code> is split into a number of subcommands based on currency and/or functionality. The best way to get up-to-date help is to use the integrated help option.</p> <p>The full list of subcommands can be seen like so:</p> <pre><code>trezorctl --help\n</code></pre> <p>Each subcommand has its own help, shown with <code>trezorctl &lt;command&gt; --help</code>.</p>"},{"location":"OPTIONS/#list-of-subcommands","title":"List of subcommands","text":"<p>For convenience of search, the help texts of all commands and subcommands are listed on one page here.</p> <pre><code>Usage: trezorctl [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  -p, --path TEXT           Select device by specific path.\n  -v, --verbose             Show communication messages.\n  -j, --json                Print result as JSON object\n  -P, --passphrase-on-host  Enter passphrase on host.\n  -S, --script              Use UI for usage in scripts.\n  -s, --session-id HEX      Resume given session ID.\n  -r, --record TEXT         Record screen changes into a specified directory.\n  --version                 Show the version and exit.\n  --help                    Show this message and exit.\n\nCommands:\n  binance            Binance Chain commands.\n  btc                Bitcoin and Bitcoin-like coins commands.\n  cardano            Cardano commands.\n  clear-session      Clear session (remove cached PIN, passphrase, etc.).\n  cosi               CoSi (Cothority / collective signing) commands.\n  crypto             Miscellaneous cryptography features.\n  debug              Miscellaneous debug features.\n  device             Device management commands - setup, recover seed, wipe, etc.\n  eos                EOS commands.\n  ethereum           Ethereum commands.\n  fido               FIDO2, U2F and WebAuthN management commands.\n  firmware           Firmware commands.\n  get-features       Retrieve device features and settings.\n  get-session        Get a session ID for subsequent commands.\n  list               List connected Trezor devices.\n  monero             Monero commands.\n  nem                NEM commands.\n  ping               Send ping message.\n  ripple             Ripple commands.\n  set                Device settings.\n  stellar            Stellar commands.\n  tezos              Tezos commands.\n  usb-reset          Perform USB reset on stuck devices.\n  version            Show version of trezorctl/trezorlib.\n  wait-for-emulator  Wait until Trezor Emulator comes up.\n</code></pre>"},{"location":"OPTIONS/#binance-chain-commands","title":"Binance Chain commands.","text":"<pre><code>trezorctl binance --help\n</code></pre> <pre><code>Usage: trezorctl binance [OPTIONS] COMMAND [ARGS]...\n\n  Binance Chain commands.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  get-address     Get Binance address for specified path.\n  get-public-key  Get Binance public key.\n  sign-tx         Sign Binance transaction.\n</code></pre>"},{"location":"OPTIONS/#bitcoin-and-bitcoin-like-coins-commands","title":"Bitcoin and Bitcoin-like coins commands.","text":"<pre><code>trezorctl btc --help\n</code></pre> <pre><code>Usage: trezorctl btc [OPTIONS] COMMAND [ARGS]...\n\n  Bitcoin and Bitcoin-like coins commands.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  get-address      Get address for specified path.\n  get-descriptor   Get descriptor of given account.\n  get-public-node  Get public node of given path.\n  sign-message     Sign message using address of given path.\n  sign-tx          Sign transaction.\n  verify-message   Verify message.\n</code></pre>"},{"location":"OPTIONS/#cardano-commands","title":"Cardano commands.","text":"<pre><code>trezorctl cardano --help\n</code></pre> <pre><code>Usage: trezorctl cardano [OPTIONS] COMMAND [ARGS]...\n\n  Cardano commands.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  get-address             Get Cardano address.\n  get-native-script-hash  Get Cardano native script hash.\n  get-public-key          Get Cardano public key.\n  sign-tx                 Sign Cardano transaction.\n</code></pre>"},{"location":"OPTIONS/#cosi-cothority-collective-signing-commands","title":"CoSi (Cothority / collective signing) commands.","text":"<pre><code>trezorctl cosi --help\n</code></pre> <pre><code>Usage: trezorctl cosi [OPTIONS] COMMAND [ARGS]...\n\n  CoSi (Cothority / collective signing) commands.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  commit  Ask device to commit to CoSi signing.\n  sign    Ask device to sign using CoSi.\n</code></pre>"},{"location":"OPTIONS/#miscellaneous-cryptography-features","title":"Miscellaneous cryptography features.","text":"<pre><code>trezorctl crypto --help\n</code></pre> <pre><code>Usage: trezorctl crypto [OPTIONS] COMMAND [ARGS]...\n\n  Miscellaneous cryptography features.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  decrypt-keyvalue  Decrypt value by given key and path.\n  encrypt-keyvalue  Encrypt value by given key and path.\n  get-entropy       Get random bytes from device.\n</code></pre>"},{"location":"OPTIONS/#miscellaneous-debug-features","title":"Miscellaneous debug features.","text":"<pre><code>trezorctl debug --help\n</code></pre> <pre><code>Usage: trezorctl debug [OPTIONS] COMMAND [ARGS]...\n\n  Miscellaneous debug features.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  record      Record screen changes into a specified directory.\n  send-bytes  Send raw bytes to Trezor.\n</code></pre>"},{"location":"OPTIONS/#device-management-commands-setup-recover-seed-wipe-etc","title":"Device management commands - setup, recover seed, wipe, etc.","text":"<pre><code>trezorctl device --help\n</code></pre> <pre><code>Usage: trezorctl device [OPTIONS] COMMAND [ARGS]...\n\n  Device management commands - setup, recover seed, wipe, etc.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  backup                Perform device seed backup.\n  load                  Upload seed and custom configuration to the device.\n  reboot-to-bootloader  Reboot device into bootloader mode.\n  recover               Start safe recovery workflow.\n  sd-protect            Secure the device with SD card protection.\n  self-test             Perform a factory self-test.\n  set-busy              Show a \"Do not disconnect\" dialog.\n  setup                 Perform device setup and generate new seed.\n  wipe                  Reset device to factory defaults and remove all private data.\n</code></pre>"},{"location":"OPTIONS/#eos-commands","title":"EOS commands.","text":"<pre><code>trezorctl eos --help\n</code></pre> <pre><code>Usage: trezorctl eos [OPTIONS] COMMAND [ARGS]...\n\n  EOS commands.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  get-public-key    Get Eos public key in base58 encoding.\n  sign-transaction  Sign EOS transaction.\n</code></pre>"},{"location":"OPTIONS/#ethereum-commands","title":"Ethereum commands.","text":"<pre><code>trezorctl ethereum --help\n</code></pre> <pre><code>Usage: trezorctl ethereum [OPTIONS] COMMAND [ARGS]...\n\n  Ethereum commands.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  get-address           Get Ethereum address in hex encoding.\n  get-public-node       Get Ethereum public node of given path.\n  sign-message          Sign message with Ethereum address.\n  sign-tx               Sign (and optionally publish) Ethereum transaction.\n  sign-typed-data       Sign typed data (EIP-712) with Ethereum address.\n  sign-typed-data-hash  Sign hash of typed data (EIP-712) with Ethereum address.\n  verify-message        Verify message signed with Ethereum address.\n</code></pre>"},{"location":"OPTIONS/#fido2-u2f-and-webauthn-management-commands","title":"FIDO2, U2F and WebAuthN management commands.","text":"<pre><code>trezorctl fido --help\n</code></pre> <pre><code>Usage: trezorctl fido [OPTIONS] COMMAND [ARGS]...\n\n  FIDO2, U2F and WebAuthN management commands.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  counter      Get or set the FIDO/U2F counter value.\n  credentials  Manage FIDO2 resident credentials.\n</code></pre>"},{"location":"OPTIONS/#firmware-commands","title":"Firmware commands.","text":"<pre><code>trezorctl firmware --help\n</code></pre> <pre><code>Usage: trezorctl firmware [OPTIONS] COMMAND [ARGS]...\n\n  Firmware commands.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  download  Download and save the firmware image.\n  get-hash  Get a hash of the installed firmware combined with the optional challenge.\n  update    Upload new firmware to device.\n  verify    Verify the integrity of the firmware data stored in a file.\n</code></pre>"},{"location":"OPTIONS/#monero-commands","title":"Monero commands.","text":"<pre><code>trezorctl monero --help\n</code></pre> <pre><code>Usage: trezorctl monero [OPTIONS] COMMAND [ARGS]...\n\n  Monero commands.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  get-address    Get Monero address for specified path.\n  get-watch-key  Get Monero watch key for specified path.\n</code></pre>"},{"location":"OPTIONS/#nem-commands","title":"NEM commands.","text":"<pre><code>trezorctl nem --help\n</code></pre> <pre><code>Usage: trezorctl nem [OPTIONS] COMMAND [ARGS]...\n\n  NEM commands.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  get-address  Get NEM address for specified path.\n  sign-tx      Sign (and optionally broadcast) NEM transaction.\n</code></pre>"},{"location":"OPTIONS/#ripple-commands","title":"Ripple commands.","text":"<pre><code>trezorctl ripple --help\n</code></pre> <pre><code>Usage: trezorctl ripple [OPTIONS] COMMAND [ARGS]...\n\n  Ripple commands.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  get-address  Get Ripple address\n  sign-tx      Sign Ripple transaction\n</code></pre>"},{"location":"OPTIONS/#device-settings","title":"Device settings.","text":"<pre><code>trezorctl set --help\n</code></pre> <pre><code>Usage: trezorctl set [OPTIONS] COMMAND [ARGS]...\n\n  Device settings.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  auto-lock-delay        Set auto-lock delay (in seconds).\n  display-rotation       Set display rotation.\n  experimental-features  Enable or disable experimental message types.\n  flags                  Set device flags.\n  homescreen             Set new homescreen.\n  label                  Set new device label.\n  passphrase             Enable, disable or configure passphrase protection.\n  pin                    Set, change or remove PIN.\n  safety-checks          Set safety check level.\n  wipe-code              Set or remove the wipe code.\n</code></pre>"},{"location":"OPTIONS/#stellar-commands","title":"Stellar commands.","text":"<pre><code>trezorctl stellar --help\n</code></pre> <pre><code>Usage: trezorctl stellar [OPTIONS] COMMAND [ARGS]...\n\n  Stellar commands.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  get-address       Get Stellar public address.\n  sign-transaction  Sign a base64-encoded transaction envelope.\n</code></pre>"},{"location":"OPTIONS/#tezos-commands","title":"Tezos commands.","text":"<pre><code>trezorctl tezos --help\n</code></pre> <pre><code>Usage: trezorctl tezos [OPTIONS] COMMAND [ARGS]...\n\n  Tezos commands.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  get-address     Get Tezos address for specified path.\n  get-public-key  Get Tezos public key.\n  sign-tx         Sign Tezos transaction.\n</code></pre>"},{"location":"examples_trezorlib/","title":"Trezorlib examples","text":""},{"location":"examples_trezorlib/#hello-world","title":"Hello world","text":"<p>Connecting to <code>Trezor</code> and displaying some basic information.</p> <pre><code>from trezorlib import btc\nfrom trezorlib.client import get_default_client\nfrom trezorlib.tools import parse_path\n\n\ndef main() -&gt; None:\n    # Use first connected device\n    client = get_default_client()\n\n    # Print out Trezor's features and settings\n    print(client.features)\n\n    # Get the first address of first BIP44 account\n    bip32_path = parse_path(\"44'/0'/0'/0/0\")\n    address = btc.get_address(client, \"Bitcoin\", bip32_path, True)\n    print(\"Bitcoin address:\", address)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"transaction-format/","title":"trezorctl Bitcoin transaction JSON format","text":"<p>Since version 0.11.2, <code>trezorctl</code> allows fully offline signing of Bitcoin and Bitcoin-like altcoin transactions encoded in a custom JSON structure. Starting with version 0.11.6, this is the only supported format for signing.</p>"},{"location":"transaction-format/#structure","title":"Structure","text":"<p>The structure of the JSON matches the shape of the relevant protobuf messages. See file messages-bitcoin.proto for up-to-date structure.</p> <p>The root is an object with the following attributes:</p> <ul> <li><code>coin_name</code>: string representing the coin name as listed in coin defs. If   missing, <code>\"Bitcoin\"</code> is used.</li> <li><code>inputs</code>: array of <code>TxInputType</code> objects. Must be present.</li> <li><code>outputs</code>: array of <code>TxOutputType</code> objects. Must be present.</li> <li><code>details</code>: object whose keys correspond to metadata on the <code>SignTx</code> type. Can be   omitted.</li> <li><code>prev_txes</code>: object whose keys are hex-encoded transaction hashes, and values are   objects of type <code>TransactionType</code>. When signing a transaction with non-SegWit inputs,   each previous transaction must have an entry in <code>prev_txes</code>. With pure SegWit   transactions, this field can be omitted.</li> </ul> <p>See definition of the respective object types in messages-bitcoin.proto for descriptions of individual fields.</p> <p>Please note that the <code>optional</code> keyword in the protobuf definition does not indicate that the field can be omitted, nor does the <code>default</code> extension mean that the default value will be used if missing.</p>"},{"location":"transaction-format/#derivation-paths","title":"Derivation paths","text":"<p>A derivation path in the field <code>address_n</code> is encoded as an array of numbers according to the BIP-32 specification. Use <code>trezorlib.tools.parse_path</code> to convert a string derivation path to the corresponding array.</p>"},{"location":"transaction-format/#inputs","title":"Inputs","text":"<pre><code>enum InputScriptType {\n    SPENDADDRESS = 0;       // standard P2PKH address\n    SPENDMULTISIG = 1;      // P2SH multisig address\n    EXTERNAL = 2;           // reserved for external inputs (coinjoin)\n    SPENDWITNESS = 3;       // native SegWit\n    SPENDP2SHWITNESS = 4;   // SegWit over P2SH (backward compatible)\n}\n\nmessage TxInputType {\n    repeated uint32 address_n = 1;   // BIP-32 path to derive the key from master node\n    required bytes prev_hash = 2;    // hash of previous transaction output to spend by this input\n    required uint32 prev_index = 3;  // index of previous output to spend\n    optional bytes script_sig = 4;   // script signature, unset for tx to sign\n    optional uint32 sequence = 5;    // sequence (default=0xffffffff)\n    optional InputScriptType script_type = 6   ;    // defines template of input script\n    optional MultisigRedeemScriptType multisig = 7; // Filled if input is going to spend multisig tx\n    optional uint64 amount = 8;                     // amount of previous transaction output\n    optional uint32 decred_tree = 9;                // only for Decred\n    optional uint32 decred_script_version = 10;     // only for Decred\n}\n</code></pre> <p>Each input must have a derivation path (<code>address_n</code>), <code>prev_hash</code> and <code>prev_index</code> refering to the output being spent, <code>sequence</code> number, <code>script_type</code> corresponding to the desired signature type, and <code>amount</code>.</p> <p>The field <code>script_sig</code> must not be set.</p> <p>The field <code>multisig</code> can be used for multisig inputs. Documenting the multisig structure is TBD. With regular inputs, <code>multisig</code> must not be set.</p> <p><code>decred</code> fields must only be set when relevant to your currency.</p>"},{"location":"transaction-format/#outputs","title":"Outputs","text":"<pre><code>enum OutputScriptType {\n    PAYTOADDRESS = 0;       // string address output; change is a P2PKH address\n    PAYTOMULTISIG = 2;      // change output is a multisig address\n    PAYTOOPRETURN = 3;      // op_return\n    PAYTOWITNESS = 4;       // change output is native SegWit\n    PAYTOP2SHWITNESS = 5;   // change output is SegWit over P2SH\n}\n\nmessage TxOutputType {\n    optional string address = 1;    // destination address in Base58 encoding\n    repeated uint32 address_n = 2;  // derivation path for change address\n    required uint64 amount = 3;     // amount to spend in satoshis\n    required OutputScriptType script_type = 4;      // output script type\n    optional MultisigRedeemScriptType multisig = 5; // multisig output definition\n    optional bytes op_return_data = 6;              // defines op_return data\n    optional uint32 decred_script_version = 7;      // only for Decred\n</code></pre> <p>All outputs must have an <code>amount</code> and a <code>script_type</code>.</p> <p>For normal (non-change) outputs, the field <code>address</code> must be set to an address string, and the <code>script_type</code> must be set to <code>\"PAYTOADDRESS\"</code>. <code>address_n</code> must not be set.</p> <p>For outputs returning change, <code>address</code> must not be set, and <code>address_n</code> must be a derivation path of the desired change address. <code>script_type</code> indicates the desired address type of the change output.</p> <p>For <code>OP_RETURN</code> outputs, <code>script_type</code> must be set to <code>\"PAYTOOPRETURN\"</code> and <code>op_return_data</code> must be filled appropriately. <code>address_n</code> and <code>address</code> must not be set.</p> <p><code>decred</code> fields must only be set when relevant to your currency.</p>"},{"location":"transaction-format/#transaction-metadata","title":"Transaction metadata","text":"<p>The following is a shortened definition of the <code>SignTx</code> protobuf message, containing all possible fields that are accepted in the <code>details</code> object.</p> <p>All fields are optional unless required by your currency.</p> <pre><code>message SignTx {\n    optional uint32 version = 4;           // transaction version\n    optional uint32 lock_time = 5;         // transaction lock_time\n    optional uint32 expiry = 6;            // only for Decred and Zcash\n    optional uint32 version_group_id = 8;  // only for Zcash, nVersionGroupId when overwintered is set\n    optional uint32 timestamp = 9;         // only for Peercoin, transaction timestamp\n    optional uint32 branch_id = 10;        // only for Zcash, BRANCH_ID when overwintered is set\n}\n</code></pre>"},{"location":"transaction-format/#previous-transactions","title":"Previous transactions","text":"<p>For inputs that do not use BIP-143 (SegWit) signing, each input transaction must have an entry in the <code>prev_txes</code> object. The following object definitions are used:</p> <pre><code>message TxInputType {\n    required bytes prev_hash = 2;     // hash of previous transaction output to spend by this input\n    required uint32 prev_index = 3;   // index of previous output to spend\n    optional bytes script_sig = 4;    // script signature, unset for tx to sign\n    optional uint32 sequence = 5;     // sequence (default=0xffffffff)\n    optional uint32 decred_tree = 9;  // only for Decred\n}\n\nmessage TxOutputBinType {\n    required uint64 amount = 1;\n    required bytes script_pubkey = 2;\n    optional uint32 decred_script_version = 3;  // only for Decred\n}\n\nmessage TransactionType {\n    optional uint32 version = 1;\n    repeated TxInputType inputs = 2;\n    repeated TxOutputBinType bin_outputs = 3;\n    optional uint32 lock_time = 4;\n    optional bytes extra_data = 8;          // only for Zcash\n    optional uint32 expiry = 10;            // only for Decred and Zcash\n    optional bool overwintered = 11;        // only for Zcash\n    optional uint32 version_group_id = 12;  // only for Zcash, nVersionGroupId when overwintered is set\n    optional uint32 timestamp = 13;         // only for Peercoin, transaction timestamp\n    optional uint32 branch_id = 14;         // only for Zcash, BRANCH_ID when overwintered is set\n}\n</code></pre>"},{"location":"transaction-format/#encoding","title":"Encoding","text":"<p>Object types are encoded by a variant of proto3 JSON mapping. The following notable differences exist:</p> <ol> <li>due to the fact that Trezor protocol uses proto2, the logic for omitted fields is    different. If a value is missing or null in JSON, it is considered unset for the    corresponding protobuf.</li> <li>proto3 JSON mapping encodes <code>bytes</code> as Base64. The transaction format encodes them as    hexadecimal strings. This will be changed in a future revision, but the hex strings    will still be understood.</li> <li>Field names are expected in <code>snake_case</code>, identical to the protobuf definition. In    the future, support for <code>camelCase</code> field names will be added.</li> </ol> <p>Otherwise the encoding is identical:</p> <ul> <li>numeric fields (<code>uint32</code>, <code>uint64</code>) are encoded as JSON numbers</li> <li><code>bool</code> fields are encoded as JSON booleans (<code>true</code>, <code>false</code>)</li> <li><code>string</code> fields are encoded as JSON strings</li> <li><code>bytes</code> fields are encoded as JSON strings with hex representation of the bytes content</li> <li><code>repeated</code> fields are JSON arrays of the inner type</li> <li><code>enum</code> fields can be either a JSON number of the value, or a JSON string of the name</li> <li>nested objects are JSON objects</li> </ul>"},{"location":"transaction-format/#example","title":"Example","text":"<p>The JSON below encodes a transaction with the following inputs:</p> <ul> <li>e9cec1644db8fa95fe639a9b503a63ea587d2f4e480d3847703e3ec73adf6b5a   output 0 (P2PKH address 1Jw5FrKhi2aWbbF4h3QRWLog5AjsJYGswv)   at derivation path m/44'/0'/0'/0/282   amount 85 170 sat</li> <li>1f545c0ca1f2c055e199c70457025c1e393edd013a274a976187115a5c601155   output 0 (P2SH-SegWit address 3DEAk9KGrgvj2gHQ1hyfCXus9hZr9K8Beh)   at derivation path m/49'/0'/0'/0/55   amount 500 000 sat</li> </ul> <p>And the following outputs:</p> <ul> <li>12 345 sat to address 3DDEgt7quAq7XqoG6PjVXi1eeAea4rfWck</li> <li>562 825 sat to a P2SH-SegWit change address at derivation path m/49'/0'/0'/1/99</li> <li>fee of 10 000 sat</li> </ul> <p>(Note that Trezor does not support change addresses when mixing input types. The example is designed purely to showcase the JSON structure. Usually, all inputs should have the same <code>script_type</code>.)</p> <p>Transaction version is 2, other metadata is not set.</p> <pre><code>{\n  \"coin_name\": \"Bitcoin\",\n  \"details\": {\n    \"version\": 2\n  },\n  \"inputs\": [\n    {\n      \"address_n\": [\n        2147483692,\n        2147483648,\n        2147483648,\n        0,\n        282\n      ],\n      \"amount\": 85170,\n      \"prev_hash\": \"e9cec1644db8fa95fe639a9b503a63ea587d2f4e480d3847703e3ec73adf6b5a\",\n      \"prev_index\": 0,\n      \"script_type\": \"SPENDADDRESS\",\n      \"sequence\": 4294967293\n    },\n    {\n      \"address_n\": [\n        2147483697,\n        2147483648,\n        2147483648,\n        0,\n        55\n      ],\n      \"amount\": 500000,\n      \"prev_hash\": \"1f545c0ca1f2c055e199c70457025c1e393edd013a274a976187115a5c601155\",\n      \"prev_index\": 0,\n      \"script_type\": \"SPENDP2SHWITNESS\",\n      \"sequence\": 4294967293\n    }\n  ],\n  \"outputs\": [\n    {\n      \"address\": \"3DDEgt7quAq7XqoG6PjVXi1eeAea4rfWck\",\n      \"amount\": 12345,\n      \"script_type\": \"PAYTOADDRESS\"\n    },\n    {\n      \"address_n\": [\n        2147483697,\n        2147483648,\n        2147483648,\n        1,\n        99\n      ],\n      \"amount\": 562825,\n      \"script_type\": \"PAYTOP2SHWITNESS\"\n    }\n  ],\n  \"prev_txes\": {\n    \"e9cec1644db8fa95fe639a9b503a63ea587d2f4e480d3847703e3ec73adf6b5a\": {\n      \"bin_outputs\": [\n        {\n          \"amount\": 85170,\n          \"script_pubkey\": \"76a914c4b4272ca6d3b069dcf7afdda172a7dae677d4c988ac\"\n        },\n        {\n          \"amount\": 2375277,\n          \"script_pubkey\": \"a914115125511fa9f301ecdda8bb73401644c260c61b87\"\n        }\n      ],\n      \"inputs\": [\n        {\n          \"prev_hash\": \"59ef8b5633c2a8bf0a21edcbc4b9f271572061f81d42b366fe3b8bc0ec68014e\",\n          \"prev_index\": 1,\n          \"script_sig\": \"1600149043ed42ab198d95067d8760c247f164c4933f3f\",\n          \"sequence\": 4294967295\n        }\n      ],\n      \"lock_time\": 0,\n      \"version\": 1\n    }\n  }\n}\n\n</code></pre>"},{"location":"API/btc/","title":"Bitcoin","text":"<pre><code>from trezorlib import btc\n</code></pre>"},{"location":"API/btc/#python.src.trezorlib.btc.authorize_coinjoin","title":"<code>authorize_coinjoin(client, coordinator, max_rounds, max_coordinator_fee_rate, max_fee_per_kvbyte, n, coin_name, script_type=messages.InputScriptType.SPENDADDRESS)</code>","text":"<p>Authorize a CoinJoin transaction.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <code>coordinator</code> <code>str</code> <p>coordinator identifier to approve as a prefix in commitment data (max. 36 ASCII characters)</p> required <code>max_rounds</code> <code>int</code> <p>maximum number of rounds that Trezor is authorized to take part in</p> required <code>max_coordinator_fee_rate</code> <code>int</code> <p>maximum coordination fee rate in units of 10^-6 percent</p> required <code>max_fee_per_kvbyte</code> <code>int</code> <p>maximum mining fee rate in units of satoshis per 1000 vbytes</p> required <code>n</code> <code>Address</code> <p>prefix of the BIP-32 path leading to the account (m / purpose' / coin_type' / account')</p> required <code>coin_name</code> <code>str</code> <p>name of the coin, e.g. \"Bitcoin\", \"Testnet\"</p> required <code>script_type</code> <code>InputScriptType</code> <p>script type of the account (default: SPENDADDRESS)</p> <code>SPENDADDRESS</code> <p>Returns:</p> Name Type Description <code>str</code> <code>MessageType</code> <p>Success message</p> Source code in <code>src/trezorlib/btc.py</code> <pre><code>@expect(messages.Success, field=\"message\", ret_type=str)\ndef authorize_coinjoin(\n    client: \"TrezorClient\",\n    coordinator: str,\n    max_rounds: int,\n    max_coordinator_fee_rate: int,\n    max_fee_per_kvbyte: int,\n    n: \"Address\",\n    coin_name: str,\n    script_type: messages.InputScriptType = messages.InputScriptType.SPENDADDRESS,\n) -&gt; \"MessageType\":\n    \"\"\"Authorize a CoinJoin transaction.\n\n    Args:\n        client: TrezorClient instance\n        coordinator: coordinator identifier to approve as a prefix in commitment data (max. 36 ASCII characters)\n        max_rounds: maximum number of rounds that Trezor is authorized to take part in\n        max_coordinator_fee_rate: maximum coordination fee rate in units of 10^-6 percent\n        max_fee_per_kvbyte: maximum mining fee rate in units of satoshis per 1000 vbytes\n        n: prefix of the BIP-32 path leading to the account (m / purpose' / coin_type' / account')\n        coin_name: name of the coin, e.g. \"Bitcoin\", \"Testnet\"\n        script_type: script type of the account (default: SPENDADDRESS)\n\n    Returns:\n        str: Success message\n    \"\"\"\n    return client.call(\n        messages.AuthorizeCoinJoin(\n            coordinator=coordinator,\n            max_rounds=max_rounds,\n            max_coordinator_fee_rate=max_coordinator_fee_rate,\n            max_fee_per_kvbyte=max_fee_per_kvbyte,\n            address_n=n,\n            coin_name=coin_name,\n            script_type=script_type,\n        )\n    )\n</code></pre>"},{"location":"API/btc/#python.src.trezorlib.btc.from_json","title":"<code>from_json(json_dict)</code>","text":"<p>Translate transaction from JSON to protobuf message.</p> <p>Parameters:</p> Name Type Description Default <code>json_dict</code> <code>Transaction</code> <p>Transaction in JSON format.</p> required <p>Returns:</p> Type Description <code>TransactionType</code> <p>TransactionType</p> Source code in <code>src/trezorlib/btc.py</code> <pre><code>def from_json(json_dict: \"Transaction\") -&gt; messages.TransactionType:\n    \"\"\"Translate transaction from JSON to protobuf message.\n\n    Args:\n        json_dict: Transaction in JSON format.\n\n    Returns:\n        TransactionType\n    \"\"\"\n\n    def make_input(vin: \"Vin\") -&gt; messages.TxInputType:\n        if \"coinbase\" in vin:\n            return messages.TxInputType(\n                prev_hash=b\"\\0\" * 32,\n                prev_index=0xFFFFFFFF,  # signed int -1\n                script_sig=bytes.fromhex(vin[\"coinbase\"]),\n                sequence=vin[\"sequence\"],\n            )\n\n        else:\n            return messages.TxInputType(\n                prev_hash=bytes.fromhex(vin[\"txid\"]),\n                prev_index=vin[\"vout\"],\n                script_sig=bytes.fromhex(vin[\"scriptSig\"][\"hex\"]),\n                sequence=vin[\"sequence\"],\n            )\n\n    def make_bin_output(vout: \"Vout\") -&gt; messages.TxOutputBinType:\n        return messages.TxOutputBinType(\n            amount=int(Decimal(vout[\"value\"]) * (10**8)),\n            script_pubkey=bytes.fromhex(vout[\"scriptPubKey\"][\"hex\"]),\n        )\n\n    return messages.TransactionType(\n        version=json_dict[\"version\"],\n        lock_time=json_dict.get(\"locktime\", 0),\n        inputs=[make_input(vin) for vin in json_dict[\"vin\"]],\n        bin_outputs=[make_bin_output(vout) for vout in json_dict[\"vout\"]],\n    )\n</code></pre>"},{"location":"API/btc/#python.src.trezorlib.btc.get_address","title":"<code>get_address(*args, **kwargs)</code>","text":"<p>Ask device for address corresponding to given path.</p> <p>See <code>get_authenticated_address</code> for possible parameters and their meaning.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>MessageType</code> <p>address</p> Source code in <code>src/trezorlib/btc.py</code> <pre><code>@expect(messages.Address, field=\"address\", ret_type=str)\ndef get_address(*args: Any, **kwargs: Any) -&gt; \"MessageType\":\n    \"\"\"Ask device for address corresponding to given path.\n\n    See `get_authenticated_address` for possible parameters and their meaning.\n\n    Returns:\n        str: address\n    \"\"\"\n    return get_authenticated_address(*args, **kwargs)\n</code></pre>"},{"location":"API/btc/#python.src.trezorlib.btc.get_authenticated_address","title":"<code>get_authenticated_address(client, coin_name, n, show_display=False, multisig=None, script_type=messages.InputScriptType.SPENDADDRESS, ignore_xpub_magic=False, unlock_path=None, unlock_path_mac=None)</code>","text":"<p>Get address for given path.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <code>coin_name</code> <code>str</code> <p>coin name, e.g. \"Bitcoin\" or \"Testnet\"</p> required <code>n</code> <code>Address</code> <p>BIP-32 path to derive the key from master node</p> required <code>show_display</code> <code>bool</code> <p>optionally show on the display before sending the result</p> <code>False</code> <code>multisig</code> <code>Optional[MultisigRedeemScriptType]</code> <p>multisig configuration</p> <code>None</code> <code>script_type</code> <code>InputScriptType</code> <p>script type to use (non-segwit, segwit, etc.)</p> <code>SPENDADDRESS</code> <code>ignore_xpub_magic</code> <code>bool</code> <p>ignore SLIP-0132 XPUB magic, use xpub/tpub prefix for all account types</p> <code>False</code> <code>unlock_path</code> <code>Optional[List[int]]</code> <p>protected BIP-32 path to be unlocked</p> <code>None</code> <code>unlock_path_mac</code> <code>Optional[bytes]</code> <p>MAC returned by UnlockedPathRequest</p> <code>None</code> <p>Returns:</p> Type Description <code>MessageType</code> <p>Address</p> Source code in <code>src/trezorlib/btc.py</code> <pre><code>@expect(messages.Address)\ndef get_authenticated_address(\n    client: \"TrezorClient\",\n    coin_name: str,\n    n: \"Address\",\n    show_display: bool = False,\n    multisig: Optional[messages.MultisigRedeemScriptType] = None,\n    script_type: messages.InputScriptType = messages.InputScriptType.SPENDADDRESS,\n    ignore_xpub_magic: bool = False,\n    unlock_path: Optional[List[int]] = None,\n    unlock_path_mac: Optional[bytes] = None,\n) -&gt; \"MessageType\":\n    \"\"\"Get address for given path.\n\n    Args:\n        client: TrezorClient instance\n        coin_name: coin name, e.g. \"Bitcoin\" or \"Testnet\"\n        n: BIP-32 path to derive the key from master node\n        show_display: optionally show on the display before sending the result\n        multisig: multisig configuration\n        script_type: script type to use (non-segwit, segwit, etc.)\n        ignore_xpub_magic: ignore SLIP-0132 XPUB magic, use xpub/tpub prefix for all account types\n        unlock_path: protected BIP-32 path to be unlocked\n        unlock_path_mac: MAC returned by UnlockedPathRequest\n\n    Returns:\n        Address\n    \"\"\"\n    if unlock_path:\n        res = client.call(\n            messages.UnlockPath(address_n=unlock_path, mac=unlock_path_mac)\n        )\n        if not isinstance(res, messages.UnlockedPathRequest):\n            raise exceptions.TrezorException(\"Unexpected message\")\n\n    return client.call(\n        messages.GetAddress(\n            address_n=n,\n            coin_name=coin_name,\n            show_display=show_display,\n            multisig=multisig,\n            script_type=script_type,\n            ignore_xpub_magic=ignore_xpub_magic,\n        )\n    )\n</code></pre>"},{"location":"API/btc/#python.src.trezorlib.btc.get_ownership_id","title":"<code>get_ownership_id(client, coin_name, n, multisig=None, script_type=messages.InputScriptType.SPENDADDRESS)</code>","text":"<p>Ask device for a SLIP-19 ownership identifier corresponding to scriptPubKey for given path.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <code>coin_name</code> <code>str</code> <p>coin name, e.g. \"Bitcoin\" or \"Testnet\"</p> required <code>n</code> <code>Address</code> <p>BIP-32 path to derive the key from master node</p> required <code>multisig</code> <code>Optional[MultisigRedeemScriptType]</code> <p>multisig configuration</p> <code>None</code> <code>script_type</code> <code>InputScriptType</code> <p>script type to use (non-segwit, segwit, etc.)</p> <code>SPENDADDRESS</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>MessageType</code> <p>ownership identifier</p> Source code in <code>src/trezorlib/btc.py</code> <pre><code>@expect(messages.OwnershipId, field=\"ownership_id\", ret_type=bytes)\ndef get_ownership_id(\n    client: \"TrezorClient\",\n    coin_name: str,\n    n: \"Address\",\n    multisig: Optional[messages.MultisigRedeemScriptType] = None,\n    script_type: messages.InputScriptType = messages.InputScriptType.SPENDADDRESS,\n) -&gt; \"MessageType\":\n    \"\"\"Ask device for a SLIP-19 ownership identifier corresponding to scriptPubKey for given path.\n\n    Args:\n        client: TrezorClient instance\n        coin_name: coin name, e.g. \"Bitcoin\" or \"Testnet\"\n        n: BIP-32 path to derive the key from master node\n        multisig: multisig configuration\n        script_type: script type to use (non-segwit, segwit, etc.)\n\n    Returns:\n        bytes: ownership identifier\n    \"\"\"\n    return client.call(\n        messages.GetOwnershipId(\n            address_n=n,\n            coin_name=coin_name,\n            multisig=multisig,\n            script_type=script_type,\n        )\n    )\n</code></pre>"},{"location":"API/btc/#python.src.trezorlib.btc.get_ownership_proof","title":"<code>get_ownership_proof(client, coin_name, n, multisig=None, script_type=messages.InputScriptType.SPENDADDRESS, user_confirmation=False, ownership_ids=None, commitment_data=None, preauthorized=False)</code>","text":"<p>Ask device for a SLIP-19 proof of ownership corresponding to given path.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <code>coin_name</code> <code>str</code> <p>coin name, e.g. \"Bitcoin\" or \"Testnet\"</p> required <code>n</code> <code>Address</code> <p>BIP-32 path to derive the key from master node</p> required <code>multisig</code> <code>Optional[MultisigRedeemScriptType]</code> <p>multisig configuration</p> <code>None</code> <code>script_type</code> <code>InputScriptType</code> <p>script type to use (non-segwit, segwit, etc.)</p> <code>SPENDADDRESS</code> <code>user_confirmation</code> <code>bool</code> <p>show a confirmation dialog and set the \"user confirmation\" bit in the proof</p> <code>False</code> <code>ownership_ids</code> <code>Optional[List[bytes]]</code> <p>list of ownership identifiers in case of multisig</p> <code>None</code> <code>commitment_data</code> <code>Optional[bytes]</code> <p>additional data to which the proof should commit</p> <code>None</code> <code>preauthorized</code> <code>bool</code> <p><code>True</code> to skip user prompt if the operation is preauthorized via <code>authorize_coinjoin</code></p> <code>False</code> <p>Returns:</p> Type Description <code>bytes</code> <p>ownership_proof</p> <code>bytes</code> <p>signature</p> Source code in <code>src/trezorlib/btc.py</code> <pre><code>def get_ownership_proof(\n    client: \"TrezorClient\",\n    coin_name: str,\n    n: \"Address\",\n    multisig: Optional[messages.MultisigRedeemScriptType] = None,\n    script_type: messages.InputScriptType = messages.InputScriptType.SPENDADDRESS,\n    user_confirmation: bool = False,\n    ownership_ids: Optional[List[bytes]] = None,\n    commitment_data: Optional[bytes] = None,\n    preauthorized: bool = False,\n) -&gt; Tuple[bytes, bytes]:\n    \"\"\"Ask device for a SLIP-19 proof of ownership corresponding to given path.\n\n    Args:\n        client: TrezorClient instance\n        coin_name: coin name, e.g. \"Bitcoin\" or \"Testnet\"\n        n: BIP-32 path to derive the key from master node\n        multisig: multisig configuration\n        script_type: script type to use (non-segwit, segwit, etc.)\n        user_confirmation: show a confirmation dialog and set the \"user confirmation\" bit in the proof\n        ownership_ids: list of ownership identifiers in case of multisig\n        commitment_data: additional data to which the proof should commit\n        preauthorized: `True` to skip user prompt if the operation is preauthorized via `authorize_coinjoin`\n\n    Returns:\n        ownership_proof\n        signature\n    \"\"\"\n    if preauthorized:\n        res = client.call(messages.DoPreauthorized())\n        if not isinstance(res, messages.PreauthorizedRequest):\n            raise exceptions.TrezorException(\"Unexpected message\")\n\n    res = client.call(\n        messages.GetOwnershipProof(\n            address_n=n,\n            coin_name=coin_name,\n            script_type=script_type,\n            multisig=multisig,\n            user_confirmation=user_confirmation,\n            ownership_ids=ownership_ids,\n            commitment_data=commitment_data,\n        )\n    )\n\n    if not isinstance(res, messages.OwnershipProof):\n        raise exceptions.TrezorException(\"Unexpected message\")\n\n    return res.ownership_proof, res.signature\n</code></pre>"},{"location":"API/btc/#python.src.trezorlib.btc.get_public_node","title":"<code>get_public_node(client, n, ecdsa_curve_name=None, show_display=False, coin_name=None, script_type=messages.InputScriptType.SPENDADDRESS, ignore_xpub_magic=False, unlock_path=None, unlock_path_mac=None)</code>","text":"<p>Ask device for public key corresponding to given path.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <code>n</code> <code>Address</code> <p>BIP-32 path to derive the key from master node</p> required <code>ecdsa_curve_name</code> <code>Optional[str]</code> <p>ECDSA curve name to use</p> <code>None</code> <code>show_display</code> <code>bool</code> <p>optionally show on the display before sending the result</p> <code>False</code> <code>coin_name</code> <code>Optional[str]</code> <p>coin name, e.g. \"Bitcoin\" or \"Testnet\"</p> <code>None</code> <code>script_type</code> <code>InputScriptType</code> <p>script type to use (non-segwit, segwit, etc.)</p> <code>SPENDADDRESS</code> <code>ignore_xpub_magic</code> <code>bool</code> <p>ignore SLIP-0132 XPUB magic, use xpub/tpub prefix for all account types</p> <code>False</code> <code>unlock_path</code> <code>Optional[List[int]]</code> <p>BIP-32 path to unlock the device</p> <code>None</code> <code>unlock_path_mac</code> <code>Optional[bytes]</code> <p>MAC returned by UnlockedPathRequest</p> <code>None</code> <p>Returns:</p> Type Description <code>MessageType</code> <p>PublicKey</p> Source code in <code>src/trezorlib/btc.py</code> <pre><code>@expect(messages.PublicKey)\ndef get_public_node(\n    client: \"TrezorClient\",\n    n: \"Address\",\n    ecdsa_curve_name: Optional[str] = None,\n    show_display: bool = False,\n    coin_name: Optional[str] = None,\n    script_type: messages.InputScriptType = messages.InputScriptType.SPENDADDRESS,\n    ignore_xpub_magic: bool = False,\n    unlock_path: Optional[List[int]] = None,\n    unlock_path_mac: Optional[bytes] = None,\n) -&gt; \"MessageType\":\n    \"\"\"Ask device for public key corresponding to given path.\n\n    Args:\n        client: TrezorClient instance\n        n: BIP-32 path to derive the key from master node\n        ecdsa_curve_name: ECDSA curve name to use\n        show_display: optionally show on the display before sending the result\n        coin_name: coin name, e.g. \"Bitcoin\" or \"Testnet\"\n        script_type: script type to use (non-segwit, segwit, etc.)\n        ignore_xpub_magic: ignore SLIP-0132 XPUB magic, use xpub/tpub prefix for all account types\n        unlock_path: BIP-32 path to unlock the device\n        unlock_path_mac: MAC returned by UnlockedPathRequest\n\n    Returns:\n        PublicKey\n    \"\"\"\n    if unlock_path:\n        res = client.call(\n            messages.UnlockPath(address_n=unlock_path, mac=unlock_path_mac)\n        )\n        if not isinstance(res, messages.UnlockedPathRequest):\n            raise exceptions.TrezorException(\"Unexpected message\")\n\n    return client.call(\n        messages.GetPublicKey(\n            address_n=n,\n            ecdsa_curve_name=ecdsa_curve_name,\n            show_display=show_display,\n            coin_name=coin_name,\n            script_type=script_type,\n            ignore_xpub_magic=ignore_xpub_magic,\n        )\n    )\n</code></pre>"},{"location":"API/btc/#python.src.trezorlib.btc.sign_message","title":"<code>sign_message(client, coin_name, n, message, script_type=messages.InputScriptType.SPENDADDRESS, no_script_type=False)</code>","text":"<p>Ask device to sign a message.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <code>coin_name</code> <code>str</code> <p>coin name, e.g. \"Bitcoin\" or \"Testnet\"</p> required <code>n</code> <code>Address</code> <p>BIP-32 path to derive the key from master node</p> required <code>message</code> <code>AnyStr</code> <p>message to sign</p> required <code>script_type</code> <code>InputScriptType</code> <p>script type to use (non-segwit, segwit, etc.)</p> <code>SPENDADDRESS</code> <code>no_script_type</code> <code>bool</code> <p>don't include script type information in the recovery byte of the signature, same as in Bitcoin Core</p> <code>False</code> <p>Returns:</p> Type Description <code>MessageType</code> <p>MessageSignature</p> Source code in <code>src/trezorlib/btc.py</code> <pre><code>@expect(messages.MessageSignature)\ndef sign_message(\n    client: \"TrezorClient\",\n    coin_name: str,\n    n: \"Address\",\n    message: AnyStr,\n    script_type: messages.InputScriptType = messages.InputScriptType.SPENDADDRESS,\n    no_script_type: bool = False,\n) -&gt; \"MessageType\":\n    \"\"\"Ask device to sign a message.\n\n    Args:\n        client: TrezorClient instance\n        coin_name: coin name, e.g. \"Bitcoin\" or \"Testnet\"\n        n: BIP-32 path to derive the key from master node\n        message: message to sign\n        script_type: script type to use (non-segwit, segwit, etc.)\n        no_script_type: don't include script type information in the recovery byte of the signature, same as in Bitcoin Core\n\n    Returns:\n        MessageSignature\n    \"\"\"\n    return client.call(\n        messages.SignMessage(\n            coin_name=coin_name,\n            address_n=n,\n            message=prepare_message_bytes(message),\n            script_type=script_type,\n            no_script_type=no_script_type,\n        )\n    )\n</code></pre>"},{"location":"API/btc/#python.src.trezorlib.btc.sign_tx","title":"<code>sign_tx(client, coin_name, inputs, outputs, details=None, prev_txes=None, payment_reqs=(), preauthorized=False, unlock_path=None, unlock_path_mac=None, **kwargs)</code>","text":"<p>Sign a Bitcoin-like transaction.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <code>coin_name</code> <code>str</code> <p>coin name, e.g. \"Bitcoin\" or \"Testnet\"</p> required <code>inputs</code> <code>Sequence[TxInputType]</code> <p>list of transaction inputs</p> required <code>outputs</code> <code>Sequence[TxOutputType]</code> <p>list of transaction outputs</p> required <code>details</code> <code>Optional[SignTx]</code> <p>additional transaction details</p> <code>None</code> <code>prev_txes</code> <code>Optional[TxCacheType]</code> <p>dictionary of previous transactions</p> <code>None</code> <code>payment_reqs</code> <code>Sequence[TxAckPaymentRequest]</code> <p>list of payment requests</p> <code>()</code> <code>preauthorized</code> <code>bool</code> <p><code>True</code> to automatically confirm if the transaction is preauthorized via <code>authorize_coinjoin</code></p> <code>False</code> <code>unlock_path</code> <code>Optional[List[int]]</code> <p>protected BIP-32 path to be unlocked</p> <code>None</code> <code>unlock_path_mac</code> <code>Optional[bytes]</code> <p>MAC returned by UnlockedPathRequest</p> <code>None</code> <p>Returns:</p> Type Description <code>Sequence[Optional[bytes]]</code> <p>list of signatures</p> <code>bytes</code> <p>serialized transaction</p> <p>Returns a list of signatures (one for each provided input) and the network-serialized transaction.</p> <p>In addition to the required arguments, it is possible to specify additional transaction properties (version, lock time, expiry...). Each additional argument must correspond to a field in the <code>SignTx</code> data type. Note that some fields (<code>inputs_count</code>, <code>outputs_count</code>, <code>coin_name</code>) will be inferred from the arguments and cannot be overriden by kwargs.</p> Source code in <code>src/trezorlib/btc.py</code> <pre><code>@session\ndef sign_tx(\n    client: \"TrezorClient\",\n    coin_name: str,\n    inputs: Sequence[messages.TxInputType],\n    outputs: Sequence[messages.TxOutputType],\n    details: Optional[messages.SignTx] = None,\n    prev_txes: Optional[\"TxCacheType\"] = None,\n    payment_reqs: Sequence[messages.TxAckPaymentRequest] = (),\n    preauthorized: bool = False,\n    unlock_path: Optional[List[int]] = None,\n    unlock_path_mac: Optional[bytes] = None,\n    **kwargs: Any,\n) -&gt; Tuple[Sequence[Optional[bytes]], bytes]:\n    \"\"\"Sign a Bitcoin-like transaction.\n\n    Args:\n        client: TrezorClient instance\n        coin_name: coin name, e.g. \"Bitcoin\" or \"Testnet\"\n        inputs: list of transaction inputs\n        outputs: list of transaction outputs\n        details: additional transaction details\n        prev_txes: dictionary of previous transactions\n        payment_reqs: list of payment requests\n        preauthorized: `True` to automatically confirm if the transaction is preauthorized via `authorize_coinjoin`\n        unlock_path: protected BIP-32 path to be unlocked\n        unlock_path_mac: MAC returned by UnlockedPathRequest\n\n    Returns:\n        list of signatures\n        serialized transaction\n\n    Returns a list of signatures (one for each provided input) and the\n    network-serialized transaction.\n\n    In addition to the required arguments, it is possible to specify additional\n    transaction properties (version, lock time, expiry...). Each additional argument\n    must correspond to a field in the `SignTx` data type. Note that some fields\n    (`inputs_count`, `outputs_count`, `coin_name`) will be inferred from the arguments\n    and cannot be overriden by kwargs.\n    \"\"\"\n    if prev_txes is None:\n        prev_txes = {}\n\n    if details is not None:\n        warnings.warn(\n            \"'details' argument is deprecated, use kwargs instead\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        signtx = details\n        signtx.coin_name = coin_name\n        signtx.inputs_count = len(inputs)\n        signtx.outputs_count = len(outputs)\n\n    else:\n        signtx = messages.SignTx(\n            coin_name=coin_name,\n            inputs_count=len(inputs),\n            outputs_count=len(outputs),\n        )\n        for name, value in kwargs.items():\n            if hasattr(signtx, name):\n                setattr(signtx, name, value)\n\n    if unlock_path:\n        res = client.call(\n            messages.UnlockPath(address_n=unlock_path, mac=unlock_path_mac)\n        )\n        if not isinstance(res, messages.UnlockedPathRequest):\n            raise exceptions.TrezorException(\"Unexpected message\")\n    elif preauthorized:\n        res = client.call(messages.DoPreauthorized())\n        if not isinstance(res, messages.PreauthorizedRequest):\n            raise exceptions.TrezorException(\"Unexpected message\")\n\n    res = client.call(signtx)\n\n    # Prepare structure for signatures\n    signatures: List[Optional[bytes]] = [None] * len(inputs)\n    serialized_tx = b\"\"\n\n    def copy_tx_meta(tx: messages.TransactionType) -&gt; messages.TransactionType:\n        tx_copy = copy(tx)\n        # clear fields\n        tx_copy.inputs_cnt = len(tx.inputs)\n        tx_copy.inputs = []\n        tx_copy.outputs_cnt = len(tx.bin_outputs or tx.outputs)\n        tx_copy.outputs = []\n        tx_copy.bin_outputs = []\n        tx_copy.extra_data_len = len(tx.extra_data or b\"\")\n        tx_copy.extra_data = None\n        return tx_copy\n\n    this_tx = messages.TransactionType(\n        inputs=inputs,\n        outputs=outputs,\n        inputs_cnt=len(inputs),\n        outputs_cnt=len(outputs),\n        # pick either kw-provided or default value from the SignTx request\n        version=signtx.version,\n    )\n\n    R = messages.RequestType\n    while isinstance(res, messages.TxRequest):\n        # If there's some part of signed transaction, let's add it\n        if res.serialized:\n            if res.serialized.serialized_tx:\n                serialized_tx += res.serialized.serialized_tx\n\n            if res.serialized.signature_index is not None:\n                idx = res.serialized.signature_index\n                sig = res.serialized.signature\n                if signatures[idx] is not None:\n                    raise ValueError(f\"Signature for index {idx} already filled\")\n                signatures[idx] = sig\n\n        if res.request_type == R.TXFINISHED:\n            break\n\n        assert res.details is not None, \"device did not provide details\"\n\n        # Device asked for one more information, let's process it.\n        if res.details.tx_hash is not None:\n            if res.details.tx_hash not in prev_txes:\n                raise ValueError(\n                    f\"Previous transaction {res.details.tx_hash.hex()} not available\"\n                )\n            current_tx = prev_txes[res.details.tx_hash]\n        else:\n            current_tx = this_tx\n\n        if res.request_type == R.TXPAYMENTREQ:\n            assert res.details.request_index is not None\n            msg = payment_reqs[res.details.request_index]\n            res = client.call(msg)\n        else:\n            msg = messages.TransactionType()\n            if res.request_type == R.TXMETA:\n                msg = copy_tx_meta(current_tx)\n            elif res.request_type in (R.TXINPUT, R.TXORIGINPUT):\n                assert res.details.request_index is not None\n                msg.inputs = [current_tx.inputs[res.details.request_index]]\n            elif res.request_type == R.TXOUTPUT:\n                assert res.details.request_index is not None\n                if res.details.tx_hash:\n                    msg.bin_outputs = [\n                        current_tx.bin_outputs[res.details.request_index]\n                    ]\n                else:\n                    msg.outputs = [current_tx.outputs[res.details.request_index]]\n            elif res.request_type == R.TXORIGOUTPUT:\n                assert res.details.request_index is not None\n                msg.outputs = [current_tx.outputs[res.details.request_index]]\n            elif res.request_type == R.TXEXTRADATA:\n                assert res.details.extra_data_offset is not None\n                assert res.details.extra_data_len is not None\n                assert current_tx.extra_data is not None\n                o, l = res.details.extra_data_offset, res.details.extra_data_len\n                msg.extra_data = current_tx.extra_data[o : o + l]\n            else:\n                raise exceptions.TrezorException(\n                    f\"Unknown request type - {res.request_type}.\"\n                )\n\n            res = client.call(messages.TxAck(tx=msg))\n\n    if not isinstance(res, messages.TxRequest):\n        raise exceptions.TrezorException(\"Unexpected message\")\n\n    for i, sig in zip(inputs, signatures):\n        if i.script_type != messages.InputScriptType.EXTERNAL and sig is None:\n            raise exceptions.TrezorException(\"Some signatures are missing!\")\n\n    return signatures, serialized_tx\n</code></pre>"},{"location":"API/btc/#python.src.trezorlib.btc.verify_message","title":"<code>verify_message(client, coin_name, address, signature, message)</code>","text":"<p>Ask device to verify message.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <code>coin_name</code> <code>str</code> <p>coin name, e.g. \"Bitcoin\" or \"Testnet\"</p> required <code>address</code> <code>str</code> <p>address to verify the signature against</p> required <code>signature</code> <code>bytes</code> <p>signature to verify</p> required <code>message</code> <code>AnyStr</code> <p>message to verify</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the signature is valid, False otherwise</p> Source code in <code>src/trezorlib/btc.py</code> <pre><code>def verify_message(\n    client: \"TrezorClient\",\n    coin_name: str,\n    address: str,\n    signature: bytes,\n    message: AnyStr,\n) -&gt; bool:\n    \"\"\"Ask device to verify message.\n\n    Args:\n        client: TrezorClient instance\n        coin_name: coin name, e.g. \"Bitcoin\" or \"Testnet\"\n        address: address to verify the signature against\n        signature: signature to verify\n        message: message to verify\n\n    Returns:\n        bool: True if the signature is valid, False otherwise\n    \"\"\"\n    try:\n        resp = client.call(\n            messages.VerifyMessage(\n                address=address,\n                signature=signature,\n                message=prepare_message_bytes(message),\n                coin_name=coin_name,\n            )\n        )\n    except exceptions.TrezorFailure:\n        return False\n    return isinstance(resp, messages.Success)\n</code></pre>"},{"location":"API/client/","title":"Client","text":"<pre><code>from trezorlib import client\n</code></pre>"},{"location":"API/client/#python.src.trezorlib.client.TrezorClient","title":"<code>TrezorClient</code>","text":"<p>Trezor client, a connection to a Trezor device.</p> <p>This class allows you to manage connection state, send and receive protobuf messages, handle user interactions, and perform some generic tasks (send a cancel message, initialize or clear a session, ping the device).</p> Source code in <code>src/trezorlib/client.py</code> <pre><code>class TrezorClient:\n    \"\"\"Trezor client, a connection to a Trezor device.\n\n    This class allows you to manage connection state, send and receive protobuf\n    messages, handle user interactions, and perform some generic tasks\n    (send a cancel message, initialize or clear a session, ping the device).\n    \"\"\"\n\n    def __init__(\n        self,\n        transport: \"Transport\",\n        ui: \"TrezorClientUI\",\n        session_id: Optional[bytes] = None,\n        derive_cardano: Optional[bool] = None,\n        model: Optional[models.TrezorModel] = None,\n        _init_device: bool = True,\n    ) -&gt; None:\n        \"\"\"Create a TrezorClient instance.\n\n        Args:\n            transport: Transport instance\n            ui: UI instance\n            session_id: attempt to resume session with the given ID\n            derive_cardano: enable the Cardano app, if available\n            model: Optional model of the device\n            _init_device: Whether to initialize the device (more below)\n\n        You have to provide a `transport`, i.e., a raw connection to the device. You can\n        use `trezorlib.transport.get_transport` to find one.\n\n        You have to provide an UI implementation for the three kinds of interaction:\n        - button request (notify the user that their interaction is needed)\n        - PIN request (on T1, ask the user to input numbers for a PIN matrix)\n        - passphrase request (ask the user to enter a passphrase) See `trezorlib.ui` for\n          details.\n\n        See `TrezorClient.init_device` for details about `session_id` and\n        `derive_cardano`.\n\n        You can provide Trezor model information. If not provided, it is detected from\n        the model name reported at initialization time.\n\n        By default, the instance will open a connection to the Trezor device, send an\n        `Initialize` message, set up the `features` field from the response, and connect\n        to a session. By specifying `_init_device=False`, this step is skipped. Notably,\n        this means that `client.features` is unset. Use `client.init_device()` or\n        `client.refresh_features()` to fix that, otherwise A LOT OF THINGS will break.\n        Only use this if you are _sure_ that you know what you are doing. This feature\n        might be removed at any time.\n        \"\"\"\n        LOG.info(f\"creating client instance for device: {transport.get_path()}\")\n        self.model = model\n        if self.model:\n            self.mapping = self.model.default_mapping\n        else:\n            self.mapping = mapping.DEFAULT_MAPPING\n        self.transport = transport\n        self.ui = ui\n        self.session_counter = 0\n        self.session_id = session_id\n        if _init_device:\n            self.init_device(session_id=session_id, derive_cardano=derive_cardano)\n\n    def open(self) -&gt; None:\n        \"\"\"Open a connection with the device.\"\"\"\n        if self.session_counter == 0:\n            self.transport.begin_session()\n        self.session_counter += 1\n\n    def close(self) -&gt; None:\n        \"\"\"Close the connection with the device.\"\"\"\n        self.session_counter = max(self.session_counter - 1, 0)\n        if self.session_counter == 0:\n            # TODO call EndSession here?\n            self.transport.end_session()\n\n    def cancel(self) -&gt; None:\n        \"\"\"Send a Cancel message to the device, aborting the current operation.\"\"\"\n        self._raw_write(messages.Cancel())\n\n    def call_raw(self, msg: \"MessageType\") -&gt; \"MessageType\":\n        \"\"\"Send a protobuf message to the device and return the immediate response.\n\n        Bypasses handling of auxilliary flows like `ButtonRequest`, `PinRequest`,\n        `PassphraseRequest`.\n        \"\"\"\n        __tracebackhide__ = True  # for pytest # pylint: disable=W0612\n        self._raw_write(msg)\n        return self._raw_read()\n\n    def _raw_write(self, msg: \"MessageType\") -&gt; None:\n        \"\"\"Send a protobuf message to the device.\"\"\"\n        __tracebackhide__ = True  # for pytest # pylint: disable=W0612\n        LOG.debug(\n            f\"sending message: {msg.__class__.__name__}\",\n            extra={\"protobuf\": msg},\n        )\n        msg_type, msg_bytes = self.mapping.encode(msg)\n        LOG.log(\n            DUMP_BYTES,\n            f\"encoded as type {msg_type} ({len(msg_bytes)} bytes): {msg_bytes.hex()}\",\n        )\n        self.transport.write(msg_type, msg_bytes)\n\n    def _raw_read(self) -&gt; \"MessageType\":\n        \"\"\"Read and return a response message from the device.\"\"\"\n        __tracebackhide__ = True  # for pytest # pylint: disable=W0612\n        msg_type, msg_bytes = self.transport.read()\n        LOG.log(\n            DUMP_BYTES,\n            f\"received type {msg_type} ({len(msg_bytes)} bytes): {msg_bytes.hex()}\",\n        )\n        msg = self.mapping.decode(msg_type, msg_bytes)\n        LOG.debug(\n            f\"received message: {msg.__class__.__name__}\",\n            extra={\"protobuf\": msg},\n        )\n        return msg\n\n    def _callback_pin(self, msg: messages.PinMatrixRequest) -&gt; \"MessageType\":\n        \"\"\"Obtain PIN from the UI implementation and send it to the device.\"\"\"\n        try:\n            pin = self.ui.get_pin(msg.type)\n        except exceptions.Cancelled:\n            self.call_raw(messages.Cancel())\n            raise\n\n        if any(d not in \"123456789\" for d in pin) or not (\n            1 &lt;= len(pin) &lt;= MAX_PIN_LENGTH\n        ):\n            self.call_raw(messages.Cancel())\n            raise ValueError(\"Invalid PIN provided\")\n\n        resp = self.call_raw(messages.PinMatrixAck(pin=pin))\n        if isinstance(resp, messages.Failure) and resp.code in (\n            messages.FailureType.PinInvalid,\n            messages.FailureType.PinCancelled,\n            messages.FailureType.PinExpected,\n        ):\n            raise exceptions.PinException(resp.code, resp.message)\n        else:\n            return resp\n\n    def _callback_passphrase(self, msg: messages.PassphraseRequest) -&gt; \"MessageType\":\n        \"\"\"Obtain passphrase from the UI implementation and send it into the device.\"\"\"\n        available_on_device = Capability.PassphraseEntry in self.features.capabilities\n\n        def send_passphrase(\n            passphrase: Optional[str] = None, on_device: Optional[bool] = None\n        ) -&gt; \"MessageType\":\n            msg = messages.PassphraseAck(passphrase=passphrase, on_device=on_device)\n            resp = self.call_raw(msg)\n            if isinstance(resp, messages.Deprecated_PassphraseStateRequest):\n                self.session_id = resp.state\n                resp = self.call_raw(messages.Deprecated_PassphraseStateAck())\n            return resp\n\n        # short-circuit old style entry\n        if msg._on_device is True:\n            return send_passphrase(None, None)\n\n        try:\n            passphrase = self.ui.get_passphrase(available_on_device=available_on_device)\n        except exceptions.Cancelled:\n            self.call_raw(messages.Cancel())\n            raise\n\n        if passphrase is PASSPHRASE_ON_DEVICE:\n            if not available_on_device:\n                self.call_raw(messages.Cancel())\n                raise RuntimeError(\"Device is not capable of entering passphrase\")\n            else:\n                return send_passphrase(on_device=True)\n\n        # else process host-entered passphrase\n        if not isinstance(passphrase, str):\n            raise RuntimeError(\"Passphrase must be a str\")\n        passphrase = Mnemonic.normalize_string(passphrase)\n        if len(passphrase) &gt; MAX_PASSPHRASE_LENGTH:\n            self.call_raw(messages.Cancel())\n            raise ValueError(\"Passphrase too long\")\n\n        return send_passphrase(passphrase, on_device=False)\n\n    def _callback_button(self, msg: messages.ButtonRequest) -&gt; \"MessageType\":\n        \"\"\"Acknowledge to the device the ButtonRequest was received, send\n        it to the UI and wait for the device response.\n\n        Args:\n            msg: the ButtonRequest message received from the device.\n\n        Returns:\n            The response from the device.\n        \"\"\"\n        __tracebackhide__ = True  # for pytest # pylint: disable=W0612\n        # do this raw - send ButtonAck first, notify UI later\n        self._raw_write(messages.ButtonAck())\n        self.ui.button_request(msg)\n        return self._raw_read()\n\n    @session\n    def call(self, msg: \"MessageType\") -&gt; \"MessageType\":\n        \"\"\"Send a protobuf message to the device and return the response.\n\n        Automatically handles auxilliary flows like `ButtonRequest` etc. While `call()`\n        is running, there can be any number of callbacks into the UI implementation.\n\n        Args:\n            msg: protobuf message to send\n\n        Returns:\n            Protobuf message received from the device\n        \"\"\"\n        self.check_firmware_version()\n        resp = self.call_raw(msg)\n        while True:\n            if isinstance(resp, messages.PinMatrixRequest):\n                resp = self._callback_pin(resp)\n            elif isinstance(resp, messages.PassphraseRequest):\n                resp = self._callback_passphrase(resp)\n            elif isinstance(resp, messages.ButtonRequest):\n                resp = self._callback_button(resp)\n            elif isinstance(resp, messages.Failure):\n                if resp.code == messages.FailureType.ActionCancelled:\n                    raise exceptions.Cancelled\n                raise exceptions.TrezorFailure(resp)\n            else:\n                return resp\n\n    def _refresh_features(self, features: messages.Features) -&gt; None:\n        \"\"\"Update internal fields based on passed-in Features message.\n\n        Args:\n            features: Features message coming from the device.\n        \"\"\"\n\n        if not self.model:\n            # Trezor Model One bootloader 1.8.0 or older does not send model name\n            self.model = models.by_name(features.model or \"1\")\n            if self.model is None:\n                raise RuntimeError(\"Unsupported Trezor model\")\n\n        if features.vendor not in self.model.vendors:\n            raise RuntimeError(\"Unsupported device\")\n\n        self.features = features\n        self.version = (\n            self.features.major_version,\n            self.features.minor_version,\n            self.features.patch_version,\n        )\n        self.check_firmware_version(warn_only=True)\n        if self.features.session_id is not None:\n            self.session_id = self.features.session_id\n            self.features.session_id = None\n\n    @session\n    def refresh_features(self) -&gt; messages.Features:\n        \"\"\"Reload features from the device.\n\n        Should be called after changing settings or performing operations that affect\n        device state.\n\n        Returns:\n            Features message from the device.\n        \"\"\"\n        resp = self.call_raw(messages.GetFeatures())\n        if not isinstance(resp, messages.Features):\n            raise exceptions.TrezorException(\"Unexpected response to GetFeatures\")\n        self._refresh_features(resp)\n        return resp\n\n    @session\n    def init_device(\n        self,\n        *,\n        session_id: Optional[bytes] = None,\n        new_session: bool = False,\n        derive_cardano: Optional[bool] = None,\n    ) -&gt; Optional[bytes]:\n        \"\"\"Initialize the device and return a session ID.\n\n        Args:\n            session_id: Attempt to resume a session with this ID.\n            new_session: If True, a new session ID will be generated and returned.\n            derive_cardano: If True, the Cardano app will be initialized.\n\n        Returns:\n            Session ID, if we manage to get it, otherwise None.\n\n        You can optionally specify a session ID. If the session still exists on the\n        device, the same session ID will be returned and the session is resumed.\n        Otherwise a different session ID is returned.\n\n        Specify `new_session=True` to open a fresh session. Since firmware version\n        1.9.0/2.3.0, the previous session will remain cached on the device, and can be\n        resumed by calling `init_device` again with the appropriate session ID.\n\n        If neither `new_session` nor `session_id` is specified, the current session ID\n        will be reused. If no session ID was cached, a new session ID will be allocated\n        and returned.\n\n        If `derive_cardano` is True, and the device supports it, the Cardano master\n        secrets will be derived. This is required for using Cardano derivations other\n        than `LEDGER` -- attempting to call Cardano functions in a session without\n        `derive_cardano` will result in an error.\n\n        Enabling `derive_cardano` can increase session startup time by up to 5 seconds.\n\n        # Version notes:\n\n        Trezor One older than 1.9.0 does not have session management. Optional arguments\n        have no effect and the function returns None\n\n        Trezor T older than 2.3.0 does not have session cache. Requesting a new session\n        will overwrite the old one. In addition, this function will always return None.\n        A valid session_id can be obtained from the `session_id` attribute, but only\n        after a passphrase-protected call is performed. You can use the following code:\n\n        ```python\n        client.init_device()\n        client.ensure_unlocked()\n        valid_session_id = client.session_id\n        ```\n        \"\"\"\n        if new_session:\n            self.session_id = None\n        elif session_id is not None:\n            self.session_id = session_id\n\n        resp = self.call_raw(\n            messages.Initialize(\n                session_id=self.session_id,\n                derive_cardano=derive_cardano,\n            )\n        )\n        if isinstance(resp, messages.Failure):\n            # can happen if `derive_cardano` does not match the current session\n            raise exceptions.TrezorFailure(resp)\n        if not isinstance(resp, messages.Features):\n            raise exceptions.TrezorException(\"Unexpected response to Initialize\")\n\n        if self.session_id is not None and resp.session_id == self.session_id:\n            LOG.info(\"Successfully resumed session\")\n        elif session_id is not None:\n            LOG.info(\"Failed to resume session\")\n\n        # TT &lt; 2.3.0 compatibility:\n        # _refresh_features will clear out the session_id field. We want this function\n        # to return its value, so that callers can rely on it being either a valid\n        # session_id, or None if we can't do that.\n        # Older TT FW does not report session_id in Features and self.session_id might\n        # be invalid because TT will not allocate a session_id until a passphrase\n        # exchange happens.\n        reported_session_id = resp.session_id\n        self._refresh_features(resp)\n        return reported_session_id\n\n    def is_outdated(self) -&gt; bool:\n        \"\"\"Check if the device firmware is outdated.\n\n        Returns:\n            True if the device firmware is outdated, False otherwise.\n        \"\"\"\n        if self.features.bootloader_mode:\n            return False\n\n        assert self.model is not None  # should happen in _refresh_features\n        return self.version &lt; self.model.minimum_version\n\n    def check_firmware_version(self, warn_only: bool = False) -&gt; None:\n        \"\"\"Check if the firmware version is still actively supported.\n\n        Args:\n            warn_only: If True, only log a warning. Otherwise, raise an exception.\n\n        Raises:\n            OutdatedFirmwareError: If the firmware version is too old.\n        \"\"\"\n        if self.is_outdated():\n            if warn_only:\n                warnings.warn(\"Firmware is out of date\", stacklevel=2)\n            else:\n                raise exceptions.OutdatedFirmwareError(OUTDATED_FIRMWARE_ERROR)\n\n    @expect(messages.Success, field=\"message\", ret_type=str)\n    def ping(\n        self,\n        msg: str,\n        button_protection: bool = False,\n    ) -&gt; \"MessageType\":\n        \"\"\"Ping the device.\n\n        Args:\n            msg: Message to display on the device.\n            button_protection: Require button press to confirm.\n\n        Returns:\n            The success message/string returned by the device.\n        \"\"\"\n        # We would like ping to work on any valid TrezorClient instance, but\n        # due to the protection modes, we need to go through self.call, and that will\n        # raise an exception if the firmware is too old.\n        # So we short-circuit the simplest variant of ping with call_raw.\n        if not button_protection:\n            # XXX this should be: `with self:`\n            try:\n                self.open()\n                resp = self.call_raw(messages.Ping(message=msg))\n                if isinstance(resp, messages.ButtonRequest):\n                    # device is PIN-locked.\n                    # respond and hope for the best\n                    resp = self._callback_button(resp)\n                return resp\n            finally:\n                self.close()\n\n        return self.call(\n            messages.Ping(message=msg, button_protection=button_protection)\n        )\n\n    def get_device_id(self) -&gt; str:\n        \"\"\"Get device ID.\n\n        Returns:\n            Device ID in hexadecimal string.\n        \"\"\"\n        assert self.features.device_id is not None\n        return self.features.device_id\n\n    @session\n    def lock(self, *, _refresh_features: bool = True) -&gt; None:\n        \"\"\"Lock the device.\n\n        If the device does not have a PIN configured, this will do nothing.\n        Otherwise, a lock screen will be shown and the device will prompt for PIN\n        before further actions.\n\n        This call does _not_ invalidate passphrase cache. If passphrase is in use,\n        the device will not prompt for it after unlocking.\n\n        To invalidate passphrase cache, use `end_session()`. To lock _and_ invalidate\n        passphrase cache, use `clear_session()`.\n        \"\"\"\n        # Private argument _refresh_features can be used internally to avoid\n        # refreshing in cases where we will refresh soon anyway. This is used\n        # in TrezorClient.clear_session()\n        self.call(messages.LockDevice())\n        if _refresh_features:\n            self.refresh_features()\n\n    @session\n    def ensure_unlocked(self) -&gt; None:\n        \"\"\"Ensure the device is unlocked and a passphrase is cached.\n\n        If the device is locked, this will prompt for PIN. If passphrase is enabled\n        and no passphrase is cached for the current session, the device will also\n        prompt for passphrase.\n\n        After calling this method, further actions on the device will not prompt for\n        PIN or passphrase until the device is locked or the session becomes invalid.\n        \"\"\"\n        from .btc import get_address\n\n        get_address(self, \"Testnet\", PASSPHRASE_TEST_PATH)\n        self.refresh_features()\n\n    def end_session(self) -&gt; None:\n        \"\"\"Close the current session and clear cached passphrase.\n\n        The session will become invalid until `init_device()` is called again.\n        If passphrase is enabled, further actions will prompt for it again.\n\n        This is a no-op in bootloader mode, as it does not support session management.\n        \"\"\"\n        # since: 2.3.4, 1.9.4\n        try:\n            if not self.features.bootloader_mode:\n                self.call(messages.EndSession())\n        except exceptions.TrezorFailure:\n            # A failure most likely means that the FW version does not support\n            # the EndSession call. We ignore the failure and clear the local session_id.\n            # The client-side end result is identical.\n            pass\n        self.session_id = None\n\n    @session\n    def clear_session(self) -&gt; None:\n        \"\"\"Lock the device and present a fresh session.\n\n        The current session will be invalidated and a new one will be started. If the\n        device has PIN enabled, it will become locked.\n\n        Equivalent to calling `lock()`, `end_session()` and `init_device()`.\n        \"\"\"\n        self.lock(_refresh_features=False)\n        self.end_session()\n        self.init_device(new_session=True)\n</code></pre>"},{"location":"API/client/#python.src.trezorlib.client.TrezorClient.__init__","title":"<code>__init__(transport, ui, session_id=None, derive_cardano=None, model=None, _init_device=True)</code>","text":"<p>Create a TrezorClient instance.</p> <p>Parameters:</p> Name Type Description Default <code>transport</code> <code>Transport</code> <p>Transport instance</p> required <code>ui</code> <code>TrezorClientUI</code> <p>UI instance</p> required <code>session_id</code> <code>Optional[bytes]</code> <p>attempt to resume session with the given ID</p> <code>None</code> <code>derive_cardano</code> <code>Optional[bool]</code> <p>enable the Cardano app, if available</p> <code>None</code> <code>model</code> <code>Optional[TrezorModel]</code> <p>Optional model of the device</p> <code>None</code> <code>_init_device</code> <code>bool</code> <p>Whether to initialize the device (more below)</p> <code>True</code> <p>You have to provide a <code>transport</code>, i.e., a raw connection to the device. You can use <code>trezorlib.transport.get_transport</code> to find one.</p> <p>You have to provide an UI implementation for the three kinds of interaction: - button request (notify the user that their interaction is needed) - PIN request (on T1, ask the user to input numbers for a PIN matrix) - passphrase request (ask the user to enter a passphrase) See <code>trezorlib.ui</code> for   details.</p> <p>See <code>TrezorClient.init_device</code> for details about <code>session_id</code> and <code>derive_cardano</code>.</p> <p>You can provide Trezor model information. If not provided, it is detected from the model name reported at initialization time.</p> <p>By default, the instance will open a connection to the Trezor device, send an <code>Initialize</code> message, set up the <code>features</code> field from the response, and connect to a session. By specifying <code>_init_device=False</code>, this step is skipped. Notably, this means that <code>client.features</code> is unset. Use <code>client.init_device()</code> or <code>client.refresh_features()</code> to fix that, otherwise A LOT OF THINGS will break. Only use this if you are sure that you know what you are doing. This feature might be removed at any time.</p> Source code in <code>src/trezorlib/client.py</code> <pre><code>def __init__(\n    self,\n    transport: \"Transport\",\n    ui: \"TrezorClientUI\",\n    session_id: Optional[bytes] = None,\n    derive_cardano: Optional[bool] = None,\n    model: Optional[models.TrezorModel] = None,\n    _init_device: bool = True,\n) -&gt; None:\n    \"\"\"Create a TrezorClient instance.\n\n    Args:\n        transport: Transport instance\n        ui: UI instance\n        session_id: attempt to resume session with the given ID\n        derive_cardano: enable the Cardano app, if available\n        model: Optional model of the device\n        _init_device: Whether to initialize the device (more below)\n\n    You have to provide a `transport`, i.e., a raw connection to the device. You can\n    use `trezorlib.transport.get_transport` to find one.\n\n    You have to provide an UI implementation for the three kinds of interaction:\n    - button request (notify the user that their interaction is needed)\n    - PIN request (on T1, ask the user to input numbers for a PIN matrix)\n    - passphrase request (ask the user to enter a passphrase) See `trezorlib.ui` for\n      details.\n\n    See `TrezorClient.init_device` for details about `session_id` and\n    `derive_cardano`.\n\n    You can provide Trezor model information. If not provided, it is detected from\n    the model name reported at initialization time.\n\n    By default, the instance will open a connection to the Trezor device, send an\n    `Initialize` message, set up the `features` field from the response, and connect\n    to a session. By specifying `_init_device=False`, this step is skipped. Notably,\n    this means that `client.features` is unset. Use `client.init_device()` or\n    `client.refresh_features()` to fix that, otherwise A LOT OF THINGS will break.\n    Only use this if you are _sure_ that you know what you are doing. This feature\n    might be removed at any time.\n    \"\"\"\n    LOG.info(f\"creating client instance for device: {transport.get_path()}\")\n    self.model = model\n    if self.model:\n        self.mapping = self.model.default_mapping\n    else:\n        self.mapping = mapping.DEFAULT_MAPPING\n    self.transport = transport\n    self.ui = ui\n    self.session_counter = 0\n    self.session_id = session_id\n    if _init_device:\n        self.init_device(session_id=session_id, derive_cardano=derive_cardano)\n</code></pre>"},{"location":"API/client/#python.src.trezorlib.client.TrezorClient.call","title":"<code>call(msg)</code>","text":"<p>Send a protobuf message to the device and return the response.</p> <p>Automatically handles auxilliary flows like <code>ButtonRequest</code> etc. While <code>call()</code> is running, there can be any number of callbacks into the UI implementation.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>MessageType</code> <p>protobuf message to send</p> required <p>Returns:</p> Type Description <code>MessageType</code> <p>Protobuf message received from the device</p> Source code in <code>src/trezorlib/client.py</code> <pre><code>@session\ndef call(self, msg: \"MessageType\") -&gt; \"MessageType\":\n    \"\"\"Send a protobuf message to the device and return the response.\n\n    Automatically handles auxilliary flows like `ButtonRequest` etc. While `call()`\n    is running, there can be any number of callbacks into the UI implementation.\n\n    Args:\n        msg: protobuf message to send\n\n    Returns:\n        Protobuf message received from the device\n    \"\"\"\n    self.check_firmware_version()\n    resp = self.call_raw(msg)\n    while True:\n        if isinstance(resp, messages.PinMatrixRequest):\n            resp = self._callback_pin(resp)\n        elif isinstance(resp, messages.PassphraseRequest):\n            resp = self._callback_passphrase(resp)\n        elif isinstance(resp, messages.ButtonRequest):\n            resp = self._callback_button(resp)\n        elif isinstance(resp, messages.Failure):\n            if resp.code == messages.FailureType.ActionCancelled:\n                raise exceptions.Cancelled\n            raise exceptions.TrezorFailure(resp)\n        else:\n            return resp\n</code></pre>"},{"location":"API/client/#python.src.trezorlib.client.TrezorClient.call_raw","title":"<code>call_raw(msg)</code>","text":"<p>Send a protobuf message to the device and return the immediate response.</p> <p>Bypasses handling of auxilliary flows like <code>ButtonRequest</code>, <code>PinRequest</code>, <code>PassphraseRequest</code>.</p> Source code in <code>src/trezorlib/client.py</code> <pre><code>def call_raw(self, msg: \"MessageType\") -&gt; \"MessageType\":\n    \"\"\"Send a protobuf message to the device and return the immediate response.\n\n    Bypasses handling of auxilliary flows like `ButtonRequest`, `PinRequest`,\n    `PassphraseRequest`.\n    \"\"\"\n    __tracebackhide__ = True  # for pytest # pylint: disable=W0612\n    self._raw_write(msg)\n    return self._raw_read()\n</code></pre>"},{"location":"API/client/#python.src.trezorlib.client.TrezorClient.cancel","title":"<code>cancel()</code>","text":"<p>Send a Cancel message to the device, aborting the current operation.</p> Source code in <code>src/trezorlib/client.py</code> <pre><code>def cancel(self) -&gt; None:\n    \"\"\"Send a Cancel message to the device, aborting the current operation.\"\"\"\n    self._raw_write(messages.Cancel())\n</code></pre>"},{"location":"API/client/#python.src.trezorlib.client.TrezorClient.check_firmware_version","title":"<code>check_firmware_version(warn_only=False)</code>","text":"<p>Check if the firmware version is still actively supported.</p> <p>Parameters:</p> Name Type Description Default <code>warn_only</code> <code>bool</code> <p>If True, only log a warning. Otherwise, raise an exception.</p> <code>False</code> <p>Raises:</p> Type Description <code>OutdatedFirmwareError</code> <p>If the firmware version is too old.</p> Source code in <code>src/trezorlib/client.py</code> <pre><code>def check_firmware_version(self, warn_only: bool = False) -&gt; None:\n    \"\"\"Check if the firmware version is still actively supported.\n\n    Args:\n        warn_only: If True, only log a warning. Otherwise, raise an exception.\n\n    Raises:\n        OutdatedFirmwareError: If the firmware version is too old.\n    \"\"\"\n    if self.is_outdated():\n        if warn_only:\n            warnings.warn(\"Firmware is out of date\", stacklevel=2)\n        else:\n            raise exceptions.OutdatedFirmwareError(OUTDATED_FIRMWARE_ERROR)\n</code></pre>"},{"location":"API/client/#python.src.trezorlib.client.TrezorClient.clear_session","title":"<code>clear_session()</code>","text":"<p>Lock the device and present a fresh session.</p> <p>The current session will be invalidated and a new one will be started. If the device has PIN enabled, it will become locked.</p> <p>Equivalent to calling <code>lock()</code>, <code>end_session()</code> and <code>init_device()</code>.</p> Source code in <code>src/trezorlib/client.py</code> <pre><code>@session\ndef clear_session(self) -&gt; None:\n    \"\"\"Lock the device and present a fresh session.\n\n    The current session will be invalidated and a new one will be started. If the\n    device has PIN enabled, it will become locked.\n\n    Equivalent to calling `lock()`, `end_session()` and `init_device()`.\n    \"\"\"\n    self.lock(_refresh_features=False)\n    self.end_session()\n    self.init_device(new_session=True)\n</code></pre>"},{"location":"API/client/#python.src.trezorlib.client.TrezorClient.close","title":"<code>close()</code>","text":"<p>Close the connection with the device.</p> Source code in <code>src/trezorlib/client.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the connection with the device.\"\"\"\n    self.session_counter = max(self.session_counter - 1, 0)\n    if self.session_counter == 0:\n        # TODO call EndSession here?\n        self.transport.end_session()\n</code></pre>"},{"location":"API/client/#python.src.trezorlib.client.TrezorClient.end_session","title":"<code>end_session()</code>","text":"<p>Close the current session and clear cached passphrase.</p> <p>The session will become invalid until <code>init_device()</code> is called again. If passphrase is enabled, further actions will prompt for it again.</p> <p>This is a no-op in bootloader mode, as it does not support session management.</p> Source code in <code>src/trezorlib/client.py</code> <pre><code>def end_session(self) -&gt; None:\n    \"\"\"Close the current session and clear cached passphrase.\n\n    The session will become invalid until `init_device()` is called again.\n    If passphrase is enabled, further actions will prompt for it again.\n\n    This is a no-op in bootloader mode, as it does not support session management.\n    \"\"\"\n    # since: 2.3.4, 1.9.4\n    try:\n        if not self.features.bootloader_mode:\n            self.call(messages.EndSession())\n    except exceptions.TrezorFailure:\n        # A failure most likely means that the FW version does not support\n        # the EndSession call. We ignore the failure and clear the local session_id.\n        # The client-side end result is identical.\n        pass\n    self.session_id = None\n</code></pre>"},{"location":"API/client/#python.src.trezorlib.client.TrezorClient.ensure_unlocked","title":"<code>ensure_unlocked()</code>","text":"<p>Ensure the device is unlocked and a passphrase is cached.</p> <p>If the device is locked, this will prompt for PIN. If passphrase is enabled and no passphrase is cached for the current session, the device will also prompt for passphrase.</p> <p>After calling this method, further actions on the device will not prompt for PIN or passphrase until the device is locked or the session becomes invalid.</p> Source code in <code>src/trezorlib/client.py</code> <pre><code>@session\ndef ensure_unlocked(self) -&gt; None:\n    \"\"\"Ensure the device is unlocked and a passphrase is cached.\n\n    If the device is locked, this will prompt for PIN. If passphrase is enabled\n    and no passphrase is cached for the current session, the device will also\n    prompt for passphrase.\n\n    After calling this method, further actions on the device will not prompt for\n    PIN or passphrase until the device is locked or the session becomes invalid.\n    \"\"\"\n    from .btc import get_address\n\n    get_address(self, \"Testnet\", PASSPHRASE_TEST_PATH)\n    self.refresh_features()\n</code></pre>"},{"location":"API/client/#python.src.trezorlib.client.TrezorClient.get_device_id","title":"<code>get_device_id()</code>","text":"<p>Get device ID.</p> <p>Returns:</p> Type Description <code>str</code> <p>Device ID in hexadecimal string.</p> Source code in <code>src/trezorlib/client.py</code> <pre><code>def get_device_id(self) -&gt; str:\n    \"\"\"Get device ID.\n\n    Returns:\n        Device ID in hexadecimal string.\n    \"\"\"\n    assert self.features.device_id is not None\n    return self.features.device_id\n</code></pre>"},{"location":"API/client/#python.src.trezorlib.client.TrezorClient.init_device","title":"<code>init_device(*, session_id=None, new_session=False, derive_cardano=None)</code>","text":"<p>Initialize the device and return a session ID.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>Optional[bytes]</code> <p>Attempt to resume a session with this ID.</p> <code>None</code> <code>new_session</code> <code>bool</code> <p>If True, a new session ID will be generated and returned.</p> <code>False</code> <code>derive_cardano</code> <code>Optional[bool]</code> <p>If True, the Cardano app will be initialized.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>Session ID, if we manage to get it, otherwise None.</p> <p>You can optionally specify a session ID. If the session still exists on the device, the same session ID will be returned and the session is resumed. Otherwise a different session ID is returned.</p> <p>Specify <code>new_session=True</code> to open a fresh session. Since firmware version 1.9.0/2.3.0, the previous session will remain cached on the device, and can be resumed by calling <code>init_device</code> again with the appropriate session ID.</p> <p>If neither <code>new_session</code> nor <code>session_id</code> is specified, the current session ID will be reused. If no session ID was cached, a new session ID will be allocated and returned.</p> <p>If <code>derive_cardano</code> is True, and the device supports it, the Cardano master secrets will be derived. This is required for using Cardano derivations other than <code>LEDGER</code> -- attempting to call Cardano functions in a session without <code>derive_cardano</code> will result in an error.</p> <p>Enabling <code>derive_cardano</code> can increase session startup time by up to 5 seconds.</p>"},{"location":"API/client/#python.src.trezorlib.client.TrezorClient.init_device--version-notes","title":"Version notes:","text":"<p>Trezor One older than 1.9.0 does not have session management. Optional arguments have no effect and the function returns None</p> <p>Trezor T older than 2.3.0 does not have session cache. Requesting a new session will overwrite the old one. In addition, this function will always return None. A valid session_id can be obtained from the <code>session_id</code> attribute, but only after a passphrase-protected call is performed. You can use the following code:</p> <pre><code>client.init_device()\nclient.ensure_unlocked()\nvalid_session_id = client.session_id\n</code></pre> Source code in <code>src/trezorlib/client.py</code> <pre><code>@session\ndef init_device(\n    self,\n    *,\n    session_id: Optional[bytes] = None,\n    new_session: bool = False,\n    derive_cardano: Optional[bool] = None,\n) -&gt; Optional[bytes]:\n    \"\"\"Initialize the device and return a session ID.\n\n    Args:\n        session_id: Attempt to resume a session with this ID.\n        new_session: If True, a new session ID will be generated and returned.\n        derive_cardano: If True, the Cardano app will be initialized.\n\n    Returns:\n        Session ID, if we manage to get it, otherwise None.\n\n    You can optionally specify a session ID. If the session still exists on the\n    device, the same session ID will be returned and the session is resumed.\n    Otherwise a different session ID is returned.\n\n    Specify `new_session=True` to open a fresh session. Since firmware version\n    1.9.0/2.3.0, the previous session will remain cached on the device, and can be\n    resumed by calling `init_device` again with the appropriate session ID.\n\n    If neither `new_session` nor `session_id` is specified, the current session ID\n    will be reused. If no session ID was cached, a new session ID will be allocated\n    and returned.\n\n    If `derive_cardano` is True, and the device supports it, the Cardano master\n    secrets will be derived. This is required for using Cardano derivations other\n    than `LEDGER` -- attempting to call Cardano functions in a session without\n    `derive_cardano` will result in an error.\n\n    Enabling `derive_cardano` can increase session startup time by up to 5 seconds.\n\n    # Version notes:\n\n    Trezor One older than 1.9.0 does not have session management. Optional arguments\n    have no effect and the function returns None\n\n    Trezor T older than 2.3.0 does not have session cache. Requesting a new session\n    will overwrite the old one. In addition, this function will always return None.\n    A valid session_id can be obtained from the `session_id` attribute, but only\n    after a passphrase-protected call is performed. You can use the following code:\n\n    ```python\n    client.init_device()\n    client.ensure_unlocked()\n    valid_session_id = client.session_id\n    ```\n    \"\"\"\n    if new_session:\n        self.session_id = None\n    elif session_id is not None:\n        self.session_id = session_id\n\n    resp = self.call_raw(\n        messages.Initialize(\n            session_id=self.session_id,\n            derive_cardano=derive_cardano,\n        )\n    )\n    if isinstance(resp, messages.Failure):\n        # can happen if `derive_cardano` does not match the current session\n        raise exceptions.TrezorFailure(resp)\n    if not isinstance(resp, messages.Features):\n        raise exceptions.TrezorException(\"Unexpected response to Initialize\")\n\n    if self.session_id is not None and resp.session_id == self.session_id:\n        LOG.info(\"Successfully resumed session\")\n    elif session_id is not None:\n        LOG.info(\"Failed to resume session\")\n\n    # TT &lt; 2.3.0 compatibility:\n    # _refresh_features will clear out the session_id field. We want this function\n    # to return its value, so that callers can rely on it being either a valid\n    # session_id, or None if we can't do that.\n    # Older TT FW does not report session_id in Features and self.session_id might\n    # be invalid because TT will not allocate a session_id until a passphrase\n    # exchange happens.\n    reported_session_id = resp.session_id\n    self._refresh_features(resp)\n    return reported_session_id\n</code></pre>"},{"location":"API/client/#python.src.trezorlib.client.TrezorClient.is_outdated","title":"<code>is_outdated()</code>","text":"<p>Check if the device firmware is outdated.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the device firmware is outdated, False otherwise.</p> Source code in <code>src/trezorlib/client.py</code> <pre><code>def is_outdated(self) -&gt; bool:\n    \"\"\"Check if the device firmware is outdated.\n\n    Returns:\n        True if the device firmware is outdated, False otherwise.\n    \"\"\"\n    if self.features.bootloader_mode:\n        return False\n\n    assert self.model is not None  # should happen in _refresh_features\n    return self.version &lt; self.model.minimum_version\n</code></pre>"},{"location":"API/client/#python.src.trezorlib.client.TrezorClient.lock","title":"<code>lock(*, _refresh_features=True)</code>","text":"<p>Lock the device.</p> <p>If the device does not have a PIN configured, this will do nothing. Otherwise, a lock screen will be shown and the device will prompt for PIN before further actions.</p> <p>This call does not invalidate passphrase cache. If passphrase is in use, the device will not prompt for it after unlocking.</p> <p>To invalidate passphrase cache, use <code>end_session()</code>. To lock and invalidate passphrase cache, use <code>clear_session()</code>.</p> Source code in <code>src/trezorlib/client.py</code> <pre><code>@session\ndef lock(self, *, _refresh_features: bool = True) -&gt; None:\n    \"\"\"Lock the device.\n\n    If the device does not have a PIN configured, this will do nothing.\n    Otherwise, a lock screen will be shown and the device will prompt for PIN\n    before further actions.\n\n    This call does _not_ invalidate passphrase cache. If passphrase is in use,\n    the device will not prompt for it after unlocking.\n\n    To invalidate passphrase cache, use `end_session()`. To lock _and_ invalidate\n    passphrase cache, use `clear_session()`.\n    \"\"\"\n    # Private argument _refresh_features can be used internally to avoid\n    # refreshing in cases where we will refresh soon anyway. This is used\n    # in TrezorClient.clear_session()\n    self.call(messages.LockDevice())\n    if _refresh_features:\n        self.refresh_features()\n</code></pre>"},{"location":"API/client/#python.src.trezorlib.client.TrezorClient.open","title":"<code>open()</code>","text":"<p>Open a connection with the device.</p> Source code in <code>src/trezorlib/client.py</code> <pre><code>def open(self) -&gt; None:\n    \"\"\"Open a connection with the device.\"\"\"\n    if self.session_counter == 0:\n        self.transport.begin_session()\n    self.session_counter += 1\n</code></pre>"},{"location":"API/client/#python.src.trezorlib.client.TrezorClient.ping","title":"<code>ping(msg, button_protection=False)</code>","text":"<p>Ping the device.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>Message to display on the device.</p> required <code>button_protection</code> <code>bool</code> <p>Require button press to confirm.</p> <code>False</code> <p>Returns:</p> Type Description <code>MessageType</code> <p>The success message/string returned by the device.</p> Source code in <code>src/trezorlib/client.py</code> <pre><code>@expect(messages.Success, field=\"message\", ret_type=str)\ndef ping(\n    self,\n    msg: str,\n    button_protection: bool = False,\n) -&gt; \"MessageType\":\n    \"\"\"Ping the device.\n\n    Args:\n        msg: Message to display on the device.\n        button_protection: Require button press to confirm.\n\n    Returns:\n        The success message/string returned by the device.\n    \"\"\"\n    # We would like ping to work on any valid TrezorClient instance, but\n    # due to the protection modes, we need to go through self.call, and that will\n    # raise an exception if the firmware is too old.\n    # So we short-circuit the simplest variant of ping with call_raw.\n    if not button_protection:\n        # XXX this should be: `with self:`\n        try:\n            self.open()\n            resp = self.call_raw(messages.Ping(message=msg))\n            if isinstance(resp, messages.ButtonRequest):\n                # device is PIN-locked.\n                # respond and hope for the best\n                resp = self._callback_button(resp)\n            return resp\n        finally:\n            self.close()\n\n    return self.call(\n        messages.Ping(message=msg, button_protection=button_protection)\n    )\n</code></pre>"},{"location":"API/client/#python.src.trezorlib.client.TrezorClient.refresh_features","title":"<code>refresh_features()</code>","text":"<p>Reload features from the device.</p> <p>Should be called after changing settings or performing operations that affect device state.</p> <p>Returns:</p> Type Description <code>Features</code> <p>Features message from the device.</p> Source code in <code>src/trezorlib/client.py</code> <pre><code>@session\ndef refresh_features(self) -&gt; messages.Features:\n    \"\"\"Reload features from the device.\n\n    Should be called after changing settings or performing operations that affect\n    device state.\n\n    Returns:\n        Features message from the device.\n    \"\"\"\n    resp = self.call_raw(messages.GetFeatures())\n    if not isinstance(resp, messages.Features):\n        raise exceptions.TrezorException(\"Unexpected response to GetFeatures\")\n    self._refresh_features(resp)\n    return resp\n</code></pre>"},{"location":"API/client/#python.src.trezorlib.client.get_default_client","title":"<code>get_default_client(path=None, ui=None, **kwargs)</code>","text":"<p>Get a client for a connected Trezor device.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Optional[str]</code> <p>Optional path to the device, e.g. \"udp:21324\"</p> <code>None</code> <code>ui</code> <code>Optional[TrezorClientUI]</code> <p>Optional UI instance</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments to pass to the TrezorClient constructor</p> <code>{}</code> <p>Returns:</p> Type Description <code>TrezorClient</code> <p>TrezorClient instance</p> <p>Returns a <code>TrezorClient</code> instance with minimum fuss.</p> <p>If path is specified, does a prefix-search for the specified device. Otherwise, uses the value of <code>TREZOR_PATH</code> env variable, or finds first connected Trezor. If no UI is supplied, instantiates the default CLI UI - <code>ClickUI</code>.</p> Source code in <code>src/trezorlib/client.py</code> <pre><code>def get_default_client(\n    path: Optional[str] = None, ui: Optional[\"TrezorClientUI\"] = None, **kwargs: Any\n) -&gt; \"TrezorClient\":\n    \"\"\"Get a client for a connected Trezor device.\n\n    Args:\n        path: Optional path to the device, e.g. \"udp:21324\"\n        ui: Optional UI instance\n        **kwargs: Additional arguments to pass to the TrezorClient constructor\n\n    Returns:\n        TrezorClient instance\n\n    Returns a `TrezorClient` instance with minimum fuss.\n\n    If path is specified, does a prefix-search for the specified device. Otherwise, uses\n    the value of `TREZOR_PATH` env variable, or finds first connected Trezor.\n    If no UI is supplied, instantiates the default CLI UI - `ClickUI`.\n    \"\"\"\n    from .transport import get_transport\n    from .ui import ClickUI\n\n    if path is None:\n        path = os.getenv(\"TREZOR_PATH\")\n\n    transport = get_transport(path, prefix_search=True)\n    if ui is None:\n        ui = ClickUI()\n\n    return TrezorClient(transport, ui, **kwargs)\n</code></pre>"},{"location":"API/debuglink/","title":"Debuglink","text":"<pre><code>from trezorlib import debuglink\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink","title":"<code>DebugLink</code>","text":"<p>DebugLink client.</p> <p>Only works with Trezors that were built with debuglink support.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>class DebugLink:\n    \"\"\"DebugLink client.\n\n    Only works with Trezors that were built with debuglink support.\n    \"\"\"\n\n    def __init__(self, transport: \"Transport\", auto_interact: bool = True) -&gt; None:\n        self.transport = transport\n        self.allow_interactions = auto_interact\n        self.mapping = mapping.DEFAULT_MAPPING\n\n        # To be set by TrezorClientDebugLink (is not known during creation time)\n        self.model: Optional[str] = None\n\n        # For T1 screenshotting functionality in DebugUI\n        self.t1_take_screenshots = False\n        self.t1_screenshot_directory: Optional[Path] = None\n        self.t1_screenshot_counter = 0\n\n    def open(self) -&gt; None:\n        \"\"\"Open a debuglink connection.\"\"\"\n        self.transport.begin_session()\n\n    def close(self) -&gt; None:\n        \"\"\"Close a debuglink connection.\"\"\"\n        self.transport.end_session()\n\n    def _call(self, msg: protobuf.MessageType, nowait: bool = False) -&gt; Any:\n        \"\"\"Send a protobuf message to the device.\n\n        Args:\n            msg: Message to send\n            nowait: Do not wait for a response\n\n        Returns:\n            Response message or `None` if `nowait` is True\n        \"\"\"\n        LOG.debug(\n            f\"sending message: {msg.__class__.__name__}\",\n            extra={\"protobuf\": msg},\n        )\n        msg_type, msg_bytes = self.mapping.encode(msg)\n        LOG.log(\n            DUMP_BYTES,\n            f\"encoded as type {msg_type} ({len(msg_bytes)} bytes): {msg_bytes.hex()}\",\n        )\n        self.transport.write(msg_type, msg_bytes)\n        if nowait:\n            return None\n\n        ret_type, ret_bytes = self.transport.read()\n        LOG.log(\n            DUMP_BYTES,\n            f\"received type {msg_type} ({len(msg_bytes)} bytes): {msg_bytes.hex()}\",\n        )\n        msg = self.mapping.decode(ret_type, ret_bytes)\n        LOG.debug(\n            f\"received message: {msg.__class__.__name__}\",\n            extra={\"protobuf\": msg},\n        )\n        return msg\n\n    def state(self) -&gt; messages.DebugLinkState:\n        \"\"\"Get a debuglink state.\n\n        Returns:\n            DebugLinkState message\n\n        It includes information about the current screen content, PIN etc.\n        \"\"\"\n        return self._call(messages.DebugLinkGetState())\n\n    def read_layout(self) -&gt; LayoutContent:\n        \"\"\"Get the current content of the Trezor screen.\n\n        Returns:\n            LayoutContent\n        \"\"\"\n        return LayoutContent(self.state().layout_lines)\n\n    def wait_layout(self) -&gt; LayoutContent:\n        \"\"\"Get the content of the Trezor screen as soon as it changes.\n\n        Returns:\n            LayoutContent\n        \"\"\"\n        obj = self._call(messages.DebugLinkGetState(wait_layout=True))\n        if isinstance(obj, messages.Failure):\n            raise TrezorFailure(obj)\n        return LayoutContent(obj.layout_lines)\n\n    def watch_layout(self, watch: bool) -&gt; None:\n        \"\"\"Enable or disable watching layouts.\n        If disabled, wait_layout will not work.\n\n        The message is missing on T1. Use `TrezorClientDebugLink.watch_layout` for\n        cross-version compatibility.\n        \"\"\"\n        self._call(messages.DebugLinkWatchLayout(watch=watch))\n\n    def encode_pin(self, pin: str, matrix: Optional[str] = None) -&gt; str:\n        \"\"\"Transform correct PIN according to the displayed matrix.\n\n        Args:\n            pin: PIN\n            matrix: Optional matrix\n\n        Returns:\n            Encoded PIN\n        \"\"\"\n        if matrix is None:\n            matrix = self.state().matrix\n            if matrix is None:\n                # we are on trezor-core\n                return pin\n\n        return \"\".join([str(matrix.index(p) + 1) for p in pin])\n\n    def read_recovery_word(self) -&gt; Tuple[Optional[str], Optional[int]]:\n        \"\"\"Read the current recovery word.\n\n        Returns:\n                (fake) word on display during RecoveryDevice workflow\n                index of mnemonic word the device is expecting during RecoveryDevice workflow\n        \"\"\"\n        state = self.state()\n        return (state.recovery_fake_word, state.recovery_word_pos)\n\n    def read_reset_word(self) -&gt; str:\n        \"\"\"Read the mnemonic word(s) on the screen.\n\n        Returns:\n            word on device display during ResetDevice workflow\n        \"\"\"\n        state = self._call(messages.DebugLinkGetState(wait_word_list=True))\n        return state.reset_word\n\n    def read_reset_word_pos(self) -&gt; int:\n        \"\"\"Read the position of the requested word.\n\n        Returns:\n            index of mnemonic word the device is expecting during ResetDevice workflow\n        \"\"\"\n        state = self._call(messages.DebugLinkGetState(wait_word_pos=True))\n        return state.reset_word_pos\n\n    def input(\n        self,\n        word: Optional[str] = None,\n        button: Optional[messages.DebugButton] = None,\n        swipe: Optional[messages.DebugSwipeDirection] = None,\n        x: Optional[int] = None,\n        y: Optional[int] = None,\n        wait: Optional[bool] = None,\n        hold_ms: Optional[int] = None,\n    ) -&gt; Optional[LayoutContent]:\n        \"\"\"Somehow interact with the device.\n\n        Can be pressing a button, swiping the screen, or entering a word.\n\n        Args:\n            word: mnemonic word to enter\n            button: button to press\n            swipe: direction to swipe\n            x: x coordinate of the touch/click\n            y: y coordinate of the touch/click\n            wait: wait for the layout to change\n            hold_ms: hold the button for this many milliseconds\n\n        Returns:\n            LayoutContent if `wait` is True, `None` otherwise.\n        \"\"\"\n        if not self.allow_interactions:\n            return None\n\n        args = sum(a is not None for a in (word, button, swipe, x))\n        if args != 1:\n            raise ValueError(\"Invalid input - must use one of word, button, swipe\")\n\n        decision = messages.DebugLinkDecision(\n            button=button, swipe=swipe, input=word, x=x, y=y, wait=wait, hold_ms=hold_ms\n        )\n        ret = self._call(decision, nowait=not wait)\n        if ret is not None:\n            return LayoutContent(ret.lines)\n\n        return None\n\n    # Type overloads make sure that when we supply `wait=True` into `click()`,\n    # it will always return `LayoutContent` and we do not need to assert `is not None`.\n\n    @overload\n    def click(self, click: Tuple[int, int]) -&gt; None:\n        ...\n\n    @overload\n    def click(self, click: Tuple[int, int], wait: Literal[True]) -&gt; LayoutContent:\n        ...\n\n    def click(\n        self, click: Tuple[int, int], wait: bool = False\n    ) -&gt; Optional[LayoutContent]:\n        \"\"\"Click on a specific point on the screen.\n\n        Args:\n            click: (x, y) coordinates of the click\n            wait: wait for the screen to change\n\n        Returns:\n            LayoutContent if `wait` is True, `None` otherwise.\n        \"\"\"\n        x, y = click\n        return self.input(x=x, y=y, wait=wait)\n\n    def press_yes(self) -&gt; None:\n        \"\"\"Press the \"Yes\" button.\"\"\"\n        self.input(button=messages.DebugButton.YES)\n\n    def press_no(self) -&gt; None:\n        \"\"\"Press the \"No\" button.\"\"\"\n        self.input(button=messages.DebugButton.NO)\n\n    def press_info(self) -&gt; None:\n        \"\"\"Press the \"Info\" button.\"\"\"\n        self.input(button=messages.DebugButton.INFO)\n\n    def swipe_up(self, wait: bool = False) -&gt; None:\n        \"\"\"Swipe the screen up.\"\"\"\n        self.input(swipe=messages.DebugSwipeDirection.UP, wait=wait)\n\n    def swipe_down(self) -&gt; None:\n        \"\"\"Swipe the screen down.\"\"\"\n        self.input(swipe=messages.DebugSwipeDirection.DOWN)\n\n    def swipe_right(self) -&gt; None:\n        \"\"\"Swipe the screen right.\"\"\"\n        self.input(swipe=messages.DebugSwipeDirection.RIGHT)\n\n    def swipe_left(self) -&gt; None:\n        \"\"\"Swipe the screen left.\"\"\"\n        self.input(swipe=messages.DebugSwipeDirection.LEFT)\n\n    def stop(self) -&gt; None:\n        \"\"\"Kill the debuglink connection.\"\"\"\n        self._call(messages.DebugLinkStop(), nowait=True)\n\n    def reseed(self, value: int) -&gt; protobuf.MessageType:\n        \"\"\"Re-seed RNG with given value.\n\n        Args:\n            value: seed value\n        \"\"\"\n        return self._call(messages.DebugLinkReseedRandom(value=value))\n\n    def start_recording(self, directory: str) -&gt; None:\n        \"\"\"Start recording screen changes into a specified directory.\n\n        Different recording logic between TT and T1.\n\n        Args:\n            directory: directory to store the recordings\n        \"\"\"\n        if self.model == \"T\":\n            self._call(messages.DebugLinkRecordScreen(target_directory=directory))\n        else:\n            self.t1_screenshot_directory = Path(directory)\n            self.t1_screenshot_counter = 0\n            self.t1_take_screenshots = True\n\n    def stop_recording(self) -&gt; None:\n        \"\"\"Stop the screen recording.\n\n        Different logic between TT and T1.\n        \"\"\"\n        if self.model == \"T\":\n            self._call(messages.DebugLinkRecordScreen(target_directory=None))\n        else:\n            self.t1_take_screenshots = False\n\n    @expect(messages.DebugLinkMemory, field=\"memory\", ret_type=bytes)\n    def memory_read(self, address: int, length: int) -&gt; protobuf.MessageType:\n        \"\"\"Read memory from the device.\"\"\"\n        return self._call(messages.DebugLinkMemoryRead(address=address, length=length))\n\n    def memory_write(self, address: int, memory: bytes, flash: bool = False) -&gt; None:\n        \"\"\"Write memory to device.\n\n        WARNING: Writing to the wrong location can irreparably break the device.\n\n        Args:\n            address: Address to write to\n            memory: Data to write\n            flash: Write to flash\n        \"\"\"\n        self._call(\n            messages.DebugLinkMemoryWrite(address=address, memory=memory, flash=flash),\n            nowait=True,\n        )\n\n    def flash_erase(self, sector: int) -&gt; None:\n        \"\"\"Erase block of flash on device.\n\n        WARNING: Writing to the wrong location can irreparably break the device.\n\n        Args:\n            sector: Sector to erase\n        \"\"\"\n        self._call(messages.DebugLinkFlashErase(sector=sector), nowait=True)\n\n    @expect(messages.Success)\n    def erase_sd_card(self, format: bool = True) -&gt; messages.Success:\n        \"\"\"Erase the SD card.\n\n        Args:\n            format: Format the SD card after erasing\n        \"\"\"\n        return self._call(messages.DebugLinkEraseSdCard(format=format))\n\n    def take_t1_screenshot_if_relevant(self) -&gt; None:\n        \"\"\"Conditionally take screenshots on T1.\n\n        TT handles them differently, see debuglink.start_recording.\n        \"\"\"\n        if self.model == \"1\" and self.t1_take_screenshots:\n            self.save_screenshot_for_t1()\n\n    def save_screenshot_for_t1(self) -&gt; None:\n        \"\"\"Save screenshot for T1.\n\n        Reconstructs pixel data and saves it as a PNG file.\n        \"\"\"\n        from PIL import Image\n\n        layout = self.state().layout\n        assert layout is not None\n        assert len(layout) == 128 * 64 // 8\n\n        pixels: List[int] = []\n        for byteline in range(64 // 8):\n            offset = byteline * 128\n            row = layout[offset : offset + 128]\n            for bit in range(8):\n                pixels.extend(bool(px &amp; (1 &lt;&lt; bit)) for px in row)\n\n        im = Image.new(\"1\", (128, 64))\n        im.putdata(pixels[::-1])\n\n        assert self.t1_screenshot_directory is not None\n        img_location = (\n            self.t1_screenshot_directory / f\"{self.t1_screenshot_counter:04d}.png\"\n        )\n        im.save(img_location)\n        self.t1_screenshot_counter += 1\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.click","title":"<code>click(click, wait=False)</code>","text":"<pre><code>click(click: Tuple[int, int]) -&gt; None\n</code></pre><pre><code>click(click: Tuple[int, int], wait: Literal[True]) -&gt; LayoutContent\n</code></pre> <p>Click on a specific point on the screen.</p> <p>Parameters:</p> Name Type Description Default <code>click</code> <code>Tuple[int, int]</code> <p>(x, y) coordinates of the click</p> required <code>wait</code> <code>bool</code> <p>wait for the screen to change</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[LayoutContent]</code> <p>LayoutContent if <code>wait</code> is True, <code>None</code> otherwise.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def click(\n    self, click: Tuple[int, int], wait: bool = False\n) -&gt; Optional[LayoutContent]:\n    \"\"\"Click on a specific point on the screen.\n\n    Args:\n        click: (x, y) coordinates of the click\n        wait: wait for the screen to change\n\n    Returns:\n        LayoutContent if `wait` is True, `None` otherwise.\n    \"\"\"\n    x, y = click\n    return self.input(x=x, y=y, wait=wait)\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.close","title":"<code>close()</code>","text":"<p>Close a debuglink connection.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close a debuglink connection.\"\"\"\n    self.transport.end_session()\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.encode_pin","title":"<code>encode_pin(pin, matrix=None)</code>","text":"<p>Transform correct PIN according to the displayed matrix.</p> <p>Parameters:</p> Name Type Description Default <code>pin</code> <code>str</code> <p>PIN</p> required <code>matrix</code> <code>Optional[str]</code> <p>Optional matrix</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Encoded PIN</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def encode_pin(self, pin: str, matrix: Optional[str] = None) -&gt; str:\n    \"\"\"Transform correct PIN according to the displayed matrix.\n\n    Args:\n        pin: PIN\n        matrix: Optional matrix\n\n    Returns:\n        Encoded PIN\n    \"\"\"\n    if matrix is None:\n        matrix = self.state().matrix\n        if matrix is None:\n            # we are on trezor-core\n            return pin\n\n    return \"\".join([str(matrix.index(p) + 1) for p in pin])\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.erase_sd_card","title":"<code>erase_sd_card(format=True)</code>","text":"<p>Erase the SD card.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>bool</code> <p>Format the SD card after erasing</p> <code>True</code> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>@expect(messages.Success)\ndef erase_sd_card(self, format: bool = True) -&gt; messages.Success:\n    \"\"\"Erase the SD card.\n\n    Args:\n        format: Format the SD card after erasing\n    \"\"\"\n    return self._call(messages.DebugLinkEraseSdCard(format=format))\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.flash_erase","title":"<code>flash_erase(sector)</code>","text":"<p>Erase block of flash on device.</p> <p>WARNING: Writing to the wrong location can irreparably break the device.</p> <p>Parameters:</p> Name Type Description Default <code>sector</code> <code>int</code> <p>Sector to erase</p> required Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def flash_erase(self, sector: int) -&gt; None:\n    \"\"\"Erase block of flash on device.\n\n    WARNING: Writing to the wrong location can irreparably break the device.\n\n    Args:\n        sector: Sector to erase\n    \"\"\"\n    self._call(messages.DebugLinkFlashErase(sector=sector), nowait=True)\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.input","title":"<code>input(word=None, button=None, swipe=None, x=None, y=None, wait=None, hold_ms=None)</code>","text":"<p>Somehow interact with the device.</p> <p>Can be pressing a button, swiping the screen, or entering a word.</p> <p>Parameters:</p> Name Type Description Default <code>word</code> <code>Optional[str]</code> <p>mnemonic word to enter</p> <code>None</code> <code>button</code> <code>Optional[DebugButton]</code> <p>button to press</p> <code>None</code> <code>swipe</code> <code>Optional[DebugSwipeDirection]</code> <p>direction to swipe</p> <code>None</code> <code>x</code> <code>Optional[int]</code> <p>x coordinate of the touch/click</p> <code>None</code> <code>y</code> <code>Optional[int]</code> <p>y coordinate of the touch/click</p> <code>None</code> <code>wait</code> <code>Optional[bool]</code> <p>wait for the layout to change</p> <code>None</code> <code>hold_ms</code> <code>Optional[int]</code> <p>hold the button for this many milliseconds</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[LayoutContent]</code> <p>LayoutContent if <code>wait</code> is True, <code>None</code> otherwise.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def input(\n    self,\n    word: Optional[str] = None,\n    button: Optional[messages.DebugButton] = None,\n    swipe: Optional[messages.DebugSwipeDirection] = None,\n    x: Optional[int] = None,\n    y: Optional[int] = None,\n    wait: Optional[bool] = None,\n    hold_ms: Optional[int] = None,\n) -&gt; Optional[LayoutContent]:\n    \"\"\"Somehow interact with the device.\n\n    Can be pressing a button, swiping the screen, or entering a word.\n\n    Args:\n        word: mnemonic word to enter\n        button: button to press\n        swipe: direction to swipe\n        x: x coordinate of the touch/click\n        y: y coordinate of the touch/click\n        wait: wait for the layout to change\n        hold_ms: hold the button for this many milliseconds\n\n    Returns:\n        LayoutContent if `wait` is True, `None` otherwise.\n    \"\"\"\n    if not self.allow_interactions:\n        return None\n\n    args = sum(a is not None for a in (word, button, swipe, x))\n    if args != 1:\n        raise ValueError(\"Invalid input - must use one of word, button, swipe\")\n\n    decision = messages.DebugLinkDecision(\n        button=button, swipe=swipe, input=word, x=x, y=y, wait=wait, hold_ms=hold_ms\n    )\n    ret = self._call(decision, nowait=not wait)\n    if ret is not None:\n        return LayoutContent(ret.lines)\n\n    return None\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.memory_read","title":"<code>memory_read(address, length)</code>","text":"<p>Read memory from the device.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>@expect(messages.DebugLinkMemory, field=\"memory\", ret_type=bytes)\ndef memory_read(self, address: int, length: int) -&gt; protobuf.MessageType:\n    \"\"\"Read memory from the device.\"\"\"\n    return self._call(messages.DebugLinkMemoryRead(address=address, length=length))\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.memory_write","title":"<code>memory_write(address, memory, flash=False)</code>","text":"<p>Write memory to device.</p> <p>WARNING: Writing to the wrong location can irreparably break the device.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>Address to write to</p> required <code>memory</code> <code>bytes</code> <p>Data to write</p> required <code>flash</code> <code>bool</code> <p>Write to flash</p> <code>False</code> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def memory_write(self, address: int, memory: bytes, flash: bool = False) -&gt; None:\n    \"\"\"Write memory to device.\n\n    WARNING: Writing to the wrong location can irreparably break the device.\n\n    Args:\n        address: Address to write to\n        memory: Data to write\n        flash: Write to flash\n    \"\"\"\n    self._call(\n        messages.DebugLinkMemoryWrite(address=address, memory=memory, flash=flash),\n        nowait=True,\n    )\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.open","title":"<code>open()</code>","text":"<p>Open a debuglink connection.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def open(self) -&gt; None:\n    \"\"\"Open a debuglink connection.\"\"\"\n    self.transport.begin_session()\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.press_info","title":"<code>press_info()</code>","text":"<p>Press the \"Info\" button.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def press_info(self) -&gt; None:\n    \"\"\"Press the \"Info\" button.\"\"\"\n    self.input(button=messages.DebugButton.INFO)\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.press_no","title":"<code>press_no()</code>","text":"<p>Press the \"No\" button.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def press_no(self) -&gt; None:\n    \"\"\"Press the \"No\" button.\"\"\"\n    self.input(button=messages.DebugButton.NO)\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.press_yes","title":"<code>press_yes()</code>","text":"<p>Press the \"Yes\" button.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def press_yes(self) -&gt; None:\n    \"\"\"Press the \"Yes\" button.\"\"\"\n    self.input(button=messages.DebugButton.YES)\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.read_layout","title":"<code>read_layout()</code>","text":"<p>Get the current content of the Trezor screen.</p> <p>Returns:</p> Type Description <code>LayoutContent</code> <p>LayoutContent</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def read_layout(self) -&gt; LayoutContent:\n    \"\"\"Get the current content of the Trezor screen.\n\n    Returns:\n        LayoutContent\n    \"\"\"\n    return LayoutContent(self.state().layout_lines)\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.read_recovery_word","title":"<code>read_recovery_word()</code>","text":"<p>Read the current recovery word.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>(fake) word on display during RecoveryDevice workflow</p> <code>Optional[int]</code> <p>index of mnemonic word the device is expecting during RecoveryDevice workflow</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def read_recovery_word(self) -&gt; Tuple[Optional[str], Optional[int]]:\n    \"\"\"Read the current recovery word.\n\n    Returns:\n            (fake) word on display during RecoveryDevice workflow\n            index of mnemonic word the device is expecting during RecoveryDevice workflow\n    \"\"\"\n    state = self.state()\n    return (state.recovery_fake_word, state.recovery_word_pos)\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.read_reset_word","title":"<code>read_reset_word()</code>","text":"<p>Read the mnemonic word(s) on the screen.</p> <p>Returns:</p> Type Description <code>str</code> <p>word on device display during ResetDevice workflow</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def read_reset_word(self) -&gt; str:\n    \"\"\"Read the mnemonic word(s) on the screen.\n\n    Returns:\n        word on device display during ResetDevice workflow\n    \"\"\"\n    state = self._call(messages.DebugLinkGetState(wait_word_list=True))\n    return state.reset_word\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.read_reset_word_pos","title":"<code>read_reset_word_pos()</code>","text":"<p>Read the position of the requested word.</p> <p>Returns:</p> Type Description <code>int</code> <p>index of mnemonic word the device is expecting during ResetDevice workflow</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def read_reset_word_pos(self) -&gt; int:\n    \"\"\"Read the position of the requested word.\n\n    Returns:\n        index of mnemonic word the device is expecting during ResetDevice workflow\n    \"\"\"\n    state = self._call(messages.DebugLinkGetState(wait_word_pos=True))\n    return state.reset_word_pos\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.reseed","title":"<code>reseed(value)</code>","text":"<p>Re-seed RNG with given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>seed value</p> required Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def reseed(self, value: int) -&gt; protobuf.MessageType:\n    \"\"\"Re-seed RNG with given value.\n\n    Args:\n        value: seed value\n    \"\"\"\n    return self._call(messages.DebugLinkReseedRandom(value=value))\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.save_screenshot_for_t1","title":"<code>save_screenshot_for_t1()</code>","text":"<p>Save screenshot for T1.</p> <p>Reconstructs pixel data and saves it as a PNG file.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def save_screenshot_for_t1(self) -&gt; None:\n    \"\"\"Save screenshot for T1.\n\n    Reconstructs pixel data and saves it as a PNG file.\n    \"\"\"\n    from PIL import Image\n\n    layout = self.state().layout\n    assert layout is not None\n    assert len(layout) == 128 * 64 // 8\n\n    pixels: List[int] = []\n    for byteline in range(64 // 8):\n        offset = byteline * 128\n        row = layout[offset : offset + 128]\n        for bit in range(8):\n            pixels.extend(bool(px &amp; (1 &lt;&lt; bit)) for px in row)\n\n    im = Image.new(\"1\", (128, 64))\n    im.putdata(pixels[::-1])\n\n    assert self.t1_screenshot_directory is not None\n    img_location = (\n        self.t1_screenshot_directory / f\"{self.t1_screenshot_counter:04d}.png\"\n    )\n    im.save(img_location)\n    self.t1_screenshot_counter += 1\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.start_recording","title":"<code>start_recording(directory)</code>","text":"<p>Start recording screen changes into a specified directory.</p> <p>Different recording logic between TT and T1.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>directory to store the recordings</p> required Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def start_recording(self, directory: str) -&gt; None:\n    \"\"\"Start recording screen changes into a specified directory.\n\n    Different recording logic between TT and T1.\n\n    Args:\n        directory: directory to store the recordings\n    \"\"\"\n    if self.model == \"T\":\n        self._call(messages.DebugLinkRecordScreen(target_directory=directory))\n    else:\n        self.t1_screenshot_directory = Path(directory)\n        self.t1_screenshot_counter = 0\n        self.t1_take_screenshots = True\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.state","title":"<code>state()</code>","text":"<p>Get a debuglink state.</p> <p>Returns:</p> Type Description <code>DebugLinkState</code> <p>DebugLinkState message</p> <p>It includes information about the current screen content, PIN etc.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def state(self) -&gt; messages.DebugLinkState:\n    \"\"\"Get a debuglink state.\n\n    Returns:\n        DebugLinkState message\n\n    It includes information about the current screen content, PIN etc.\n    \"\"\"\n    return self._call(messages.DebugLinkGetState())\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.stop","title":"<code>stop()</code>","text":"<p>Kill the debuglink connection.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Kill the debuglink connection.\"\"\"\n    self._call(messages.DebugLinkStop(), nowait=True)\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.stop_recording","title":"<code>stop_recording()</code>","text":"<p>Stop the screen recording.</p> <p>Different logic between TT and T1.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def stop_recording(self) -&gt; None:\n    \"\"\"Stop the screen recording.\n\n    Different logic between TT and T1.\n    \"\"\"\n    if self.model == \"T\":\n        self._call(messages.DebugLinkRecordScreen(target_directory=None))\n    else:\n        self.t1_take_screenshots = False\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.swipe_down","title":"<code>swipe_down()</code>","text":"<p>Swipe the screen down.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def swipe_down(self) -&gt; None:\n    \"\"\"Swipe the screen down.\"\"\"\n    self.input(swipe=messages.DebugSwipeDirection.DOWN)\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.swipe_left","title":"<code>swipe_left()</code>","text":"<p>Swipe the screen left.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def swipe_left(self) -&gt; None:\n    \"\"\"Swipe the screen left.\"\"\"\n    self.input(swipe=messages.DebugSwipeDirection.LEFT)\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.swipe_right","title":"<code>swipe_right()</code>","text":"<p>Swipe the screen right.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def swipe_right(self) -&gt; None:\n    \"\"\"Swipe the screen right.\"\"\"\n    self.input(swipe=messages.DebugSwipeDirection.RIGHT)\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.swipe_up","title":"<code>swipe_up(wait=False)</code>","text":"<p>Swipe the screen up.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def swipe_up(self, wait: bool = False) -&gt; None:\n    \"\"\"Swipe the screen up.\"\"\"\n    self.input(swipe=messages.DebugSwipeDirection.UP, wait=wait)\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.take_t1_screenshot_if_relevant","title":"<code>take_t1_screenshot_if_relevant()</code>","text":"<p>Conditionally take screenshots on T1.</p> <p>TT handles them differently, see debuglink.start_recording.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def take_t1_screenshot_if_relevant(self) -&gt; None:\n    \"\"\"Conditionally take screenshots on T1.\n\n    TT handles them differently, see debuglink.start_recording.\n    \"\"\"\n    if self.model == \"1\" and self.t1_take_screenshots:\n        self.save_screenshot_for_t1()\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.wait_layout","title":"<code>wait_layout()</code>","text":"<p>Get the content of the Trezor screen as soon as it changes.</p> <p>Returns:</p> Type Description <code>LayoutContent</code> <p>LayoutContent</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def wait_layout(self) -&gt; LayoutContent:\n    \"\"\"Get the content of the Trezor screen as soon as it changes.\n\n    Returns:\n        LayoutContent\n    \"\"\"\n    obj = self._call(messages.DebugLinkGetState(wait_layout=True))\n    if isinstance(obj, messages.Failure):\n        raise TrezorFailure(obj)\n    return LayoutContent(obj.layout_lines)\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugLink.watch_layout","title":"<code>watch_layout(watch)</code>","text":"<p>Enable or disable watching layouts. If disabled, wait_layout will not work.</p> <p>The message is missing on T1. Use <code>TrezorClientDebugLink.watch_layout</code> for cross-version compatibility.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def watch_layout(self, watch: bool) -&gt; None:\n    \"\"\"Enable or disable watching layouts.\n    If disabled, wait_layout will not work.\n\n    The message is missing on T1. Use `TrezorClientDebugLink.watch_layout` for\n    cross-version compatibility.\n    \"\"\"\n    self._call(messages.DebugLinkWatchLayout(watch=watch))\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugUI","title":"<code>DebugUI</code>","text":"<p>UI to be used together with DebugLink.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>class DebugUI:\n    \"\"\"UI to be used together with DebugLink.\"\"\"\n\n    INPUT_FLOW_DONE = object()\n\n    def __init__(self, debuglink: DebugLink) -&gt; None:\n        self.debuglink = debuglink\n        self.clear()\n\n    def clear(self) -&gt; None:\n        \"\"\"Put all internal variables to empty state.\"\"\"\n        self.pins: Optional[Iterator[str]] = None\n        self.passphrase = \"\"\n        self.input_flow: Union[\n            Generator[None, messages.ButtonRequest, None], object, None\n        ] = None\n\n    def button_request(self, br: messages.ButtonRequest) -&gt; None:\n        \"\"\"Handle button request.\"\"\"\n        self.debuglink.take_t1_screenshot_if_relevant()\n\n        if self.input_flow is None:\n            if br.code == messages.ButtonRequestType.PinEntry:\n                self.debuglink.input(self.get_pin())\n            else:\n                if br.pages is not None:\n                    for _ in range(br.pages - 1):\n                        self.debuglink.swipe_up(wait=True)\n                self.debuglink.press_yes()\n        elif self.input_flow is self.INPUT_FLOW_DONE:\n            raise AssertionError(\"input flow ended prematurely\")\n        else:\n            try:\n                assert isinstance(self.input_flow, Generator)\n                self.input_flow.send(br)\n            except StopIteration:\n                self.input_flow = self.INPUT_FLOW_DONE\n\n    def get_pin(self, code: Optional[\"PinMatrixRequestType\"] = None) -&gt; str:\n        \"\"\"Handle the PIN request.\"\"\"\n        self.debuglink.take_t1_screenshot_if_relevant()\n\n        if self.pins is None:\n            raise RuntimeError(\"PIN requested but no sequence was configured\")\n\n        try:\n            return self.debuglink.encode_pin(next(self.pins))\n        except StopIteration:\n            raise AssertionError(\"PIN sequence ended prematurely\")\n\n    def get_passphrase(self, available_on_device: bool) -&gt; str:\n        \"\"\"Handle the passphrase request.\"\"\"\n        self.debuglink.take_t1_screenshot_if_relevant()\n        return self.passphrase\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugUI.button_request","title":"<code>button_request(br)</code>","text":"<p>Handle button request.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def button_request(self, br: messages.ButtonRequest) -&gt; None:\n    \"\"\"Handle button request.\"\"\"\n    self.debuglink.take_t1_screenshot_if_relevant()\n\n    if self.input_flow is None:\n        if br.code == messages.ButtonRequestType.PinEntry:\n            self.debuglink.input(self.get_pin())\n        else:\n            if br.pages is not None:\n                for _ in range(br.pages - 1):\n                    self.debuglink.swipe_up(wait=True)\n            self.debuglink.press_yes()\n    elif self.input_flow is self.INPUT_FLOW_DONE:\n        raise AssertionError(\"input flow ended prematurely\")\n    else:\n        try:\n            assert isinstance(self.input_flow, Generator)\n            self.input_flow.send(br)\n        except StopIteration:\n            self.input_flow = self.INPUT_FLOW_DONE\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugUI.clear","title":"<code>clear()</code>","text":"<p>Put all internal variables to empty state.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Put all internal variables to empty state.\"\"\"\n    self.pins: Optional[Iterator[str]] = None\n    self.passphrase = \"\"\n    self.input_flow: Union[\n        Generator[None, messages.ButtonRequest, None], object, None\n    ] = None\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugUI.get_passphrase","title":"<code>get_passphrase(available_on_device)</code>","text":"<p>Handle the passphrase request.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def get_passphrase(self, available_on_device: bool) -&gt; str:\n    \"\"\"Handle the passphrase request.\"\"\"\n    self.debuglink.take_t1_screenshot_if_relevant()\n    return self.passphrase\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.DebugUI.get_pin","title":"<code>get_pin(code=None)</code>","text":"<p>Handle the PIN request.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def get_pin(self, code: Optional[\"PinMatrixRequestType\"] = None) -&gt; str:\n    \"\"\"Handle the PIN request.\"\"\"\n    self.debuglink.take_t1_screenshot_if_relevant()\n\n    if self.pins is None:\n        raise RuntimeError(\"PIN requested but no sequence was configured\")\n\n    try:\n        return self.debuglink.encode_pin(next(self.pins))\n    except StopIteration:\n        raise AssertionError(\"PIN sequence ended prematurely\")\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.LayoutContent","title":"<code>LayoutContent</code>","text":"<p>Stores content of a layout as returned from Trezor.</p> <p>Contains helper functions to extract specific parts of the layout.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>class LayoutContent:\n    \"\"\"Stores content of a layout as returned from Trezor.\n\n    Contains helper functions to extract specific parts of the layout.\n    \"\"\"\n\n    def __init__(self, lines: Sequence[str]) -&gt; None:\n        self.lines = list(lines)\n        self.text = \" \".join(self.lines)\n\n    def get_title(self) -&gt; str:\n        \"\"\"Get title of the layout.\n\n        Returns:\n            Title of the layout or empty string if no title is present.\n\n        Title is located between \"title\" and \"content\" identifiers.\n        Example: \"&lt; Frame title :  RECOVERY SHARE #1 content :  &lt; SwipePage\"\n          -&gt; \"RECOVERY SHARE #1\"\n        \"\"\"\n        match = re.search(r\"title : (.*?) content :\", self.text)\n        if not match:\n            return \"\"\n        return match.group(1).strip()\n\n    def get_content(self, tag_name: str = \"Paragraphs\", raw: bool = False) -&gt; str:\n        \"\"\"Get text of the main screen content of the layout.\n\n        Args:\n            tag_name: Name of the tag that contains the content.\n            raw: If True, return the raw content without any processing.\n\n        Returns:\n            Content of the layout as a single string.\n        \"\"\"\n        content = \"\".join(self._get_content_lines(tag_name, raw))\n        if not raw and content.endswith(\" \"):\n            # Stripping possible space at the end\n            content = content[:-1]\n        return content\n\n    def get_button_texts(self) -&gt; List[str]:\n        \"\"\"Get text of all buttons in the layout.\n\n        Returns:\n            List of button texts.\n\n        Example button: \"&lt; Button text :  LADYBUG &gt;\"\n          -&gt; [\"LADYBUG\"]\n        \"\"\"\n        return re.findall(r\"&lt; Button text : +(.*?) &gt;\", self.text)\n\n    def get_seed_words(self) -&gt; List[str]:\n        \"\"\"Get all the seed words on the screen in order.\n\n        Returns:\n            List of seed words.\n\n        Example content: \"1. ladybug 2. acid 3. academic 4. afraid\"\n          -&gt; [\"ladybug\", \"acid\", \"academic\", \"afraid\"]\n        \"\"\"\n        return re.findall(r\"\\d+\\. (\\w+)\\b\", self.get_content())\n\n    def get_page_count(self) -&gt; int:\n        \"\"\"Get number of pages for the layout.\"\"\"\n        return self._get_number(\"page_count\")\n\n    def get_active_page(self) -&gt; int:\n        \"\"\"Get current page index of the layout.\"\"\"\n        return self._get_number(\"active_page\")\n\n    def _get_number(self, key: str) -&gt; int:\n        \"\"\"Get number connected with a specific key.\"\"\"\n        match = re.search(rf\"{key} : +(\\d+)\", self.text)\n        if not match:\n            return 0\n        return int(match.group(1))\n\n    def _get_content_lines(\n        self, tag_name: str = \"Paragraphs\", raw: bool = False\n    ) -&gt; List[str]:\n        \"\"\"Get lines of the main screen content of the layout.\"\"\"\n\n        # First line should have content after the tag, last line does not store content\n        tag = f\"&lt; {tag_name}\"\n        if tag in self.lines[0]:\n            first_line = self.lines[0].split(tag)[1]\n            all_lines = [first_line] + self.lines[1:-1]\n        else:\n            all_lines = self.lines[1:-1]\n\n        if raw:\n            return all_lines\n        else:\n            return [_clean_line(line) for line in all_lines]\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.LayoutContent.get_active_page","title":"<code>get_active_page()</code>","text":"<p>Get current page index of the layout.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def get_active_page(self) -&gt; int:\n    \"\"\"Get current page index of the layout.\"\"\"\n    return self._get_number(\"active_page\")\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.LayoutContent.get_button_texts","title":"<code>get_button_texts()</code>","text":"<p>Get text of all buttons in the layout.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of button texts.</p> \"&lt; Button text :  LADYBUG &gt;\" <p>-&gt; [\"LADYBUG\"]</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def get_button_texts(self) -&gt; List[str]:\n    \"\"\"Get text of all buttons in the layout.\n\n    Returns:\n        List of button texts.\n\n    Example button: \"&lt; Button text :  LADYBUG &gt;\"\n      -&gt; [\"LADYBUG\"]\n    \"\"\"\n    return re.findall(r\"&lt; Button text : +(.*?) &gt;\", self.text)\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.LayoutContent.get_content","title":"<code>get_content(tag_name='Paragraphs', raw=False)</code>","text":"<p>Get text of the main screen content of the layout.</p> <p>Parameters:</p> Name Type Description Default <code>tag_name</code> <code>str</code> <p>Name of the tag that contains the content.</p> <code>'Paragraphs'</code> <code>raw</code> <code>bool</code> <p>If True, return the raw content without any processing.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Content of the layout as a single string.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def get_content(self, tag_name: str = \"Paragraphs\", raw: bool = False) -&gt; str:\n    \"\"\"Get text of the main screen content of the layout.\n\n    Args:\n        tag_name: Name of the tag that contains the content.\n        raw: If True, return the raw content without any processing.\n\n    Returns:\n        Content of the layout as a single string.\n    \"\"\"\n    content = \"\".join(self._get_content_lines(tag_name, raw))\n    if not raw and content.endswith(\" \"):\n        # Stripping possible space at the end\n        content = content[:-1]\n    return content\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.LayoutContent.get_page_count","title":"<code>get_page_count()</code>","text":"<p>Get number of pages for the layout.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def get_page_count(self) -&gt; int:\n    \"\"\"Get number of pages for the layout.\"\"\"\n    return self._get_number(\"page_count\")\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.LayoutContent.get_seed_words","title":"<code>get_seed_words()</code>","text":"<p>Get all the seed words on the screen in order.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of seed words.</p> \"1. ladybug 2. acid 3. academic 4. afraid\" <p>-&gt; [\"ladybug\", \"acid\", \"academic\", \"afraid\"]</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def get_seed_words(self) -&gt; List[str]:\n    \"\"\"Get all the seed words on the screen in order.\n\n    Returns:\n        List of seed words.\n\n    Example content: \"1. ladybug 2. acid 3. academic 4. afraid\"\n      -&gt; [\"ladybug\", \"acid\", \"academic\", \"afraid\"]\n    \"\"\"\n    return re.findall(r\"\\d+\\. (\\w+)\\b\", self.get_content())\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.LayoutContent.get_title","title":"<code>get_title()</code>","text":"<p>Get title of the layout.</p> <p>Returns:</p> Type Description <code>str</code> <p>Title of the layout or empty string if no title is present.</p> <p>Title is located between \"title\" and \"content\" identifiers. Example: \"&lt; Frame title :  RECOVERY SHARE #1 content :  &lt; SwipePage\"   -&gt; \"RECOVERY SHARE #1\"</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def get_title(self) -&gt; str:\n    \"\"\"Get title of the layout.\n\n    Returns:\n        Title of the layout or empty string if no title is present.\n\n    Title is located between \"title\" and \"content\" identifiers.\n    Example: \"&lt; Frame title :  RECOVERY SHARE #1 content :  &lt; SwipePage\"\n      -&gt; \"RECOVERY SHARE #1\"\n    \"\"\"\n    match = re.search(r\"title : (.*?) content :\", self.text)\n    if not match:\n        return \"\"\n    return match.group(1).strip()\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.NullDebugLink","title":"<code>NullDebugLink</code>","text":"<p>               Bases: <code>DebugLink</code></p> <p>No-op debuglink.</p> <p>Used as a default Debuglink implementation in case the Trezor device does not support debuglink.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>class NullDebugLink(DebugLink):\n    \"\"\"No-op debuglink.\n\n    Used as a default Debuglink implementation in case the Trezor device\n    does not support debuglink.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        # Ignoring type error as self.transport will not be touched while using NullDebugLink\n        super().__init__(None)  # type: ignore [Argument of type \"None\" cannot be assigned to parameter \"transport\"]\n\n    def open(self) -&gt; None:\n        pass\n\n    def close(self) -&gt; None:\n        pass\n\n    def _call(\n        self, msg: protobuf.MessageType, nowait: bool = False\n    ) -&gt; Optional[messages.DebugLinkState]:\n        if not nowait:\n            if isinstance(msg, messages.DebugLinkGetState):\n                return messages.DebugLinkState()\n            else:\n                raise RuntimeError(\"unexpected call to a fake debuglink\")\n\n        return None\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.TrezorClientDebugLink","title":"<code>TrezorClientDebugLink</code>","text":"<p>               Bases: <code>TrezorClient</code></p> <p>Implements automatic responses and other functionality for unit tests for various callbacks, created in order to automatically pass unit tests.</p> <p>This class should be used only for purposes of unit testing, because it will fail to work without special DebugLink interface provided by the device.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>class TrezorClientDebugLink(TrezorClient):\n    \"\"\"Implements automatic responses\n    and other functionality for unit tests\n    for various callbacks, created in order\n    to automatically pass unit tests.\n\n    This class should be used only for purposes\n    of unit testing, because it will fail to work\n    without special DebugLink interface provided\n    by the device.\n    \"\"\"\n\n    def __init__(self, transport: \"Transport\", auto_interact: bool = True) -&gt; None:\n        try:\n            debug_transport = transport.find_debug()\n            self.debug = DebugLink(debug_transport, auto_interact)\n            # try to open debuglink, see if it works\n            self.debug.open()\n            self.debug.close()\n        except Exception:\n            if not auto_interact:\n                self.debug = NullDebugLink()\n            else:\n                raise\n\n        self.reset_debug_features()\n\n        super().__init__(transport, ui=self.ui)\n\n        # So that we can choose right screenshotting logic (T1 vs TT)\n        self.debug.model = self.features.model\n\n    def reset_debug_features(self) -&gt; None:\n        \"\"\"Prepare the debugging client for a new testcase.\n\n        Clears all debugging state that might have been modified by a testcase.\n        \"\"\"\n        self.ui: DebugUI = DebugUI(self.debug)\n        self.in_with_statement = False\n        self.expected_responses: Optional[List[MessageFilter]] = None\n        self.actual_responses: Optional[List[protobuf.MessageType]] = None\n        self.filters: Dict[\n            Type[protobuf.MessageType],\n            Callable[[protobuf.MessageType], protobuf.MessageType],\n        ] = {}\n\n    def open(self) -&gt; None:\n        super().open()\n        if self.session_counter == 1:\n            self.debug.open()\n\n    def close(self) -&gt; None:\n        if self.session_counter == 1:\n            self.debug.close()\n        super().close()\n\n    def set_filter(\n        self,\n        message_type: Type[protobuf.MessageType],\n        callback: Callable[[protobuf.MessageType], protobuf.MessageType],\n    ) -&gt; None:\n        \"\"\"Configure a filter function for a specified message type.\n\n        The `callback` must be a function that accepts a protobuf message, and returns\n        a (possibly modified) protobuf message of the same type. Whenever a message\n        is sent or received that matches `message_type`, `callback` is invoked on the\n        message and its result is substituted for the original.\n\n        Useful for test scenarios with an active malicious actor on the wire.\n        \"\"\"\n        if not self.in_with_statement:\n            raise RuntimeError(\"Must be called inside 'with' statement\")\n\n        self.filters[message_type] = callback\n\n    def _filter_message(self, msg: protobuf.MessageType) -&gt; protobuf.MessageType:\n        message_type = msg.__class__\n        callback = self.filters.get(message_type)\n        if callable(callback):\n            return callback(deepcopy(msg))\n        else:\n            return msg\n\n    def set_input_flow(\n        self, input_flow: Generator[None, Optional[messages.ButtonRequest], None]\n    ) -&gt; None:\n        \"\"\"Configure a sequence of input events for the current with-block.\n\n        The `input_flow` must be a generator function. A `yield` statement in the\n        input flow function waits for a ButtonRequest from the device, and returns\n        its code.\n\n        # Examples:\n        ```python\n        def input_flow():\n            # wait for first button prompt\n            code = yield\n            assert code == ButtonRequestType.Other\n            # press No\n            client.debug.press_no()\n\n            # wait for second button prompt\n            yield\n            # press Yes\n            client.debug.press_yes()\n\n        with client:\n            client.set_input_flow(input_flow)\n            some_call(client)\n        ```\n        \"\"\"\n        if not self.in_with_statement:\n            raise RuntimeError(\"Must be called inside 'with' statement\")\n\n        if callable(input_flow):\n            input_flow = input_flow()\n        if not hasattr(input_flow, \"send\"):\n            raise RuntimeError(\"input_flow should be a generator function\")\n        self.ui.input_flow = input_flow\n        input_flow.send(None)  # start the generator\n\n    def watch_layout(self, watch: bool = True) -&gt; None:\n        \"\"\"Enable or disable watching layout changes.\n\n        Since trezor-core v2.3.2, it is necessary to call `watch_layout()` before\n        using `debug.wait_layout()`, otherwise layout changes are not reported.\n        \"\"\"\n        if self.version &gt;= (2, 3, 2):\n            # version check is necessary because otherwise we cannot reliably detect\n            # whether and where to wait for reply:\n            # - T1 reports unknown debuglink messages on the wirelink\n            # - TT &lt; 2.3.0 does not reply to unknown debuglink messages due to a bug\n            self.debug.watch_layout(watch)\n\n    def __enter__(self) -&gt; \"TrezorClientDebugLink\":\n        # For usage in with/expected_responses\n        if self.in_with_statement:\n            raise RuntimeError(\"Do not nest!\")\n        self.in_with_statement = True\n        return self\n\n    def __exit__(self, exc_type: Any, value: Any, traceback: Any) -&gt; None:\n        __tracebackhide__ = True  # for pytest # pylint: disable=W0612\n\n        self.watch_layout(False)\n        # copy expected/actual responses before clearing them\n        expected_responses = self.expected_responses\n        actual_responses = self.actual_responses\n        self.reset_debug_features()\n\n        if exc_type is None:\n            # If no other exception was raised, evaluate missed responses\n            # (raises AssertionError on mismatch)\n            self._verify_responses(expected_responses, actual_responses)\n\n    def set_expected_responses(\n        self, expected: List[Union[\"ExpectedMessage\", Tuple[bool, \"ExpectedMessage\"]]]\n    ) -&gt; None:\n        \"\"\"Set a sequence of expected responses to client calls.\n\n        Within a given with-block, the list of received responses from device must\n        match the list of expected responses, otherwise an AssertionError is raised.\n\n        If an expected response is given a field value other than None, that field value\n        must exactly match the received field value. If a given field is None\n        (or unspecified) in the expected response, the received field value is not\n        checked.\n\n        Each expected response can also be a tuple (bool, message). In that case, the\n        expected response is only evaluated if the first field is True.\n        This is useful for differentiating sequences between Trezor models.\n\n        # Examples:\n        ```python\n        trezor_one = client.features.model == \"1\"\n        client.set_expected_responses([\n            messages.ButtonRequest(code=ConfirmOutput),\n            (trezor_one, messages.ButtonRequest(code=ConfirmOutput)),\n            messages.Success(),\n        ])\n        ```\n        \"\"\"\n        if not self.in_with_statement:\n            raise RuntimeError(\"Must be called inside 'with' statement\")\n\n        # make sure all items are (bool, message) tuples\n        expected_with_validity = (\n            e if isinstance(e, tuple) else (True, e) for e in expected\n        )\n\n        # only apply those items that are (True, message)\n        self.expected_responses = [\n            MessageFilter.from_message_or_type(expected)\n            for valid, expected in expected_with_validity\n            if valid\n        ]\n        self.actual_responses = []\n\n    def use_pin_sequence(self, pins: Iterable[str]) -&gt; None:\n        \"\"\"Respond to PIN prompts from device with the provided PINs.\n        The sequence must be at least as long as the expected number of PIN prompts.\n        \"\"\"\n        self.ui.pins = iter(pins)\n\n    def use_passphrase(self, passphrase: str) -&gt; None:\n        \"\"\"Respond to passphrase prompts from device with the provided passphrase.\"\"\"\n        self.ui.passphrase = Mnemonic.normalize_string(passphrase)\n\n    def use_mnemonic(self, mnemonic: str) -&gt; None:\n        \"\"\"Use the provided mnemonic to respond to device.\n        Only applies to T1, where device prompts the host for mnemonic words.\"\"\"\n        self.mnemonic = Mnemonic.normalize_string(mnemonic).split(\" \")\n\n    def _raw_read(self) -&gt; protobuf.MessageType:\n        __tracebackhide__ = True  # for pytest # pylint: disable=W0612\n\n        resp = super()._raw_read()\n        resp = self._filter_message(resp)\n        if self.actual_responses is not None:\n            self.actual_responses.append(resp)\n        return resp\n\n    def _raw_write(self, msg: protobuf.MessageType) -&gt; None:\n        return super()._raw_write(self._filter_message(msg))\n\n    @staticmethod\n    def _expectation_lines(expected: List[MessageFilter], current: int) -&gt; List[str]:\n        start_at = max(current - EXPECTED_RESPONSES_CONTEXT_LINES, 0)\n        stop_at = min(current + EXPECTED_RESPONSES_CONTEXT_LINES + 1, len(expected))\n        output: List[str] = []\n        output.append(\"Expected responses:\")\n        if start_at &gt; 0:\n            output.append(f\"    (...{start_at} previous responses omitted)\")\n        for i in range(start_at, stop_at):\n            exp = expected[i]\n            prefix = \"    \" if i != current else \"&gt;&gt;&gt; \"\n            output.append(textwrap.indent(exp.to_string(), prefix))\n        if stop_at &lt; len(expected):\n            omitted = len(expected) - stop_at\n            output.append(f\"    (...{omitted} following responses omitted)\")\n\n        output.append(\"\")\n        return output\n\n    @classmethod\n    def _verify_responses(\n        cls,\n        expected: Optional[List[MessageFilter]],\n        actual: Optional[List[protobuf.MessageType]],\n    ) -&gt; None:\n        __tracebackhide__ = True  # for pytest # pylint: disable=W0612\n\n        if expected is None and actual is None:\n            return\n\n        assert expected is not None\n        assert actual is not None\n\n        for i, (exp, act) in enumerate(zip_longest(expected, actual)):\n            if exp is None:\n                output = cls._expectation_lines(expected, i)\n                output.append(\"No more messages were expected, but we got:\")\n                for resp in actual[i:]:\n                    output.append(\n                        textwrap.indent(protobuf.format_message(resp), \"    \")\n                    )\n                raise AssertionError(\"\\n\".join(output))\n\n            if act is None:\n                output = cls._expectation_lines(expected, i)\n                output.append(\"This and the following message was not received.\")\n                raise AssertionError(\"\\n\".join(output))\n\n            if not exp.match(act):\n                output = cls._expectation_lines(expected, i)\n                output.append(\"Actually received:\")\n                output.append(textwrap.indent(protobuf.format_message(act), \"    \"))\n                raise AssertionError(\"\\n\".join(output))\n\n    def mnemonic_callback(self, _) -&gt; str:\n        word, pos = self.debug.read_recovery_word()\n        if word:\n            return word\n        if pos:\n            return self.mnemonic[pos - 1]\n\n        raise RuntimeError(\"Unexpected call\")\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.TrezorClientDebugLink.reset_debug_features","title":"<code>reset_debug_features()</code>","text":"<p>Prepare the debugging client for a new testcase.</p> <p>Clears all debugging state that might have been modified by a testcase.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def reset_debug_features(self) -&gt; None:\n    \"\"\"Prepare the debugging client for a new testcase.\n\n    Clears all debugging state that might have been modified by a testcase.\n    \"\"\"\n    self.ui: DebugUI = DebugUI(self.debug)\n    self.in_with_statement = False\n    self.expected_responses: Optional[List[MessageFilter]] = None\n    self.actual_responses: Optional[List[protobuf.MessageType]] = None\n    self.filters: Dict[\n        Type[protobuf.MessageType],\n        Callable[[protobuf.MessageType], protobuf.MessageType],\n    ] = {}\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.TrezorClientDebugLink.set_expected_responses","title":"<code>set_expected_responses(expected)</code>","text":"<p>Set a sequence of expected responses to client calls.</p> <p>Within a given with-block, the list of received responses from device must match the list of expected responses, otherwise an AssertionError is raised.</p> <p>If an expected response is given a field value other than None, that field value must exactly match the received field value. If a given field is None (or unspecified) in the expected response, the received field value is not checked.</p> <p>Each expected response can also be a tuple (bool, message). In that case, the expected response is only evaluated if the first field is True. This is useful for differentiating sequences between Trezor models.</p>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.TrezorClientDebugLink.set_expected_responses--examples","title":"Examples:","text":"<pre><code>trezor_one = client.features.model == \"1\"\nclient.set_expected_responses([\n    messages.ButtonRequest(code=ConfirmOutput),\n    (trezor_one, messages.ButtonRequest(code=ConfirmOutput)),\n    messages.Success(),\n])\n</code></pre> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def set_expected_responses(\n    self, expected: List[Union[\"ExpectedMessage\", Tuple[bool, \"ExpectedMessage\"]]]\n) -&gt; None:\n    \"\"\"Set a sequence of expected responses to client calls.\n\n    Within a given with-block, the list of received responses from device must\n    match the list of expected responses, otherwise an AssertionError is raised.\n\n    If an expected response is given a field value other than None, that field value\n    must exactly match the received field value. If a given field is None\n    (or unspecified) in the expected response, the received field value is not\n    checked.\n\n    Each expected response can also be a tuple (bool, message). In that case, the\n    expected response is only evaluated if the first field is True.\n    This is useful for differentiating sequences between Trezor models.\n\n    # Examples:\n    ```python\n    trezor_one = client.features.model == \"1\"\n    client.set_expected_responses([\n        messages.ButtonRequest(code=ConfirmOutput),\n        (trezor_one, messages.ButtonRequest(code=ConfirmOutput)),\n        messages.Success(),\n    ])\n    ```\n    \"\"\"\n    if not self.in_with_statement:\n        raise RuntimeError(\"Must be called inside 'with' statement\")\n\n    # make sure all items are (bool, message) tuples\n    expected_with_validity = (\n        e if isinstance(e, tuple) else (True, e) for e in expected\n    )\n\n    # only apply those items that are (True, message)\n    self.expected_responses = [\n        MessageFilter.from_message_or_type(expected)\n        for valid, expected in expected_with_validity\n        if valid\n    ]\n    self.actual_responses = []\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.TrezorClientDebugLink.set_filter","title":"<code>set_filter(message_type, callback)</code>","text":"<p>Configure a filter function for a specified message type.</p> <p>The <code>callback</code> must be a function that accepts a protobuf message, and returns a (possibly modified) protobuf message of the same type. Whenever a message is sent or received that matches <code>message_type</code>, <code>callback</code> is invoked on the message and its result is substituted for the original.</p> <p>Useful for test scenarios with an active malicious actor on the wire.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def set_filter(\n    self,\n    message_type: Type[protobuf.MessageType],\n    callback: Callable[[protobuf.MessageType], protobuf.MessageType],\n) -&gt; None:\n    \"\"\"Configure a filter function for a specified message type.\n\n    The `callback` must be a function that accepts a protobuf message, and returns\n    a (possibly modified) protobuf message of the same type. Whenever a message\n    is sent or received that matches `message_type`, `callback` is invoked on the\n    message and its result is substituted for the original.\n\n    Useful for test scenarios with an active malicious actor on the wire.\n    \"\"\"\n    if not self.in_with_statement:\n        raise RuntimeError(\"Must be called inside 'with' statement\")\n\n    self.filters[message_type] = callback\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.TrezorClientDebugLink.set_input_flow","title":"<code>set_input_flow(input_flow)</code>","text":"<p>Configure a sequence of input events for the current with-block.</p> <p>The <code>input_flow</code> must be a generator function. A <code>yield</code> statement in the input flow function waits for a ButtonRequest from the device, and returns its code.</p>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.TrezorClientDebugLink.set_input_flow--examples","title":"Examples:","text":"<pre><code>def input_flow():\n    # wait for first button prompt\n    code = yield\n    assert code == ButtonRequestType.Other\n    # press No\n    client.debug.press_no()\n\n    # wait for second button prompt\n    yield\n    # press Yes\n    client.debug.press_yes()\n\nwith client:\n    client.set_input_flow(input_flow)\n    some_call(client)\n</code></pre> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def set_input_flow(\n    self, input_flow: Generator[None, Optional[messages.ButtonRequest], None]\n) -&gt; None:\n    \"\"\"Configure a sequence of input events for the current with-block.\n\n    The `input_flow` must be a generator function. A `yield` statement in the\n    input flow function waits for a ButtonRequest from the device, and returns\n    its code.\n\n    # Examples:\n    ```python\n    def input_flow():\n        # wait for first button prompt\n        code = yield\n        assert code == ButtonRequestType.Other\n        # press No\n        client.debug.press_no()\n\n        # wait for second button prompt\n        yield\n        # press Yes\n        client.debug.press_yes()\n\n    with client:\n        client.set_input_flow(input_flow)\n        some_call(client)\n    ```\n    \"\"\"\n    if not self.in_with_statement:\n        raise RuntimeError(\"Must be called inside 'with' statement\")\n\n    if callable(input_flow):\n        input_flow = input_flow()\n    if not hasattr(input_flow, \"send\"):\n        raise RuntimeError(\"input_flow should be a generator function\")\n    self.ui.input_flow = input_flow\n    input_flow.send(None)  # start the generator\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.TrezorClientDebugLink.use_mnemonic","title":"<code>use_mnemonic(mnemonic)</code>","text":"<p>Use the provided mnemonic to respond to device. Only applies to T1, where device prompts the host for mnemonic words.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def use_mnemonic(self, mnemonic: str) -&gt; None:\n    \"\"\"Use the provided mnemonic to respond to device.\n    Only applies to T1, where device prompts the host for mnemonic words.\"\"\"\n    self.mnemonic = Mnemonic.normalize_string(mnemonic).split(\" \")\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.TrezorClientDebugLink.use_passphrase","title":"<code>use_passphrase(passphrase)</code>","text":"<p>Respond to passphrase prompts from device with the provided passphrase.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def use_passphrase(self, passphrase: str) -&gt; None:\n    \"\"\"Respond to passphrase prompts from device with the provided passphrase.\"\"\"\n    self.ui.passphrase = Mnemonic.normalize_string(passphrase)\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.TrezorClientDebugLink.use_pin_sequence","title":"<code>use_pin_sequence(pins)</code>","text":"<p>Respond to PIN prompts from device with the provided PINs. The sequence must be at least as long as the expected number of PIN prompts.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def use_pin_sequence(self, pins: Iterable[str]) -&gt; None:\n    \"\"\"Respond to PIN prompts from device with the provided PINs.\n    The sequence must be at least as long as the expected number of PIN prompts.\n    \"\"\"\n    self.ui.pins = iter(pins)\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.TrezorClientDebugLink.watch_layout","title":"<code>watch_layout(watch=True)</code>","text":"<p>Enable or disable watching layout changes.</p> <p>Since trezor-core v2.3.2, it is necessary to call <code>watch_layout()</code> before using <code>debug.wait_layout()</code>, otherwise layout changes are not reported.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def watch_layout(self, watch: bool = True) -&gt; None:\n    \"\"\"Enable or disable watching layout changes.\n\n    Since trezor-core v2.3.2, it is necessary to call `watch_layout()` before\n    using `debug.wait_layout()`, otherwise layout changes are not reported.\n    \"\"\"\n    if self.version &gt;= (2, 3, 2):\n        # version check is necessary because otherwise we cannot reliably detect\n        # whether and where to wait for reply:\n        # - T1 reports unknown debuglink messages on the wirelink\n        # - TT &lt; 2.3.0 does not reply to unknown debuglink messages due to a bug\n        self.debug.watch_layout(watch)\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.load_device","title":"<code>load_device(client, mnemonic, pin, passphrase_protection, label, language='en-US', skip_checksum=False, needs_backup=False, no_backup=False)</code>","text":"<p>Load device with the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <code>mnemonic</code> <code>Union[str, Iterable[str]]</code> <p>mnemonic words to load</p> required <code>pin</code> <code>Optional[str]</code> <p>PIN to set</p> required <code>passphrase_protection</code> <code>bool</code> <p>enable passphrase protection</p> required <code>label</code> <code>Optional[str]</code> <p>device label</p> required <code>language</code> <code>str</code> <p>device language</p> <code>'en-US'</code> <code>skip_checksum</code> <code>bool</code> <p>do not test mnemonic for valid BIP-39 checksum</p> <code>False</code> <code>needs_backup</code> <code>bool</code> <p>set \"needs backup\" flag</p> <code>False</code> <code>no_backup</code> <code>bool</code> <p>indicate that no backup is going to be made</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>MessageType</code> <p>Success message</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>@expect(messages.Success, field=\"message\", ret_type=str)\ndef load_device(\n    client: \"TrezorClient\",\n    mnemonic: Union[str, Iterable[str]],\n    pin: Optional[str],\n    passphrase_protection: bool,\n    label: Optional[str],\n    language: str = \"en-US\",\n    skip_checksum: bool = False,\n    needs_backup: bool = False,\n    no_backup: bool = False,\n) -&gt; protobuf.MessageType:\n    \"\"\"Load device with the given parameters.\n\n    Args:\n        client: TrezorClient instance\n        mnemonic: mnemonic words to load\n        pin: PIN to set\n        passphrase_protection: enable passphrase protection\n        label: device label\n        language: device language\n        skip_checksum: do not test mnemonic for valid BIP-39 checksum\n        needs_backup: set \"needs backup\" flag\n        no_backup: indicate that no backup is going to be made\n\n    Returns:\n        str: Success message\n    \"\"\"\n    if isinstance(mnemonic, str):\n        mnemonic = [mnemonic]\n\n    mnemonics = [Mnemonic.normalize_string(m) for m in mnemonic]\n\n    if client.features.initialized:\n        raise RuntimeError(\n            \"Device is initialized already. Call device.wipe() and try again.\"\n        )\n\n    resp = client.call(\n        messages.LoadDevice(\n            mnemonics=mnemonics,\n            pin=pin,\n            passphrase_protection=passphrase_protection,\n            language=language,\n            label=label,\n            skip_checksum=skip_checksum,\n            needs_backup=needs_backup,\n            no_backup=no_backup,\n        )\n    )\n    client.init_device()\n    return resp\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.multipage_content","title":"<code>multipage_content(layouts)</code>","text":"<p>Get overall content from multiple-page layout.</p> <p>Parameters:</p> Name Type Description Default <code>layouts</code> <code>List[LayoutContent]</code> <p>List of layouts to get the content from.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Combined content of all the layouts as a single string.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def multipage_content(layouts: List[LayoutContent]) -&gt; str:\n    \"\"\"Get overall content from multiple-page layout.\n\n    Args:\n        layouts: List of layouts to get the content from.\n\n    Returns:\n        Combined content of all the layouts as a single string.\n    \"\"\"\n    final_text = \"\"\n    for layout in layouts:\n        final_text += layout.get_content()\n        # When the raw content of the page ends with ellipsis,\n        # we need to add a space to separate it with the next page\n        if layout.get_content(raw=True).endswith(\"... \"):\n            final_text += \" \"\n\n    # Stripping possible space at the end of last page\n    if final_text.endswith(\" \"):\n        final_text = final_text[:-1]\n\n    return final_text\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.record_screen","title":"<code>record_screen(debug_client, directory, report_func=None)</code>","text":"<p>Record screen changes into a specified directory.</p> <p>Parameters:</p> Name Type Description Default <code>debug_client</code> <code>TrezorClientDebugLink</code> <p>DebugLink client.</p> required <code>directory</code> <code>Union[str, None]</code> <p>Directory to store the screenshots in. <code>None</code> if we should stop recording.</p> required <code>report_func</code> <code>Union[Callable[[str], None], None]</code> <p>Optional function to report the progress to.</p> <code>None</code> <p>Passing <code>None</code> as <code>directory</code> stops the recording.</p> <p>Creates subdirectories inside a specified directory, one for each session (for each new call of this function). (So that older screenshots are not overwritten by new ones.)</p> <p>Is available only for emulators, hardware devices are not capable of that.</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>def record_screen(\n    debug_client: \"TrezorClientDebugLink\",\n    directory: Union[str, None],\n    report_func: Union[Callable[[str], None], None] = None,\n) -&gt; None:\n    \"\"\"Record screen changes into a specified directory.\n\n    Args:\n        debug_client: DebugLink client.\n        directory: Directory to store the screenshots in. `None` if we should stop recording.\n        report_func: Optional function to report the progress to.\n\n    Passing `None` as `directory` stops the recording.\n\n    Creates subdirectories inside a specified directory, one for each session\n    (for each new call of this function).\n    (So that older screenshots are not overwritten by new ones.)\n\n    Is available only for emulators, hardware devices are not capable of that.\n    \"\"\"\n\n    def get_session_screenshot_dir(directory: Path) -&gt; Path:\n        \"\"\"Create and return screenshot dir for the current session, according to datetime.\"\"\"\n        session_dir = directory / datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")\n        session_dir.mkdir(parents=True, exist_ok=True)\n        return session_dir\n\n    if not _is_emulator(debug_client):\n        raise RuntimeError(\"Recording is only supported on emulator.\")\n\n    if directory is None:\n        debug_client.debug.stop_recording()\n        if report_func is not None:\n            report_func(\"Recording stopped.\")\n    else:\n        # Transforming the directory into an absolute path,\n        # because emulator demands it\n        abs_directory = Path(directory).resolve()\n        # Creating the dir when it does not exist yet\n        if not abs_directory.exists():\n            abs_directory.mkdir(parents=True, exist_ok=True)\n        # Getting a new screenshot dir for the current session\n        current_session_dir = get_session_screenshot_dir(abs_directory)\n        debug_client.debug.start_recording(str(current_session_dir))\n        if report_func is not None:\n            report_func(f\"Recording started into {current_session_dir}.\")\n</code></pre>"},{"location":"API/debuglink/#python.src.trezorlib.debuglink.self_test","title":"<code>self_test(client)</code>","text":"<p>Perform self-test on the device.</p> <p>Only works on debug firmware of Trezor One.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>MessageType</code> <p>Success message</p> Source code in <code>src/trezorlib/debuglink.py</code> <pre><code>@expect(messages.Success, field=\"message\", ret_type=str)\ndef self_test(client: \"TrezorClient\") -&gt; protobuf.MessageType:\n    \"\"\"Perform self-test on the device.\n\n    Only works on debug firmware of Trezor One.\n\n    Args:\n        client: TrezorClient instance\n\n    Returns:\n        str: Success message\n    \"\"\"\n    if client.features.bootloader_mode is not True:\n        raise RuntimeError(\"Device must be in bootloader mode\")\n\n    return client.call(\n        messages.SelfTest(\n            payload=b\"\\x00\\xFF\\x55\\xAA\\x66\\x99\\x33\\xCCABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\\x00\\xFF\\x55\\xAA\\x66\\x99\\x33\\xCC\"\n        )\n    )\n</code></pre>"},{"location":"API/device/","title":"Device","text":"<pre><code>from trezorlib import device\n</code></pre>"},{"location":"API/device/#python.src.trezorlib.device.apply_flags","title":"<code>apply_flags(client, flags)</code>","text":"<p>Change device flags.</p> <p>Flags/bits can be only set, not unset.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <code>flags</code> <code>int</code> <p>New flags for the device - bitmask</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>MessageType</code> <p>Success message</p> Source code in <code>src/trezorlib/device.py</code> <pre><code>@expect(messages.Success, field=\"message\", ret_type=str)\n@session\ndef apply_flags(client: \"TrezorClient\", flags: int) -&gt; \"MessageType\":\n    \"\"\"Change device flags.\n\n    Flags/bits can be only set, not unset.\n\n    Args:\n        client: TrezorClient instance\n        flags: New flags for the device - bitmask\n\n    Returns:\n        str: Success message\n    \"\"\"\n    out = client.call(messages.ApplyFlags(flags=flags))\n    client.refresh_features()\n    return out\n</code></pre>"},{"location":"API/device/#python.src.trezorlib.device.apply_settings","title":"<code>apply_settings(client, label=None, language=None, use_passphrase=None, homescreen=None, passphrase_always_on_device=None, auto_lock_delay_ms=None, display_rotation=None, safety_checks=None, experimental_features=None)</code>","text":"<p>Change device settings.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <code>label</code> <code>Optional[str]</code> <p>New label for the device</p> <code>None</code> <code>language</code> <code>Optional[str]</code> <p>New language for the device</p> <code>None</code> <code>use_passphrase</code> <code>Optional[bool]</code> <p>Whether to use passphrase</p> <code>None</code> <code>homescreen</code> <code>Optional[bytes]</code> <p>New homescreen for the device</p> <code>None</code> <code>passphrase_always_on_device</code> <code>Optional[bool]</code> <p>Whether to always ask for passphrase on device</p> <code>None</code> <code>auto_lock_delay_ms</code> <code>Optional[int]</code> <p>Delay in milliseconds after which the device with PIN will lock itself</p> <code>None</code> <code>display_rotation</code> <code>Optional[int]</code> <p>Display rotation in degrees from North</p> <code>None</code> <code>safety_checks</code> <code>Optional[SafetyCheckLevel]</code> <p>Safety check level</p> <code>None</code> <code>experimental_features</code> <code>Optional[bool]</code> <p>Whether to enable experimental features</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>MessageType</code> <p>Success message</p> Source code in <code>src/trezorlib/device.py</code> <pre><code>@expect(messages.Success, field=\"message\", ret_type=str)\n@session\ndef apply_settings(\n    client: \"TrezorClient\",\n    label: Optional[str] = None,\n    language: Optional[str] = None,\n    use_passphrase: Optional[bool] = None,\n    homescreen: Optional[bytes] = None,\n    passphrase_always_on_device: Optional[bool] = None,\n    auto_lock_delay_ms: Optional[int] = None,\n    display_rotation: Optional[int] = None,\n    safety_checks: Optional[messages.SafetyCheckLevel] = None,\n    experimental_features: Optional[bool] = None,\n) -&gt; \"MessageType\":\n    \"\"\"Change device settings.\n\n    Args:\n        client: TrezorClient instance\n        label: New label for the device\n        language: New language for the device\n        use_passphrase: Whether to use passphrase\n        homescreen: New homescreen for the device\n        passphrase_always_on_device: Whether to always ask for passphrase on device\n        auto_lock_delay_ms: Delay in milliseconds after which the device with PIN will lock itself\n        display_rotation: Display rotation in degrees from North\n        safety_checks: Safety check level\n        experimental_features: Whether to enable experimental features\n\n    Returns:\n        str: Success message\n    \"\"\"\n    settings = messages.ApplySettings(\n        label=label,\n        language=language,\n        use_passphrase=use_passphrase,\n        homescreen=homescreen,\n        passphrase_always_on_device=passphrase_always_on_device,\n        auto_lock_delay_ms=auto_lock_delay_ms,\n        display_rotation=display_rotation,\n        safety_checks=safety_checks,\n        experimental_features=experimental_features,\n    )\n\n    out = client.call(settings)\n    client.refresh_features()\n    return out\n</code></pre>"},{"location":"API/device/#python.src.trezorlib.device.backup","title":"<code>backup(client)</code>","text":"<p>Back up the mnemonic seed.</p> <p>Must be run on a device that is already set up but is not backed up yet. Backup can be only performed once after device setup -- either as part of the <code>reset</code> workflow, or separately using this function.</p> <p>The backup process is fully interactive on the Trezor device itself and does not interact with the host.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>MessageType</code> <p>Success message</p> Source code in <code>src/trezorlib/device.py</code> <pre><code>@expect(messages.Success, field=\"message\", ret_type=str)\n@session\ndef backup(client: \"TrezorClient\") -&gt; \"MessageType\":\n    \"\"\"Back up the mnemonic seed.\n\n    Must be run on a device that is already set up but is not backed up yet.\n    Backup can be only performed once after device setup -- either as part of the\n    `reset` workflow, or separately using this function.\n\n    The backup process is fully interactive on the Trezor device itself and does not\n    interact with the host.\n\n    Args:\n        client: TrezorClient instance\n\n    Returns:\n        str: Success message\n    \"\"\"\n    ret = client.call(messages.BackupDevice())\n    client.refresh_features()\n    return ret\n</code></pre>"},{"location":"API/device/#python.src.trezorlib.device.cancel_authorization","title":"<code>cancel_authorization(client)</code>","text":"<p>Cancel any outstanding authorization in the current session.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>MessageType</code> <p>Success message</p> Source code in <code>src/trezorlib/device.py</code> <pre><code>@expect(messages.Success, field=\"message\", ret_type=str)\ndef cancel_authorization(client: \"TrezorClient\") -&gt; \"MessageType\":\n    \"\"\"Cancel any outstanding authorization in the current session.\n\n    Args:\n        client: TrezorClient instance\n\n    Returns:\n        str: Success message\n    \"\"\"\n    return client.call(messages.CancelAuthorization())\n</code></pre>"},{"location":"API/device/#python.src.trezorlib.device.change_pin","title":"<code>change_pin(client, remove=False)</code>","text":"<p>Set up, change, or remove PIN on the device.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <code>remove</code> <code>bool</code> <p>Set to True to remove the PIN.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>MessageType</code> <p>Success message</p> Source code in <code>src/trezorlib/device.py</code> <pre><code>@expect(messages.Success, field=\"message\", ret_type=str)\n@session\ndef change_pin(client: \"TrezorClient\", remove: bool = False) -&gt; \"MessageType\":\n    \"\"\"Set up, change, or remove PIN on the device.\n\n    Args:\n        client: TrezorClient instance\n        remove: Set to True to remove the PIN.\n\n    Returns:\n        str: Success message\n    \"\"\"\n    ret = client.call(messages.ChangePin(remove=remove))\n    client.refresh_features()\n    return ret\n</code></pre>"},{"location":"API/device/#python.src.trezorlib.device.change_wipe_code","title":"<code>change_wipe_code(client, remove=False)</code>","text":"<p>Set up, change, or remove wipe code on the device.</p> <p>When entered instead of the unlock PIN, the wipe code, or \"duress PIN\", will cause the device to be erased. Wipe code can only be configured when the unlock PIN is already set up.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <code>remove</code> <code>bool</code> <p>Set to True to remove the wipe code.</p> <code>False</code> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <code>remove</code> <code>bool</code> <p>Whether to remove the wipe-code. False mean setting a new wipe-code.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>MessageType</code> <p>Success message</p> Source code in <code>src/trezorlib/device.py</code> <pre><code>@expect(messages.Success, field=\"message\", ret_type=str)\n@session\ndef change_wipe_code(client: \"TrezorClient\", remove: bool = False) -&gt; \"MessageType\":\n    \"\"\"Set up, change, or remove wipe code on the device.\n\n    When entered instead of the unlock PIN, the wipe code, or \"duress PIN\", will cause the device to be erased.\n    Wipe code can only be configured when the unlock PIN is already set up.\n\n    Args:\n        client: TrezorClient instance\n        remove: Set to True to remove the wipe code.\n\n    Args:\n        client: TrezorClient instance\n        remove: Whether to remove the wipe-code. False mean setting a new wipe-code.\n\n    Returns:\n        str: Success message\n    \"\"\"\n    ret = client.call(messages.ChangeWipeCode(remove=remove))\n    client.refresh_features()\n    return ret\n</code></pre>"},{"location":"API/device/#python.src.trezorlib.device.reboot_to_bootloader","title":"<code>reboot_to_bootloader(client)</code>","text":"<p>Reboot firmware to bootloader mode.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>MessageType</code> <p>Success message</p> Source code in <code>src/trezorlib/device.py</code> <pre><code>@session\n@expect(messages.Success, field=\"message\", ret_type=str)\ndef reboot_to_bootloader(client: \"TrezorClient\") -&gt; \"MessageType\":\n    \"\"\"Reboot firmware to bootloader mode.\n\n    Args:\n        client: TrezorClient instance\n\n    Returns:\n        str: Success message\n    \"\"\"\n    return client.call(messages.RebootToBootloader())\n</code></pre>"},{"location":"API/device/#python.src.trezorlib.device.recover","title":"<code>recover(client, word_count=24, passphrase_protection=False, pin_protection=True, label=None, language='en-US', input_callback=None, type=messages.RecoveryDeviceType.ScrambledWords, dry_run=False, u2f_counter=None)</code>","text":"<p>Restore a wallet from a mnemonic seed.</p> <p>Must be either run on a wiped device, or with the <code>dry_run</code> flag set to True.</p> <p>On Trezor 1, <code>input_callback</code> is required. When <code>recovery_type</code> is <code>ScrambledWords</code>, each call to callback must return a single word from the mnemonic seed. Trezor screen specifies which word to enter.</p> <p>When <code>recovery_type</code> is <code>Matrix</code>, each call to callback must return a single digit corresponding to the position of a letter / word in the matrix on the Trezor screen, or a backspace character.</p> <p>On Trezors with on-screen entry, <code>input_callback</code> is ignored.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <code>word_count</code> <code>int</code> <p>Number of words in mnemonic</p> <code>24</code> <code>passphrase_protection</code> <code>bool</code> <p>Whether to enable passphrase protection</p> <code>False</code> <code>pin_protection</code> <code>bool</code> <p>Whether to enable PIN protection</p> <code>True</code> <code>label</code> <code>Optional[str]</code> <p>Label for the device</p> <code>None</code> <code>language</code> <code>str</code> <p>Language for the device</p> <code>'en-US'</code> <code>input_callback</code> <code>Optional[Callable]</code> <p>Function to be called for each word. It should return the word.</p> <code>None</code> <code>type</code> <code>RecoveryDeviceType</code> <p>Recovery type</p> <code>ScrambledWords</code> <code>dry_run</code> <code>bool</code> <p>Whether to perform a dry run - simulate recovery</p> <code>False</code> <code>u2f_counter</code> <code>Optional[int]</code> <p>U2F counter value</p> <code>None</code> <p>Returns:</p> Type Description <code>MessageType</code> <p>Success message</p> Source code in <code>src/trezorlib/device.py</code> <pre><code>@session\ndef recover(\n    client: \"TrezorClient\",\n    word_count: int = 24,\n    passphrase_protection: bool = False,\n    pin_protection: bool = True,\n    label: Optional[str] = None,\n    language: str = \"en-US\",\n    input_callback: Optional[Callable] = None,\n    type: messages.RecoveryDeviceType = messages.RecoveryDeviceType.ScrambledWords,\n    dry_run: bool = False,\n    u2f_counter: Optional[int] = None,\n) -&gt; \"MessageType\":\n    \"\"\"Restore a wallet from a mnemonic seed.\n\n    Must be either run on a wiped device, or with the `dry_run` flag set to True.\n\n    On Trezor 1, `input_callback` is required. When `recovery_type` is `ScrambledWords`,\n    each call to callback must return a single word from the mnemonic seed. Trezor\n    screen specifies which word to enter.\n\n    When `recovery_type` is `Matrix`, each call to callback must return a single digit\n    corresponding to the position of a letter / word in the matrix on the Trezor screen,\n    or a backspace character.\n\n    On Trezors with on-screen entry, `input_callback` is ignored.\n\n    Args:\n        client: TrezorClient instance\n        word_count: Number of words in mnemonic\n        passphrase_protection: Whether to enable passphrase protection\n        pin_protection: Whether to enable PIN protection\n        label: Label for the device\n        language: Language for the device\n        input_callback: Function to be called for each word. It should return the word.\n        type: Recovery type\n        dry_run: Whether to perform a dry run - simulate recovery\n        u2f_counter: U2F counter value\n\n    Returns:\n        Success message\n    \"\"\"\n    if client.features.model == \"1\" and input_callback is None:\n        raise RuntimeError(\"Input callback required for Trezor One\")\n\n    if word_count not in (12, 18, 24):\n        raise ValueError(\"Invalid word count. Use 12/18/24\")\n\n    if client.features.initialized and not dry_run:\n        raise RuntimeError(\n            \"Device already initialized. Call device.wipe() and try again.\"\n        )\n\n    if u2f_counter is None:\n        u2f_counter = int(time.time())\n\n    msg = messages.RecoveryDevice(\n        word_count=word_count, enforce_wordlist=True, type=type, dry_run=dry_run\n    )\n\n    if not dry_run:\n        # set additional parameters\n        msg.passphrase_protection = passphrase_protection\n        msg.pin_protection = pin_protection\n        msg.label = label\n        msg.language = language\n        msg.u2f_counter = u2f_counter\n\n    res = client.call(msg)\n\n    while isinstance(res, messages.WordRequest):\n        try:\n            assert input_callback is not None\n            inp = input_callback(res.type)\n            res = client.call(messages.WordAck(word=inp))\n        except Cancelled:\n            res = client.call(messages.Cancel())\n\n    client.init_device()\n    return res\n</code></pre>"},{"location":"API/device/#python.src.trezorlib.device.reset","title":"<code>reset(client, display_random=False, strength=None, passphrase_protection=False, pin_protection=True, label=None, language='en-US', u2f_counter=0, skip_backup=False, no_backup=False, backup_type=messages.BackupType.Bip39)</code>","text":"<p>Create a new wallet on the device.</p> <p>Must be run on a wiped device.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <code>display_random</code> <code>bool</code> <p>Display entropy generated by the device</p> <code>False</code> <code>strength</code> <code>Optional[int]</code> <p>Strength of the generated seed in bits</p> <code>None</code> <code>passphrase_protection</code> <code>bool</code> <p>Whether to enable passphrase protection</p> <code>False</code> <code>pin_protection</code> <code>bool</code> <p>Whether to enable PIN protection</p> <code>True</code> <code>label</code> <code>Optional[str]</code> <p>Label for the device</p> <code>None</code> <code>language</code> <code>str</code> <p>Language for the device</p> <code>'en-US'</code> <code>u2f_counter</code> <code>int</code> <p>U2F counter value</p> <code>0</code> <code>skip_backup</code> <code>bool</code> <p>Postpone seed backup to <code>BackupDevice</code> workflow</p> <code>False</code> <code>no_backup</code> <code>bool</code> <p>Indicate that no backup (seedless mode) is going to be made</p> <code>False</code> <code>backup_type</code> <code>BackupType</code> <p>Type of backup to be made (BIP39, Shamir, SuperShamir)</p> <code>Bip39</code> <p>Returns:</p> Name Type Description <code>str</code> <code>MessageType</code> <p>Success message</p> Source code in <code>src/trezorlib/device.py</code> <pre><code>@expect(messages.Success, field=\"message\", ret_type=str)\n@session\ndef reset(\n    client: \"TrezorClient\",\n    display_random: bool = False,\n    strength: Optional[int] = None,\n    passphrase_protection: bool = False,\n    pin_protection: bool = True,\n    label: Optional[str] = None,\n    language: str = \"en-US\",\n    u2f_counter: int = 0,\n    skip_backup: bool = False,\n    no_backup: bool = False,\n    backup_type: messages.BackupType = messages.BackupType.Bip39,\n) -&gt; \"MessageType\":\n    \"\"\"Create a new wallet on the device.\n\n    Must be run on a wiped device.\n\n    Args:\n        client: TrezorClient instance\n        display_random: Display entropy generated by the device\n        strength: Strength of the generated seed in bits\n        passphrase_protection: Whether to enable passphrase protection\n        pin_protection: Whether to enable PIN protection\n        label: Label for the device\n        language: Language for the device\n        u2f_counter: U2F counter value\n        skip_backup: Postpone seed backup to `BackupDevice` workflow\n        no_backup: Indicate that no backup (seedless mode) is going to be made\n        backup_type: Type of backup to be made (BIP39, Shamir, SuperShamir)\n\n    Returns:\n        str: Success message\n    \"\"\"\n    if client.features.initialized:\n        raise RuntimeError(\n            \"Device is initialized already. Call wipe_device() and try again.\"\n        )\n\n    if strength is None:\n        if client.features.model == \"1\":\n            strength = 256\n        else:\n            strength = 128\n\n    # Begin with device reset workflow\n    msg = messages.ResetDevice(\n        display_random=bool(display_random),\n        strength=strength,\n        passphrase_protection=bool(passphrase_protection),\n        pin_protection=bool(pin_protection),\n        language=language,\n        label=label,\n        u2f_counter=u2f_counter,\n        skip_backup=bool(skip_backup),\n        no_backup=bool(no_backup),\n        backup_type=backup_type,\n    )\n\n    resp = client.call(msg)\n    if not isinstance(resp, messages.EntropyRequest):\n        raise RuntimeError(\"Invalid response, expected EntropyRequest\")\n\n    external_entropy = os.urandom(32)\n    # LOG.debug(\"Computer generated entropy: \" + external_entropy.hex())\n    ret = client.call(messages.EntropyAck(entropy=external_entropy))\n    client.init_device()\n    return ret\n</code></pre>"},{"location":"API/device/#python.src.trezorlib.device.sd_protect","title":"<code>sd_protect(client, operation)</code>","text":"<p>Update SD card protection.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <code>operation</code> <code>SdProtectOperationType</code> <p>Operation to perform</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>MessageType</code> <p>Success message</p> Source code in <code>src/trezorlib/device.py</code> <pre><code>@expect(messages.Success, field=\"message\", ret_type=str)\n@session\ndef sd_protect(\n    client: \"TrezorClient\", operation: messages.SdProtectOperationType\n) -&gt; \"MessageType\":\n    \"\"\"Update SD card protection.\n\n    Args:\n        client: TrezorClient instance\n        operation: Operation to perform\n\n    Returns:\n        str: Success message\n    \"\"\"\n    ret = client.call(messages.SdProtect(operation=operation))\n    client.refresh_features()\n    return ret\n</code></pre>"},{"location":"API/device/#python.src.trezorlib.device.set_busy","title":"<code>set_busy(client, expiry_ms)</code>","text":"<p>Sets or clears the busy state of the device.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <code>expiry_ms</code> <code>Optional[int]</code> <p>Expiry time in milliseconds. If None, clears the busy state.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>MessageType</code> <p>Success message</p> <p>In the busy state the device shows a \"Do not disconnect\" message instead of the homescreen. Setting <code>expiry_ms=None</code> clears the busy state.</p> Source code in <code>src/trezorlib/device.py</code> <pre><code>@expect(messages.Success, field=\"message\", ret_type=str)\n@session\ndef set_busy(client: \"TrezorClient\", expiry_ms: Optional[int]) -&gt; \"MessageType\":\n    \"\"\"Sets or clears the busy state of the device.\n\n    Args:\n        client: TrezorClient instance\n        expiry_ms: Expiry time in milliseconds. If None, clears the busy state.\n\n    Returns:\n        str: Success message\n\n    In the busy state the device shows a \"Do not disconnect\" message instead of the homescreen.\n    Setting `expiry_ms=None` clears the busy state.\n    \"\"\"\n    ret = client.call(messages.SetBusy(expiry_ms=expiry_ms))\n    client.refresh_features()\n    return ret\n</code></pre>"},{"location":"API/device/#python.src.trezorlib.device.unlock_path","title":"<code>unlock_path(client, n)</code>","text":"<p>Ask device to unlock a subtree of the keychain.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <code>n</code> <code>Address</code> <p>Path to unlock</p> required <p>Returns:</p> Type Description <code>MessageType</code> <p>MAC of the path: bytes</p> Source code in <code>src/trezorlib/device.py</code> <pre><code>@expect(messages.UnlockedPathRequest, field=\"mac\", ret_type=bytes)\ndef unlock_path(client: \"TrezorClient\", n: \"Address\") -&gt; \"MessageType\":\n    \"\"\"Ask device to unlock a subtree of the keychain.\n\n    Args:\n        client: TrezorClient instance\n        n: Path to unlock\n\n    Returns:\n        MAC of the path: bytes\n    \"\"\"\n    resp = client.call(messages.UnlockPath(address_n=n))\n\n    # Cancel the UnlockPath workflow now that we have the authentication code.\n    try:\n        client.call(messages.Cancel())\n    except Cancelled:\n        return resp\n    else:\n        raise TrezorException(\"Unexpected response in UnlockPath flow\")\n</code></pre>"},{"location":"API/device/#python.src.trezorlib.device.wipe","title":"<code>wipe(client)</code>","text":"<p>Wipe the device.</p> <p>In normal mode, this will erase the seed and all user settings.</p> <p>When sent in bootloader mode, this will also completely erase the firmware.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>MessageType</code> <p>Success message</p> Source code in <code>src/trezorlib/device.py</code> <pre><code>@expect(messages.Success, field=\"message\", ret_type=str)\n@session\ndef wipe(client: \"TrezorClient\") -&gt; \"MessageType\":\n    \"\"\"Wipe the device.\n\n    In normal mode, this will erase the seed and all user settings.\n\n    When sent in bootloader mode, this will also completely erase the firmware.\n\n    Args:\n        client: TrezorClient instance\n\n    Returns:\n        str: Success message\n    \"\"\"\n    ret = client.call(messages.WipeDevice())\n    client.init_device()\n    return ret\n</code></pre>"},{"location":"API/ethereum/","title":"Ethereum","text":"<pre><code>from trezorlib import ethereum\n</code></pre>"},{"location":"API/ethereum/#python.src.trezorlib.ethereum.get_address","title":"<code>get_address(client, n, show_display=False)</code>","text":"<p>Get Ethereum address for specified path.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>initialized TrezorClient</p> required <code>n</code> <code>Address</code> <p>BIP32 path</p> required <code>show_display</code> <code>bool</code> <p>show address on device before sending the result</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>MessageType</code> <p>Ethereum address</p> Source code in <code>src/trezorlib/ethereum.py</code> <pre><code>@expect(messages.EthereumAddress, field=\"address\", ret_type=str)\ndef get_address(\n    client: \"TrezorClient\", n: \"Address\", show_display: bool = False\n) -&gt; \"MessageType\":\n    \"\"\"Get Ethereum address for specified path.\n\n    Args:\n        client: initialized TrezorClient\n        n: BIP32 path\n        show_display: show address on device before sending the result\n\n    Returns:\n        str: Ethereum address\n    \"\"\"\n    return client.call(\n        messages.EthereumGetAddress(address_n=n, show_display=show_display)\n    )\n</code></pre>"},{"location":"API/ethereum/#python.src.trezorlib.ethereum.get_public_node","title":"<code>get_public_node(client, n, show_display=False)</code>","text":"<p>Get Ethereum public node for specified path.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>initialized TrezorClient</p> required <code>n</code> <code>Address</code> <p>BIP32 path</p> required <code>show_display</code> <code>bool</code> <p>show public key on device before sending the result</p> <code>False</code> <p>Returns:</p> Type Description <code>MessageType</code> <p>EthereumPublicKey message</p> Source code in <code>src/trezorlib/ethereum.py</code> <pre><code>@expect(messages.EthereumPublicKey)\ndef get_public_node(\n    client: \"TrezorClient\", n: \"Address\", show_display: bool = False\n) -&gt; \"MessageType\":\n    \"\"\"Get Ethereum public node for specified path.\n\n    Args:\n        client: initialized TrezorClient\n        n: BIP32 path\n        show_display: show public key on device before sending the result\n\n    Returns:\n        EthereumPublicKey message\n    \"\"\"\n    return client.call(\n        messages.EthereumGetPublicKey(address_n=n, show_display=show_display)\n    )\n</code></pre>"},{"location":"API/ethereum/#python.src.trezorlib.ethereum.parse_array_n","title":"<code>parse_array_n(type_name)</code>","text":"<p>Parse N in type[] where \"type\" can itself be an array type. Source code in <code>src/trezorlib/ethereum.py</code> <pre><code>def parse_array_n(type_name: str) -&gt; Optional[int]:\n    \"\"\"Parse N in type[&lt;N&gt;] where \"type\" can itself be an array type.\"\"\"\n    # sign that it is a dynamic array - we do not know &lt;N&gt;\n    if type_name.endswith(\"[]\"):\n        return None\n\n    start_idx = type_name.rindex(\"[\") + 1\n    return int(type_name[start_idx:-1])\n</code></pre>"},{"location":"API/ethereum/#python.src.trezorlib.ethereum.parse_type_n","title":"<code>parse_type_n(type_name)</code>","text":"<p>Parse N from type. Example: \"uint256\" -&gt; 256. Source code in <code>src/trezorlib/ethereum.py</code> <pre><code>def parse_type_n(type_name: str) -&gt; int:\n    \"\"\"Parse N from type&lt;N&gt;. Example: \"uint256\" -&gt; 256.\"\"\"\n    match = re.search(r\"\\d+$\", type_name)\n    if match:\n        return int(match.group(0))\n    else:\n        raise ValueError(f\"Could not parse type&lt;N&gt; from {type_name}.\")\n</code></pre>"},{"location":"API/ethereum/#python.src.trezorlib.ethereum.sanitize_typed_data","title":"<code>sanitize_typed_data(data)</code>","text":"<p>Remove properties from a message object that are not defined per EIP-712.</p> Source code in <code>src/trezorlib/ethereum.py</code> <pre><code>def sanitize_typed_data(data: dict) -&gt; dict:\n    \"\"\"Remove properties from a message object that are not defined per EIP-712.\"\"\"\n    REQUIRED_KEYS = (\"types\", \"primaryType\", \"domain\", \"message\")\n    sanitized_data = {key: data[key] for key in REQUIRED_KEYS}\n    sanitized_data[\"types\"].setdefault(\"EIP712Domain\", [])\n    return sanitized_data\n</code></pre>"},{"location":"API/ethereum/#python.src.trezorlib.ethereum.sign_message","title":"<code>sign_message(client, n, message)</code>","text":"<p>Sign a message by an Ethereum address.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>initialized TrezorClient</p> required <code>n</code> <code>Address</code> <p>BIP32 path</p> required <code>message</code> <code>AnyStr</code> <p>message to sign</p> required <p>Returns:</p> Type Description <code>MessageType</code> <p>EthereumMessageSignature message</p> Source code in <code>src/trezorlib/ethereum.py</code> <pre><code>@expect(messages.EthereumMessageSignature)\ndef sign_message(\n    client: \"TrezorClient\", n: \"Address\", message: AnyStr\n) -&gt; \"MessageType\":\n    \"\"\"Sign a message by an Ethereum address.\n\n    Args:\n        client: initialized TrezorClient\n        n: BIP32 path\n        message: message to sign\n\n    Returns:\n        EthereumMessageSignature message\n    \"\"\"\n    return client.call(\n        messages.EthereumSignMessage(\n            address_n=n, message=prepare_message_bytes(message)\n        )\n    )\n</code></pre>"},{"location":"API/ethereum/#python.src.trezorlib.ethereum.sign_tx","title":"<code>sign_tx(client, n, nonce, gas_price, gas_limit, to, value, data=None, chain_id=None, tx_type=None)</code>","text":"<p>Sign Ethereum transaction.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>initialized TrezorClient</p> required <code>n</code> <code>Address</code> <p>BIP32 path</p> required <code>nonce</code> <code>int</code> <p>transaction nonce - &lt;=256 bit unsigned big endian</p> required <code>gas_price</code> <code>int</code> <p>gas price - &lt;=256 bit unsigned big endian (in wei)</p> required <code>gas_limit</code> <code>int</code> <p>gas limit - &lt;=256 bit unsigned big endian</p> required <code>to</code> <code>str</code> <p>recipient address</p> required <code>value</code> <code>int</code> <p>transaction value - &lt;=256 bit unsigned big endian (in wei)</p> required <code>data</code> <code>Optional[bytes]</code> <p>transaction data</p> <code>None</code> <code>chain_id</code> <code>Optional[int]</code> <p>chain Id for EIP 155</p> <code>None</code> <code>tx_type</code> <code>Optional[int]</code> <p>transaction type - used for Wanchain</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>signature-v</p> <code>bytes</code> <p>signature-r</p> <code>bytes</code> <p>signature-s</p> Source code in <code>src/trezorlib/ethereum.py</code> <pre><code>@session\ndef sign_tx(\n    client: \"TrezorClient\",\n    n: \"Address\",\n    nonce: int,\n    gas_price: int,\n    gas_limit: int,\n    to: str,\n    value: int,\n    data: Optional[bytes] = None,\n    chain_id: Optional[int] = None,\n    tx_type: Optional[int] = None,\n) -&gt; Tuple[int, bytes, bytes]:\n    \"\"\"Sign Ethereum transaction.\n\n    Args:\n        client: initialized TrezorClient\n        n: BIP32 path\n        nonce: transaction nonce - &lt;=256 bit unsigned big endian\n        gas_price: gas price - &lt;=256 bit unsigned big endian (in wei)\n        gas_limit: gas limit - &lt;=256 bit unsigned big endian\n        to: recipient address\n        value: transaction value - &lt;=256 bit unsigned big endian (in wei)\n        data: transaction data\n        chain_id: chain Id for EIP 155\n        tx_type: transaction type - used for Wanchain\n\n    Returns:\n        signature-v\n        signature-r\n        signature-s\n    \"\"\"\n    if chain_id is None:\n        raise exceptions.TrezorException(\"Chain ID cannot be undefined\")\n\n    msg = messages.EthereumSignTx(\n        address_n=n,\n        nonce=int_to_big_endian(nonce),\n        gas_price=int_to_big_endian(gas_price),\n        gas_limit=int_to_big_endian(gas_limit),\n        value=int_to_big_endian(value),\n        to=to,\n        chain_id=chain_id,\n        tx_type=tx_type,\n    )\n\n    if data is None:\n        data = b\"\"\n\n    msg.data_length = len(data)\n    data, chunk = data[1024:], data[:1024]\n    msg.data_initial_chunk = chunk\n\n    response = client.call(msg)\n    assert isinstance(response, messages.EthereumTxRequest)\n\n    while response.data_length is not None:\n        data_length = response.data_length\n        data, chunk = data[data_length:], data[:data_length]\n        response = client.call(messages.EthereumTxAck(data_chunk=chunk))\n        assert isinstance(response, messages.EthereumTxRequest)\n\n    assert response.signature_v is not None\n    assert response.signature_r is not None\n    assert response.signature_s is not None\n\n    # https://github.com/trezor/trezor-core/pull/311\n    # only signature bit returned. recalculate signature_v\n    if response.signature_v &lt;= 1:\n        response.signature_v += 2 * chain_id + 35\n\n    return response.signature_v, response.signature_r, response.signature_s\n</code></pre>"},{"location":"API/ethereum/#python.src.trezorlib.ethereum.sign_tx_eip1559","title":"<code>sign_tx_eip1559(client, n, *, nonce, gas_limit, to, value, data=b'', chain_id, max_gas_fee, max_priority_fee, access_list=None)</code>","text":"<p>Sign Ethereum EIP-1559 transaction.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>initialized TrezorClient</p> required <code>n</code> <code>Address</code> <p>BIP32 path</p> required <code>nonce</code> <code>int</code> <p>transaction nonce - &lt;=256 bit unsigned big endian</p> required <code>gas_limit</code> <code>int</code> <p>gas limit - &lt;=256 bit unsigned big endian</p> required <code>to</code> <code>str</code> <p>recipient address</p> required <code>value</code> <code>int</code> <p>transaction value - &lt;=256 bit unsigned big endian (in wei)</p> required <code>data</code> <code>bytes</code> <p>transaction data</p> <code>b''</code> <code>chain_id</code> <code>int</code> <p>chain Id for EIP 155</p> required <code>max_gas_fee</code> <code>int</code> <p>maximum gas fee - &lt;=256 bit unsigned big endian (in wei)</p> required <code>max_priority_fee</code> <code>int</code> <p>maximum priority fee - &lt;=256 bit unsigned big endian (in wei)</p> required <code>access_list</code> <code>Optional[List[EthereumAccessList]]</code> <p>access list</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>signature-v</p> <code>bytes</code> <p>signature-r</p> <code>bytes</code> <p>signature-s</p> Source code in <code>src/trezorlib/ethereum.py</code> <pre><code>@session\ndef sign_tx_eip1559(\n    client: \"TrezorClient\",\n    n: \"Address\",\n    *,\n    nonce: int,\n    gas_limit: int,\n    to: str,\n    value: int,\n    data: bytes = b\"\",\n    chain_id: int,\n    max_gas_fee: int,\n    max_priority_fee: int,\n    access_list: Optional[List[messages.EthereumAccessList]] = None,\n) -&gt; Tuple[int, bytes, bytes]:\n    \"\"\"Sign Ethereum EIP-1559 transaction.\n\n    Args:\n        client: initialized TrezorClient\n        n: BIP32 path\n        nonce: transaction nonce - &lt;=256 bit unsigned big endian\n        gas_limit: gas limit - &lt;=256 bit unsigned big endian\n        to: recipient address\n        value: transaction value - &lt;=256 bit unsigned big endian (in wei)\n        data: transaction data\n        chain_id: chain Id for EIP 155\n        max_gas_fee: maximum gas fee - &lt;=256 bit unsigned big endian (in wei)\n        max_priority_fee: maximum priority fee - &lt;=256 bit unsigned big endian (in wei)\n        access_list: access list\n\n    Returns:\n        signature-v\n        signature-r\n        signature-s\n    \"\"\"\n    length = len(data)\n    data, chunk = data[1024:], data[:1024]\n    msg = messages.EthereumSignTxEIP1559(\n        address_n=n,\n        nonce=int_to_big_endian(nonce),\n        gas_limit=int_to_big_endian(gas_limit),\n        value=int_to_big_endian(value),\n        to=to,\n        chain_id=chain_id,\n        max_gas_fee=int_to_big_endian(max_gas_fee),\n        max_priority_fee=int_to_big_endian(max_priority_fee),\n        access_list=access_list,\n        data_length=length,\n        data_initial_chunk=chunk,\n    )\n\n    response = client.call(msg)\n    assert isinstance(response, messages.EthereumTxRequest)\n\n    while response.data_length is not None:\n        data_length = response.data_length\n        data, chunk = data[data_length:], data[:data_length]\n        response = client.call(messages.EthereumTxAck(data_chunk=chunk))\n        assert isinstance(response, messages.EthereumTxRequest)\n\n    assert response.signature_v is not None\n    assert response.signature_r is not None\n    assert response.signature_s is not None\n    return response.signature_v, response.signature_r, response.signature_s\n</code></pre>"},{"location":"API/ethereum/#python.src.trezorlib.ethereum.sign_typed_data","title":"<code>sign_typed_data(client, n, data, *, metamask_v4_compat=True)</code>","text":"<p>Sign EIP-712 Ethereum typed data.</p> <p>Not available on Trezor One.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>initialized TrezorClient</p> required <code>n</code> <code>Address</code> <p>BIP32 path</p> required <code>data</code> <code>Dict[str, Any]</code> <p>typed data to sign</p> required <code>metamask_v4_compat</code> <code>bool</code> <p>be compatible with Metamask v4 implementation</p> <code>True</code> <p>Returns:</p> Type Description <code>MessageType</code> <p>EthereumTypedDataSignature message</p> Source code in <code>src/trezorlib/ethereum.py</code> <pre><code>@expect(messages.EthereumTypedDataSignature)\ndef sign_typed_data(\n    client: \"TrezorClient\",\n    n: \"Address\",\n    data: Dict[str, Any],\n    *,\n    metamask_v4_compat: bool = True,\n) -&gt; \"MessageType\":\n    \"\"\"Sign EIP-712 Ethereum typed data.\n\n    Not available on Trezor One.\n\n    Args:\n        client: initialized TrezorClient\n        n: BIP32 path\n        data: typed data to sign\n        metamask_v4_compat: be compatible with Metamask v4 implementation\n\n    Returns:\n        EthereumTypedDataSignature message\n    \"\"\"\n    data = sanitize_typed_data(data)\n    types = data[\"types\"]\n\n    request = messages.EthereumSignTypedData(\n        address_n=n,\n        primary_type=data[\"primaryType\"],\n        metamask_v4_compat=metamask_v4_compat,\n    )\n    response = client.call(request)\n\n    # Sending all the types\n    while isinstance(response, messages.EthereumTypedDataStructRequest):\n        struct_name = response.name\n\n        members: List[\"messages.EthereumStructMember\"] = []\n        for field in types[struct_name]:\n            field_type = get_field_type(field[\"type\"], types)\n            struct_member = messages.EthereumStructMember(\n                type=field_type,\n                name=field[\"name\"],\n            )\n            members.append(struct_member)\n\n        request = messages.EthereumTypedDataStructAck(members=members)\n        response = client.call(request)\n\n    # Sending the whole message that should be signed\n    while isinstance(response, messages.EthereumTypedDataValueRequest):\n        root_index = response.member_path[0]\n        # Index 0 is for the domain data, 1 is for the actual message\n        if root_index == 0:\n            member_typename = \"EIP712Domain\"\n            member_data = data[\"domain\"]\n        elif root_index == 1:\n            member_typename = data[\"primaryType\"]\n            member_data = data[\"message\"]\n        else:\n            client.cancel()\n            raise exceptions.TrezorException(\"Root index can only be 0 or 1\")\n\n        # It can be asking for a nested structure (the member path being [X, Y, Z, ...])\n        # TODO: what to do when the value is missing (for example in recursive types)?\n        for index in response.member_path[1:]:\n            if isinstance(member_data, dict):\n                member_def = types[member_typename][index]\n                member_typename = member_def[\"type\"]\n                member_data = member_data[member_def[\"name\"]]\n            elif isinstance(member_data, list):\n                member_typename = typeof_array(member_typename)\n                member_data = member_data[index]\n\n        # If we were asked for a list, first sending its length and we will be receiving\n        # requests for individual elements later\n        if isinstance(member_data, list):\n            # Sending the length as uint16\n            encoded_data = len(member_data).to_bytes(2, \"big\")\n        else:\n            encoded_data = encode_data(member_data, member_typename)\n\n        request = messages.EthereumTypedDataValueAck(value=encoded_data)\n        response = client.call(request)\n\n    return response\n</code></pre>"},{"location":"API/ethereum/#python.src.trezorlib.ethereum.sign_typed_data_hash","title":"<code>sign_typed_data_hash(client, n, domain_hash, message_hash)</code>","text":"<p>Sign EIP-712 typed data hash.</p> <p>Only available on Trezor One that cannot run the full EIP-712 <code>sign_typed_data</code> workflow.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>initialized TrezorClient</p> required <code>n</code> <code>Address</code> <p>BIP32 path</p> required <code>domain_hash</code> <code>bytes</code> <p>Hash of domainSeparator of typed data to be signed</p> required <code>message_hash</code> <code>Optional[bytes]</code> <p>Hash of the typed data to be signed (empty if domain-only data)</p> required <p>Returns:</p> Type Description <code>MessageType</code> <p>EthereumTypedDataSignature message</p> Source code in <code>src/trezorlib/ethereum.py</code> <pre><code>@expect(messages.EthereumTypedDataSignature)\ndef sign_typed_data_hash(\n    client: \"TrezorClient\",\n    n: \"Address\",\n    domain_hash: bytes,\n    message_hash: Optional[bytes],\n) -&gt; \"MessageType\":\n    \"\"\"Sign EIP-712 typed data hash.\n\n    Only available on Trezor One that cannot run the full EIP-712 `sign_typed_data`\n    workflow.\n\n    Args:\n        client: initialized TrezorClient\n        n: BIP32 path\n        domain_hash: Hash of domainSeparator of typed data to be signed\n        message_hash: Hash of the typed data to be signed (empty if domain-only data)\n\n    Returns:\n        EthereumTypedDataSignature message\n    \"\"\"\n    return client.call(\n        messages.EthereumSignTypedHash(\n            address_n=n,\n            domain_separator_hash=domain_hash,\n            message_hash=message_hash,\n        )\n    )\n</code></pre>"},{"location":"API/ethereum/#python.src.trezorlib.ethereum.verify_message","title":"<code>verify_message(client, address, signature, message)</code>","text":"<p>Verify a message signed by an Ethereum address.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>initialized TrezorClient</p> required <code>address</code> <code>str</code> <p>address to verify the signature with</p> required <code>signature</code> <code>bytes</code> <p>signature to verify</p> required <code>message</code> <code>AnyStr</code> <p>message to verify</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the signature is valid, False otherwise</p> Source code in <code>src/trezorlib/ethereum.py</code> <pre><code>def verify_message(\n    client: \"TrezorClient\", address: str, signature: bytes, message: AnyStr\n) -&gt; bool:\n    \"\"\"Verify a message signed by an Ethereum address.\n\n    Args:\n        client: initialized TrezorClient\n        address: address to verify the signature with\n        signature: signature to verify\n        message: message to verify\n\n    Returns:\n        True if the signature is valid, False otherwise\n    \"\"\"\n    try:\n        resp = client.call(\n            messages.EthereumVerifyMessage(\n                address=address,\n                signature=signature,\n                message=prepare_message_bytes(message),\n            )\n        )\n    except exceptions.TrezorFailure:\n        return False\n    return isinstance(resp, messages.Success)\n</code></pre>"},{"location":"API/fido/","title":"FIDO","text":"<pre><code>from trezorlib import fido\n</code></pre>"},{"location":"API/fido/#python.src.trezorlib.fido.add_credential","title":"<code>add_credential(client, credential_id)</code>","text":"<p>Add a credential to the device.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <code>credential_id</code> <code>bytes</code> <p>Credential ID to add</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>MessageType</code> <p>Success message</p> Source code in <code>src/trezorlib/fido.py</code> <pre><code>@expect(messages.Success, field=\"message\", ret_type=str)\ndef add_credential(client: \"TrezorClient\", credential_id: bytes) -&gt; \"MessageType\":\n    \"\"\"Add a credential to the device.\n\n    Args:\n        client: TrezorClient instance\n        credential_id: Credential ID to add\n\n    Returns:\n        str: Success message\n    \"\"\"\n    return client.call(\n        messages.WebAuthnAddResidentCredential(credential_id=credential_id)\n    )\n</code></pre>"},{"location":"API/fido/#python.src.trezorlib.fido.get_next_counter","title":"<code>get_next_counter(client)</code>","text":"<p>Get the next U2F counter value.</p> <p>This is a get-and-increment operation. Subsequent calls to this function will return an ever increasing value. It is not possible to get the current value without incrementing it.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>MessageType</code> <p>Next U2F counter value</p> Source code in <code>src/trezorlib/fido.py</code> <pre><code>@expect(messages.NextU2FCounter, field=\"u2f_counter\", ret_type=int)\ndef get_next_counter(client: \"TrezorClient\") -&gt; \"MessageType\":\n    \"\"\"Get the next U2F counter value.\n\n    This is a get-and-increment operation. Subsequent calls to this function will\n    return an ever increasing value. It is not possible to get the current value\n    without incrementing it.\n\n    Args:\n        client: TrezorClient instance\n\n    Returns:\n        int: Next U2F counter value\n    \"\"\"\n    return client.call(messages.GetNextU2FCounter())\n</code></pre>"},{"location":"API/fido/#python.src.trezorlib.fido.list_credentials","title":"<code>list_credentials(client)</code>","text":"<p>List all credentials stored on the device.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <p>Returns:</p> Type Description <code>MessageType</code> <p>List of credentials stored on the device.</p> Source code in <code>src/trezorlib/fido.py</code> <pre><code>@expect(\n    messages.WebAuthnCredentials,\n    field=\"credentials\",\n    ret_type=List[messages.WebAuthnCredential],\n)\ndef list_credentials(client: \"TrezorClient\") -&gt; \"MessageType\":\n    \"\"\"List all credentials stored on the device.\n\n    Args:\n        client: TrezorClient instance\n\n    Returns:\n        List of credentials stored on the device.\n    \"\"\"\n    return client.call(messages.WebAuthnListResidentCredentials())\n</code></pre>"},{"location":"API/fido/#python.src.trezorlib.fido.remove_credential","title":"<code>remove_credential(client, index)</code>","text":"<p>Remove a credential from the device.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <code>index</code> <code>int</code> <p>Index of the credential to remove</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>MessageType</code> <p>Success message</p> Source code in <code>src/trezorlib/fido.py</code> <pre><code>@expect(messages.Success, field=\"message\", ret_type=str)\ndef remove_credential(client: \"TrezorClient\", index: int) -&gt; \"MessageType\":\n    \"\"\"Remove a credential from the device.\n\n    Args:\n        client: TrezorClient instance\n        index: Index of the credential to remove\n\n    Returns:\n        str: Success message\n    \"\"\"\n    return client.call(messages.WebAuthnRemoveResidentCredential(index=index))\n</code></pre>"},{"location":"API/fido/#python.src.trezorlib.fido.set_counter","title":"<code>set_counter(client, u2f_counter)</code>","text":"<p>Set the U2F counter.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>TrezorClient</code> <p>TrezorClient instance</p> required <code>u2f_counter</code> <code>int</code> <p>U2F counter value</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>MessageType</code> <p>Success message</p> Source code in <code>src/trezorlib/fido.py</code> <pre><code>@expect(messages.Success, field=\"message\", ret_type=str)\ndef set_counter(client: \"TrezorClient\", u2f_counter: int) -&gt; \"MessageType\":\n    \"\"\"Set the U2F counter.\n\n    Args:\n        client: TrezorClient instance\n        u2f_counter: U2F counter value\n\n    Returns:\n        str: Success message\n    \"\"\"\n    return client.call(messages.SetU2FCounter(u2f_counter=u2f_counter))\n</code></pre>"}]}